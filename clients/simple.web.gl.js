/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../westfield/client/runtime/index.js":
/*!********************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/index.js ***!
  \********************************************************/
/*! exports provided: webFS, display, frame, WlDisplayProxy, WlRegistryProxy, WlCallbackProxy, WlCompositorProxy, WlBufferProxy, WlDataOfferProxy, WlDataSourceProxy, WlDataDeviceProxy, WlDataDeviceManagerProxy, WlShellProxy, WlShellSurfaceProxy, WlSurfaceProxy, WlSeatProxy, WlPointerProxy, WlKeyboardProxy, WlTouchProxy, WlOutputProxy, WlRegionProxy, WlSubcompositorProxy, WlSubsurfaceProxy, WlDisplayEvents, WlRegistryEvents, WlCallbackEvents, WlBufferEvents, WlDataOfferEvents, WlDataSourceEvents, WlDataDeviceEvents, WlShellSurfaceEvents, WlSurfaceEvents, WlSeatEvents, WlPointerEvents, WlKeyboardEvents, WlTouchEvents, WlOutputEvents, XdgWmBaseProxy, XdgPositionerProxy, XdgSurfaceProxy, XdgToplevelProxy, XdgPopupProxy, XdgWmBaseEvents, XdgSurfaceEvents, XdgToplevelEvents, XdgPopupEvents, GrWebShmBufferProxy, GrWebShmProxy, GrWebShmBufferEvents, GrWebGlBufferProxy, GrWebGlProxy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "webFS", function() { return webFS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "display", function() { return display; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frame", function() { return frame; });
/* harmony import */ var _src_WebFS__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/WebFS */ "../../../westfield/client/runtime/src/WebFS.js");
/* harmony import */ var _src_Display__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/Display */ "../../../westfield/client/runtime/src/Display.js");
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _src_protocol_WlDisplayProxy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/protocol/WlDisplayProxy */ "../../../westfield/client/runtime/src/protocol/WlDisplayProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlDisplayProxy", function() { return _src_protocol_WlDisplayProxy__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _src_protocol_WlRegistryProxy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/protocol/WlRegistryProxy */ "../../../westfield/client/runtime/src/protocol/WlRegistryProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlRegistryProxy", function() { return _src_protocol_WlRegistryProxy__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _src_protocol_WlCallbackProxy__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/protocol/WlCallbackProxy */ "../../../westfield/client/runtime/src/protocol/WlCallbackProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlCallbackProxy", function() { return _src_protocol_WlCallbackProxy__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _src_protocol_WlCompositorProxy__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/protocol/WlCompositorProxy */ "../../../westfield/client/runtime/src/protocol/WlCompositorProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlCompositorProxy", function() { return _src_protocol_WlCompositorProxy__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _src_protocol_WlBufferProxy__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/protocol/WlBufferProxy */ "../../../westfield/client/runtime/src/protocol/WlBufferProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlBufferProxy", function() { return _src_protocol_WlBufferProxy__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _src_protocol_WlDataOfferProxy__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/protocol/WlDataOfferProxy */ "../../../westfield/client/runtime/src/protocol/WlDataOfferProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlDataOfferProxy", function() { return _src_protocol_WlDataOfferProxy__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _src_protocol_WlDataSourceProxy__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/protocol/WlDataSourceProxy */ "../../../westfield/client/runtime/src/protocol/WlDataSourceProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlDataSourceProxy", function() { return _src_protocol_WlDataSourceProxy__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _src_protocol_WlDataDeviceProxy__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/protocol/WlDataDeviceProxy */ "../../../westfield/client/runtime/src/protocol/WlDataDeviceProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlDataDeviceProxy", function() { return _src_protocol_WlDataDeviceProxy__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _src_protocol_WlDataDeviceManagerProxy__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/protocol/WlDataDeviceManagerProxy */ "../../../westfield/client/runtime/src/protocol/WlDataDeviceManagerProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlDataDeviceManagerProxy", function() { return _src_protocol_WlDataDeviceManagerProxy__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _src_protocol_WlShellProxy__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/protocol/WlShellProxy */ "../../../westfield/client/runtime/src/protocol/WlShellProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlShellProxy", function() { return _src_protocol_WlShellProxy__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _src_protocol_WlShellSurfaceProxy__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/protocol/WlShellSurfaceProxy */ "../../../westfield/client/runtime/src/protocol/WlShellSurfaceProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlShellSurfaceProxy", function() { return _src_protocol_WlShellSurfaceProxy__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _src_protocol_WlSurfaceProxy__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/protocol/WlSurfaceProxy */ "../../../westfield/client/runtime/src/protocol/WlSurfaceProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlSurfaceProxy", function() { return _src_protocol_WlSurfaceProxy__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _src_protocol_WlSeatProxy__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/protocol/WlSeatProxy */ "../../../westfield/client/runtime/src/protocol/WlSeatProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlSeatProxy", function() { return _src_protocol_WlSeatProxy__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _src_protocol_WlPointerProxy__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/protocol/WlPointerProxy */ "../../../westfield/client/runtime/src/protocol/WlPointerProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlPointerProxy", function() { return _src_protocol_WlPointerProxy__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _src_protocol_WlKeyboardProxy__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/protocol/WlKeyboardProxy */ "../../../westfield/client/runtime/src/protocol/WlKeyboardProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlKeyboardProxy", function() { return _src_protocol_WlKeyboardProxy__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony import */ var _src_protocol_WlTouchProxy__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./src/protocol/WlTouchProxy */ "../../../westfield/client/runtime/src/protocol/WlTouchProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlTouchProxy", function() { return _src_protocol_WlTouchProxy__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony import */ var _src_protocol_WlOutputProxy__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./src/protocol/WlOutputProxy */ "../../../westfield/client/runtime/src/protocol/WlOutputProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlOutputProxy", function() { return _src_protocol_WlOutputProxy__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _src_protocol_WlRegionProxy__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./src/protocol/WlRegionProxy */ "../../../westfield/client/runtime/src/protocol/WlRegionProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlRegionProxy", function() { return _src_protocol_WlRegionProxy__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony import */ var _src_protocol_WlSubcompositorProxy__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./src/protocol/WlSubcompositorProxy */ "../../../westfield/client/runtime/src/protocol/WlSubcompositorProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlSubcompositorProxy", function() { return _src_protocol_WlSubcompositorProxy__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _src_protocol_WlSubsurfaceProxy__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./src/protocol/WlSubsurfaceProxy */ "../../../westfield/client/runtime/src/protocol/WlSubsurfaceProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlSubsurfaceProxy", function() { return _src_protocol_WlSubsurfaceProxy__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony import */ var _src_protocol_WlDisplayEvents__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./src/protocol/WlDisplayEvents */ "../../../westfield/client/runtime/src/protocol/WlDisplayEvents.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlDisplayEvents", function() { return _src_protocol_WlDisplayEvents__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony import */ var _src_protocol_WlRegistryEvents__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./src/protocol/WlRegistryEvents */ "../../../westfield/client/runtime/src/protocol/WlRegistryEvents.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlRegistryEvents", function() { return _src_protocol_WlRegistryEvents__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony import */ var _src_protocol_WlCallbackEvents__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./src/protocol/WlCallbackEvents */ "../../../westfield/client/runtime/src/protocol/WlCallbackEvents.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlCallbackEvents", function() { return _src_protocol_WlCallbackEvents__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony import */ var _src_protocol_WlBufferEvents__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./src/protocol/WlBufferEvents */ "../../../westfield/client/runtime/src/protocol/WlBufferEvents.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlBufferEvents", function() { return _src_protocol_WlBufferEvents__WEBPACK_IMPORTED_MODULE_26__["default"]; });

/* harmony import */ var _src_protocol_WlDataOfferEvents__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./src/protocol/WlDataOfferEvents */ "../../../westfield/client/runtime/src/protocol/WlDataOfferEvents.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlDataOfferEvents", function() { return _src_protocol_WlDataOfferEvents__WEBPACK_IMPORTED_MODULE_27__["default"]; });

/* harmony import */ var _src_protocol_WlDataSourceEvents__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./src/protocol/WlDataSourceEvents */ "../../../westfield/client/runtime/src/protocol/WlDataSourceEvents.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlDataSourceEvents", function() { return _src_protocol_WlDataSourceEvents__WEBPACK_IMPORTED_MODULE_28__["default"]; });

/* harmony import */ var _src_protocol_WlDataDeviceEvents__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./src/protocol/WlDataDeviceEvents */ "../../../westfield/client/runtime/src/protocol/WlDataDeviceEvents.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlDataDeviceEvents", function() { return _src_protocol_WlDataDeviceEvents__WEBPACK_IMPORTED_MODULE_29__["default"]; });

/* harmony import */ var _src_protocol_WlShellSurfaceEvents__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./src/protocol/WlShellSurfaceEvents */ "../../../westfield/client/runtime/src/protocol/WlShellSurfaceEvents.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlShellSurfaceEvents", function() { return _src_protocol_WlShellSurfaceEvents__WEBPACK_IMPORTED_MODULE_30__["default"]; });

/* harmony import */ var _src_protocol_WlSurfaceEvents__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./src/protocol/WlSurfaceEvents */ "../../../westfield/client/runtime/src/protocol/WlSurfaceEvents.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlSurfaceEvents", function() { return _src_protocol_WlSurfaceEvents__WEBPACK_IMPORTED_MODULE_31__["default"]; });

/* harmony import */ var _src_protocol_WlSeatEvents__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./src/protocol/WlSeatEvents */ "../../../westfield/client/runtime/src/protocol/WlSeatEvents.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlSeatEvents", function() { return _src_protocol_WlSeatEvents__WEBPACK_IMPORTED_MODULE_32__["default"]; });

/* harmony import */ var _src_protocol_WlPointerEvents__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./src/protocol/WlPointerEvents */ "../../../westfield/client/runtime/src/protocol/WlPointerEvents.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlPointerEvents", function() { return _src_protocol_WlPointerEvents__WEBPACK_IMPORTED_MODULE_33__["default"]; });

/* harmony import */ var _src_protocol_WlKeyboardEvents__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./src/protocol/WlKeyboardEvents */ "../../../westfield/client/runtime/src/protocol/WlKeyboardEvents.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlKeyboardEvents", function() { return _src_protocol_WlKeyboardEvents__WEBPACK_IMPORTED_MODULE_34__["default"]; });

/* harmony import */ var _src_protocol_WlTouchEvents__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./src/protocol/WlTouchEvents */ "../../../westfield/client/runtime/src/protocol/WlTouchEvents.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlTouchEvents", function() { return _src_protocol_WlTouchEvents__WEBPACK_IMPORTED_MODULE_35__["default"]; });

/* harmony import */ var _src_protocol_WlOutputEvents__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./src/protocol/WlOutputEvents */ "../../../westfield/client/runtime/src/protocol/WlOutputEvents.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlOutputEvents", function() { return _src_protocol_WlOutputEvents__WEBPACK_IMPORTED_MODULE_36__["default"]; });

/* harmony import */ var _src_protocol_XdgWmBaseProxy__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./src/protocol/XdgWmBaseProxy */ "../../../westfield/client/runtime/src/protocol/XdgWmBaseProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "XdgWmBaseProxy", function() { return _src_protocol_XdgWmBaseProxy__WEBPACK_IMPORTED_MODULE_37__["default"]; });

/* harmony import */ var _src_protocol_XdgPositionerProxy__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./src/protocol/XdgPositionerProxy */ "../../../westfield/client/runtime/src/protocol/XdgPositionerProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "XdgPositionerProxy", function() { return _src_protocol_XdgPositionerProxy__WEBPACK_IMPORTED_MODULE_38__["default"]; });

/* harmony import */ var _src_protocol_XdgSurfaceProxy__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./src/protocol/XdgSurfaceProxy */ "../../../westfield/client/runtime/src/protocol/XdgSurfaceProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "XdgSurfaceProxy", function() { return _src_protocol_XdgSurfaceProxy__WEBPACK_IMPORTED_MODULE_39__["default"]; });

/* harmony import */ var _src_protocol_XdgToplevelProxy__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./src/protocol/XdgToplevelProxy */ "../../../westfield/client/runtime/src/protocol/XdgToplevelProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "XdgToplevelProxy", function() { return _src_protocol_XdgToplevelProxy__WEBPACK_IMPORTED_MODULE_40__["default"]; });

/* harmony import */ var _src_protocol_XdgPopupProxy__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./src/protocol/XdgPopupProxy */ "../../../westfield/client/runtime/src/protocol/XdgPopupProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "XdgPopupProxy", function() { return _src_protocol_XdgPopupProxy__WEBPACK_IMPORTED_MODULE_41__["default"]; });

/* harmony import */ var _src_protocol_XdgWmBaseEvents__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./src/protocol/XdgWmBaseEvents */ "../../../westfield/client/runtime/src/protocol/XdgWmBaseEvents.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "XdgWmBaseEvents", function() { return _src_protocol_XdgWmBaseEvents__WEBPACK_IMPORTED_MODULE_42__["default"]; });

/* harmony import */ var _src_protocol_XdgSurfaceEvents__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./src/protocol/XdgSurfaceEvents */ "../../../westfield/client/runtime/src/protocol/XdgSurfaceEvents.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "XdgSurfaceEvents", function() { return _src_protocol_XdgSurfaceEvents__WEBPACK_IMPORTED_MODULE_43__["default"]; });

/* harmony import */ var _src_protocol_XdgToplevelEvents__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./src/protocol/XdgToplevelEvents */ "../../../westfield/client/runtime/src/protocol/XdgToplevelEvents.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "XdgToplevelEvents", function() { return _src_protocol_XdgToplevelEvents__WEBPACK_IMPORTED_MODULE_44__["default"]; });

/* harmony import */ var _src_protocol_XdgPopupEvents__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./src/protocol/XdgPopupEvents */ "../../../westfield/client/runtime/src/protocol/XdgPopupEvents.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "XdgPopupEvents", function() { return _src_protocol_XdgPopupEvents__WEBPACK_IMPORTED_MODULE_45__["default"]; });

/* harmony import */ var _src_protocol_GrWebShmBufferProxy__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./src/protocol/GrWebShmBufferProxy */ "../../../westfield/client/runtime/src/protocol/GrWebShmBufferProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GrWebShmBufferProxy", function() { return _src_protocol_GrWebShmBufferProxy__WEBPACK_IMPORTED_MODULE_46__["default"]; });

/* harmony import */ var _src_protocol_GrWebShmProxy__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./src/protocol/GrWebShmProxy */ "../../../westfield/client/runtime/src/protocol/GrWebShmProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GrWebShmProxy", function() { return _src_protocol_GrWebShmProxy__WEBPACK_IMPORTED_MODULE_47__["default"]; });

/* harmony import */ var _src_protocol_GrWebShmBufferEvents__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./src/protocol/GrWebShmBufferEvents */ "../../../westfield/client/runtime/src/protocol/GrWebShmBufferEvents.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GrWebShmBufferEvents", function() { return _src_protocol_GrWebShmBufferEvents__WEBPACK_IMPORTED_MODULE_48__["default"]; });

/* harmony import */ var _src_protocol_GrWebGlBufferProxy__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./src/protocol/GrWebGlBufferProxy */ "../../../westfield/client/runtime/src/protocol/GrWebGlBufferProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GrWebGlBufferProxy", function() { return _src_protocol_GrWebGlBufferProxy__WEBPACK_IMPORTED_MODULE_49__["default"]; });

/* harmony import */ var _src_protocol_GrWebGlProxy__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./src/protocol/GrWebGlProxy */ "../../../westfield/client/runtime/src/protocol/GrWebGlProxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GrWebGlProxy", function() { return _src_protocol_GrWebGlProxy__WEBPACK_IMPORTED_MODULE_50__["default"]; });

/*
MIT License

Copyright (c) 2017 Erik De Rijcke

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/







// core wayland protocol




// import WlShmPoolProxy from './src/protocol/WlShmPoolProxy'
// import WlShmProxy from './src/protocol/WlShmProxy'



















// import WlShmEvents from './src/protocol/WlShmEvents'












// xdg_shell










// web shm




// web gl



/**
 * @type {WebFS}
 */
const webFS = _src_WebFS__WEBPACK_IMPORTED_MODULE_0__["default"].create(_uuidv4())
/**
 * @type {Connection}
 */
const connection = new westfield_runtime_common__WEBPACK_IMPORTED_MODULE_2__["Connection"]()
/**
 * @type {Display}
 */
const display = new _src_Display__WEBPACK_IMPORTED_MODULE_1__["default"](connection)

/**
 * @returns {string}
 * @private
 */
function _uuidv4 () {
  return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
    (c ^ self.crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
  )
}

/**
 * @param {Display}display
 * @param {Connection}connection
 * @param {WebFS}webFS
 * @private
 */
function _setupMessageHandling (display, connection, webFS) {
  /**
   * @type {Array<Array<{buffer: ArrayBuffer, fds: Array<WebFD>}>>}
   * @private
   */
  const _flushQueue = []
  /**
   * @param {MessageEvent}event
   */
  onmessage = (event) => {
    if (connection.closed) { return }

    const webWorkerMessage = /** @type {{protocolMessage:ArrayBuffer, meta:Array<Transferable>}} */event.data
    if (webWorkerMessage.protocolMessage instanceof ArrayBuffer) {
      const buffer = new Uint32Array(/** @type {ArrayBuffer} */webWorkerMessage.protocolMessage)
      const fds = webWorkerMessage.meta.map(transferable => {
        if (transferable instanceof ArrayBuffer) {
          return webFS.fromArrayBuffer(transferable)
        } else if (transferable instanceof ImageBitmap) {
          return webFS.fromImageBitmap(transferable)
        }// else if (transferable instanceof MessagePort) {
        // }
        console.warn(`COMPOSITOR BUG? Unsupported transferable received from compositor: ${transferable}. WebFD will be null.`)
        return null
      })
      try {
        connection.message({ buffer, fds })
      } catch (e) {
        if (display.errorHandler && typeof display.errorHandler === 'function') {
          display.errorHandler(e)
        } else {
          console.error('\tname: ' + e.name + ' message: ' + e.message + ' text: ' + e.text)
          console.error('error object stack: ')
          console.error(e.stack)
        }
      }
    } else {
      console.error(`[web-worker-client] server send an illegal message.`)
      connection.close()
    }
  }

  /**
   * @param {Array<{buffer: ArrayBuffer, fds: Array<WebFD>}>}wireMessages
   * @return {Promise<void>}
   */
  connection.onFlush = async (wireMessages) => {
    _flushQueue.push(wireMessages)

    if (_flushQueue.length > 1) {
      return
    }

    while (_flushQueue.length) {
      const sendWireMessages = _flushQueue[0]

      // convert to single arrayBuffer so it can be send over a data channel using zero copy semantics.
      const messagesSize = sendWireMessages.reduce((previousValue, currentValue) => previousValue + currentValue.buffer.byteLength, 0)

      const sendBuffer = new Uint32Array(new ArrayBuffer(messagesSize))
      let offset = 0
      const meta = []
      for (const wireMessage of sendWireMessages) {
        for (const webFd of wireMessage.fds) {
          const transferable = await webFd.getTransferable()
          meta.push(transferable)
        }
        const message = new Uint32Array(wireMessage.buffer)
        sendBuffer.set(message, offset)
        offset += message.length
      }

      postMessage({ protocolMessage: sendBuffer.buffer, meta }, [sendBuffer.buffer].concat(meta))
      _flushQueue.shift()
    }
  }
}

_setupMessageHandling(display, connection, webFS)

/**
 * @param {WlSurfaceProxy}wlSurfaceProxy
 * @return {function(): Promise<number>}
 */
function frame (wlSurfaceProxy) {
  return () => {
    return new Promise(resolve => {
      const wlCallbackProxy = wlSurfaceProxy.frame()
      wlCallbackProxy.listener = {
        done: (data) => {
          resolve(data)
          wlCallbackProxy.destroy()
        }
      }
    })
  }
}



/***/ }),

/***/ "../../../westfield/client/runtime/src/Display.js":
/*!**************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/Display.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Display; });
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _protocol_WlDisplayProxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./protocol/WlDisplayProxy */ "../../../westfield/client/runtime/src/protocol/WlDisplayProxy.js");
/*
MIT License

Copyright (c) 2017 Erik De Rijcke

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/





class Display {
  /**
   * @param {Connection}connection
   */
  constructor (connection) {
    /**
     * @type {Array<number>}
     * @private
     */
    this._recycledIds = []
    /**
     * @type {Connection}
     * @private
     */
    this._connection = connection
    /**
     * @type {WlDisplayProxy}
     * @private
     */
    this._displayProxy = new _protocol_WlDisplayProxy__WEBPACK_IMPORTED_MODULE_1__["default"](this, this._connection, 1)
    /**
     * @type {number}
     * @private
     */
    this._lastId = 1
    /**
     * @type {function():void}
     * @private
     */
    this._destroyResolve = null
    /**
     * @type {function(error:Error):void}
     * @private
     */
    this._destroyReject = null
    /**
     * @type {Promise<void>}
     * @private
     */
    this._destroyPromise = new Promise(((resolve, reject) => {
      this._destroyResolve = resolve
      this._destroyReject = reject
    }))

    this._displayProxy.listener = {
      /**
       * @param id
       */
      deleteId: (id) => { this._recycledIds.push(id) },
      /**
       * @param proxy
       * @param code
       * @param message
       */
      error: (proxy, code, message) => { this._protocolError(proxy, code, message) }
    }
    /**
     * Set this to have a default 'catch-all' application error handler. Can be null for default behavior.
     * @param {function(error):void|null}
     */
    this.errorHandler = null
  }

  close () {
    if (this._connection.closed) { return }
    this._connection.close()
    this._destroyResolve()
  }

  /**
   * @param {Proxy}proxy
   * @param {number}code
   * @param {string}message
   * @private
   */
  _protocolError (proxy, code, message) {
    if (this._connection.closed) { return }
    this._connection.close()
    this._destroyReject(new Error(`Protocol error. type: ${proxy.constructor.name}, id: ${proxy.id}, code: ${code}, message: ${message}`))
  }

  /**
   * Resolves once the connection is closed normally ie. with a call to close(). The promise will be rejected with an
   * error if the connection is closed abnormally ie when a protocol error is received.
   *
   * @return {Promise<void>}
   */
  onClose () {
    return this._destroyPromise
  }

  /**
   * @return {WlRegistryProxy}
   */
  getRegistry () {
    return this._displayProxy.getRegistry()
  }

  /**
   * For internal use. Generates the id of the next proxy object.
   *
   * @return {number}
   */
  generateNextId () {
    if (this._recycledIds.length) {
      return this._recycledIds.shift()
    } else {
      return ++this._lastId
    }
  }

  /**
   * Wait for the compositor to have send us all remaining events.
   *
   * The data in the resolved promise is the event serial.
   *
   * Don't 'await' this sync call as it will result in a deadlock where the worker will block all incoming events,
   * including the event the resolves the await state. Instead use the classic 'then(..)' construct.
   *
   * @return {Promise<number>}
   */
  sync () {
    return new Promise(resolve => {
      const wlCallbackProxy = this._displayProxy.sync()
      wlCallbackProxy.listener = {
        done: (data) => {
          resolve(data)
          wlCallbackProxy.destroy()
        }
      }
    })
  }

  /**
   * Send queued messages to the compositor.
   */
  flush () {
    this._connection.flush()
  }
}


/***/ }),

/***/ "../../../westfield/client/runtime/src/WebFS.js":
/*!************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/WebFS.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WebFS; });
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");


// TODO This is currently a literal copy of the server implementation. Do all use cases match 1o1 and can we use a single common code base between client & server for WebFS?
class WebFS {
  /**
   * @param {string}fdDomainUUID
   * @return {WebFS}
   */
  static create (fdDomainUUID) {
    return new WebFS(fdDomainUUID)
  }

  /**
   * @param {string}fdDomainUUID
   */
  constructor (fdDomainUUID) {
    /**
     * @type {string}
     * @private
     */
    this._fdDomainUUID = fdDomainUUID
    /**
     * @type {Object.<number,WebFD>}
     * @private
     */
    this._webFDs = {}
    /**
     * @type {number}
     * @private
     */
    this._nextFD = 0
  }

  /**
   * @param {ArrayBuffer} arrayBuffer
   * @return {WebFD}
   */
  fromArrayBuffer (arrayBuffer) {
    if (!(arrayBuffer instanceof ArrayBuffer)) {
      throw new TypeError(`Expected first argument to be of type ArrayBuffer.`)
    }
    const fd = this._nextFD++
    const webFD = new westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["WebFD"](fd, 'ArrayBuffer', this._fdDomainUUID, () => Promise.resolve(arrayBuffer), () => { delete this._webFDs[fd] })
    this._webFDs[fd] = webFD
    return webFD
  }

  /**
   * @param {ImageBitmap}imageBitmap
   * @return {WebFD}
   */
  fromImageBitmap (imageBitmap) {
    if (!(imageBitmap instanceof ImageBitmap)) {
      throw new TypeError(`Expected first argument to be of type ImageBitmap.`)
    }
    const fd = this._nextFD++
    const webFD = new westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["WebFD"](fd, 'ImageBitmap', this._fdDomainUUID, () => Promise.resolve(imageBitmap), () => { delete this._webFDs[fd] })
    this._webFDs[fd] = webFD
    return webFD
  }

  // TODO fromMessagePort

  /**
   * @param {number}fd
   * @return {WebFD}
   */
  getWebFD (fd) {
    return this._webFDs[fd]
  }
}


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/GrWebGlBufferProxy.js":
/*!**********************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/GrWebGlBufferProxy.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/*
 *
 *        Copyright © 2019 Erik De Rijcke
 *
 *        Permission is hereby granted, free of charge, to any person
 *        obtaining a copy of this software and associated documentation files
 *        (the "Software"), to deal in the Software without restriction,
 *        including without limitation the rights to use, copy, modify, merge,
 *        publish, distribute, sublicense, and/or sell copies of the Software,
 *        and to permit persons to whom the Software is furnished to do so,
 *        subject to the following conditions:
 *
 *        The above copyright notice and this permission notice (including the
 *        next paragraph) shall be included in all copies or substantial
 *        portions of the Software.
 *
 *        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *        EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *        NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *        BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *        ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *        CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *        SOFTWARE.
 *    
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]

class GrWebGlBufferProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 *
	 *                Transfer the associated HTML5 web gl buffer contents to the compositor.
	 *            
	 *
	 * @param {WebFD} contents HTML5 web gl image bitmap to transfer to the compositor. 
	 *
	 * @since 1
	 *
	 */
	transfer (contents) {
		this._marshall(this.id, 0, [fileDescriptor(contents)])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {GrWebGlBufferEvents|null}
		 */
		this.listener = null
	}

}
GrWebGlBufferProxy.protocolName = 'gr_web_gl_buffer'

/* harmony default export */ __webpack_exports__["default"] = (GrWebGlBufferProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/GrWebGlProxy.js":
/*!****************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/GrWebGlProxy.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/* harmony import */ var _GrWebGlBufferProxy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GrWebGlBufferProxy */ "../../../westfield/client/runtime/src/protocol/GrWebGlBufferProxy.js");
/* harmony import */ var _WlBufferProxy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WlBufferProxy */ "../../../westfield/client/runtime/src/protocol/WlBufferProxy.js");
/*
 *
 *        Copyright © 2019 Erik De Rijcke
 *
 *        Permission is hereby granted, free of charge, to any person
 *        obtaining a copy of this software and associated documentation files
 *        (the "Software"), to deal in the Software without restriction,
 *        including without limitation the rights to use, copy, modify, merge,
 *        publish, distribute, sublicense, and/or sell copies of the Software,
 *        and to permit persons to whom the Software is furnished to do so,
 *        subject to the following conditions:
 *
 *        The above copyright notice and this permission notice (including the
 *        next paragraph) shall be included in all copies or substantial
 *        portions of the Software.
 *
 *        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *        EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *        NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *        BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *        ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *        CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *        SOFTWARE.
 *    
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]




/**
 *
 *            A singleton global object that provides support for web gl.
 *
 *            Clients can create wl_buffer objects using the create_buffer request.
 *        
 */
class GrWebGlProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 *
	 *                Create a web_gl_buffer object.
	 *            
	 *
	 * @return {GrWebGlBufferProxy} The gr_web_gl buffer to create. 
	 *
	 * @since 1
	 *
	 */
	createWebGlBuffer () {
		return this._marshallConstructor(this.id, 0, _GrWebGlBufferProxy__WEBPACK_IMPORTED_MODULE_2__["default"], [newObject()])
	}

	/**
	 *
	 *                Create a wl_buffer object from a web_array_buffer so it can be used with a surface.
	 *            
	 *
	 * @param {*} grWebGlBuffer The gr_web_gl_buffer to wrap. 
	 * @return {WlBufferProxy} The buffer to create. 
	 *
	 * @since 1
	 *
	 */
	createBuffer (grWebGlBuffer) {
		return this._marshallConstructor(this.id, 1, _WlBufferProxy__WEBPACK_IMPORTED_MODULE_3__["default"], [newObject(), object(grWebGlBuffer)])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {GrWebGlEvents|null}
		 */
		this.listener = null
	}

}
GrWebGlProxy.protocolName = 'gr_web_gl'

/* harmony default export */ __webpack_exports__["default"] = (GrWebGlProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/GrWebShmBufferEvents.js":
/*!************************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/GrWebShmBufferEvents.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GrWebShmBufferEvents; });
/*
 *
 *        Copyright © 2019 Erik De Rijcke
 *
 *        Permission is hereby granted, free of charge, to any person
 *        obtaining a copy of this software and associated documentation files
 *        (the "Software"), to deal in the Software without restriction,
 *        including without limitation the rights to use, copy, modify, merge,
 *        publish, distribute, sublicense, and/or sell copies of the Software,
 *        and to permit persons to whom the Software is furnished to do so,
 *        subject to the following conditions:
 *
 *        The above copyright notice and this permission notice (including the
 *        next paragraph) shall be included in all copies or substantial
 *        portions of the Software.
 *
 *        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *        EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *        NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *        BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *        ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *        CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *        SOFTWARE.
 *    
 */

/**
 * @interface
 */
class GrWebShmBufferEvents {

	/**
	 *
	 *                Detaches a previously attached HTML5 array buffer from the compositor and returns it to the client so
	 *                it can be reused again for writing. After detaching, the array buffer ownership is passed from
	 *                the compositor main thread back to the client.
	 *            
	 *
	 * @param {WebFD} contents An HTML5 array buffer, detached from the compositor 
	 *
	 * @since 1
	 *
	 */
	detach(contents) {}
}



/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/GrWebShmBufferProxy.js":
/*!***********************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/GrWebShmBufferProxy.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/*
 *
 *        Copyright © 2019 Erik De Rijcke
 *
 *        Permission is hereby granted, free of charge, to any person
 *        obtaining a copy of this software and associated documentation files
 *        (the "Software"), to deal in the Software without restriction,
 *        including without limitation the rights to use, copy, modify, merge,
 *        publish, distribute, sublicense, and/or sell copies of the Software,
 *        and to permit persons to whom the Software is furnished to do so,
 *        subject to the following conditions:
 *
 *        The above copyright notice and this permission notice (including the
 *        next paragraph) shall be included in all copies or substantial
 *        portions of the Software.
 *
 *        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *        EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *        NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *        BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *        ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *        CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *        SOFTWARE.
 *    
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]

class GrWebShmBufferProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 *
	 *                Attaches an HTML5 array buffer to the compositor. After attaching, the array buffer ownership is passed
	 *                to the compositor main thread. The array buffer can not be used for writing anymore by the client as
	 *                per HTML5 Transferable objects spec.
	 *
	 *                The pixel format of the attached array buffer must always be RGBA8888 as per HTML5 ImageData spec.
	 *                Stride must always equal width.
	 *            
	 *
	 * @param {WebFD} contents An HTML5 array buffer to attach to the compositor. 
	 *
	 * @since 1
	 *
	 */
	attach (contents) {
		this._marshall(this.id, 0, [fileDescriptor(contents)])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {GrWebShmBufferEvents|null}
		 */
		this.listener = null
	}

	async [0] (message) {
		await this.listener.detach(h(message))
	}

}
GrWebShmBufferProxy.protocolName = 'gr_web_shm_buffer'

/* harmony default export */ __webpack_exports__["default"] = (GrWebShmBufferProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/GrWebShmProxy.js":
/*!*****************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/GrWebShmProxy.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/* harmony import */ var _GrWebShmBufferProxy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GrWebShmBufferProxy */ "../../../westfield/client/runtime/src/protocol/GrWebShmBufferProxy.js");
/* harmony import */ var _WlBufferProxy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WlBufferProxy */ "../../../westfield/client/runtime/src/protocol/WlBufferProxy.js");
/*
 *
 *        Copyright © 2019 Erik De Rijcke
 *
 *        Permission is hereby granted, free of charge, to any person
 *        obtaining a copy of this software and associated documentation files
 *        (the "Software"), to deal in the Software without restriction,
 *        including without limitation the rights to use, copy, modify, merge,
 *        publish, distribute, sublicense, and/or sell copies of the Software,
 *        and to permit persons to whom the Software is furnished to do so,
 *        subject to the following conditions:
 *
 *        The above copyright notice and this permission notice (including the
 *        next paragraph) shall be included in all copies or substantial
 *        portions of the Software.
 *
 *        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *        EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *        MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *        NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *        BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *        ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *        CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *        SOFTWARE.
 *    
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]




/**
 *
 *            A singleton global object that provides support for shared memory through HTML5 array buffers.
 *
 *            Clients can create wl_buffer objects using the create_buffer request.
 *        
 */
class GrWebShmProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 *
	 *                Create a gr_web_shm_buffer object.
	 *            
	 *
	 * @return {GrWebShmBufferProxy} web shm buffer to create 
	 *
	 * @since 1
	 *
	 */
	createWebArrayBuffer () {
		return this._marshallConstructor(this.id, 0, _GrWebShmBufferProxy__WEBPACK_IMPORTED_MODULE_2__["default"], [newObject()])
	}

	/**
	 *
	 *                Create a wl_buffer object from a web_array_buffer so it can be used with a surface.
	 *            
	 *
	 * @param {*} webArrayBuffer The gr_web_array_buffer to wrap 
	 * @param {number} width Buffer width, in pixels. 
	 * @param {number} height Buffer height, in pixels. 
	 * @return {WlBufferProxy} buffer to create 
	 *
	 * @since 1
	 *
	 */
	createBuffer (webArrayBuffer, width, height) {
		return this._marshallConstructor(this.id, 1, _WlBufferProxy__WEBPACK_IMPORTED_MODULE_3__["default"], [newObject(), object(webArrayBuffer), int(width), int(height)])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {GrWebShmEvents|null}
		 */
		this.listener = null
	}

}
GrWebShmProxy.protocolName = 'gr_web_shm'

/* harmony default export */ __webpack_exports__["default"] = (GrWebShmProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/Proxy.js":
/*!*********************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/Proxy.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Proxy; });
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/*
MIT License

Copyright (c) 2017 Erik De Rijcke

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/




class Proxy extends westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["WlObject"] {
  /**
   * @param {Display} display
   * @param {Connection}connection
   * @param {number}id
   */
  constructor (display, connection, id) {
    super(id)
    /**
     * @type {Display}
     * @private
     */
    this.display = display
    /**
     * @type {Connection}
     * @protected
     */
    this._connection = connection
    connection.registerWlObject(this)
  }

  destroy () {
    super.destroy()
    this._connection.unregisterWlObject(this)
  }

  /**
   * For internal use only.
   * @param {number} id
   * @param {number} opcode
   * @param {Function} proxyClass
   * @param {Array<{value: *, type: string, size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}):void}>} argsArray
   * @protected
   */
  _marshallConstructor (id, opcode, proxyClass, argsArray) {
    // construct new object
    const proxy = new proxyClass(this.display, this._connection, this.display.generateNextId())

    // determine required wire message length
    let size = 4 + 2 + 2 // id+size+opcode
    argsArray.forEach(arg => {
      if (arg.type === 'n') {
        arg.value = proxy.id
      }
      size += arg.size
    })

    this._connection.marshallMsg(id, opcode, size, argsArray)

    return proxy
  }

  /**
   * For internal use only.
   * @param {number} id
   * @param {number} opcode
   * @param {Array<{value: *, type: string, size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}):void}>} argsArray
   * @protected
   */
  _marshall (id, opcode, argsArray) {
    // determine required wire message length
    let size = 4 + 2 + 2  // id+size+opcode
    argsArray.forEach(arg => size += arg.size)
    this._connection.marshallMsg(id, opcode, size, argsArray)
  }
}




/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlBufferEvents.js":
/*!******************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlBufferEvents.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WlBufferEvents; });
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlBufferEvents {

	/**
	 *
	 *	Sent when this wl_buffer is no longer used by the compositor.
	 *	The client is now free to reuse or destroy this buffer and its
	 *	backing storage.
	 *
	 *	If a client receives a release event before the frame callback
	 *	requested in the same wl_surface.commit that attaches this
	 *	wl_buffer to a surface, then the client is immediately free to
	 *	reuse the buffer and its backing storage, and does not need a
	 *	second buffer for the next surface content update. Typically
	 *	this is possible, when the compositor maintains a copy of the
	 *	wl_surface contents, e.g. as a GL texture. This is an important
	 *	optimization for GL(ES) compositors with wl_shm clients.
	 *      
	 *
	 *
	 * @since 1
	 *
	 */
	release() {}
}



/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlBufferProxy.js":
/*!*****************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlBufferProxy.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]


/**
 *
 *      A buffer provides the content for a wl_surface. Buffers are
 *      created through factory interfaces such as wl_drm, wl_shm or
 *      similar. It has a width and a height and can be attached to a
 *      wl_surface, but the mechanism by which a client provides and
 *      updates the contents is defined by the buffer factory interface.
 *    
 */
class WlBufferProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 *
	 *	Destroy a buffer. If and how you need to release the backing
	 *	storage is defined by the buffer factory interface.
	 *
	 *	For possible side-effects to a surface, see wl_surface.attach.
	 *      
	 * @since 1
	 *
	 */
	destroy () {
		super.destroy()
		this._marshall(this.id, 0, [])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {WlBufferEvents|null}
		 */
		this.listener = null
	}

	async [0] (message) {
		await this.listener.release()
	}

}
WlBufferProxy.protocolName = 'wl_buffer'

/* harmony default export */ __webpack_exports__["default"] = (WlBufferProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlCallbackEvents.js":
/*!********************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlCallbackEvents.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WlCallbackEvents; });
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlCallbackEvents {

	/**
	 *
	 *	Notify the client when the related request is done.
	 *      
	 *
	 * @param {number} callbackData request-specific data for the callback 
	 *
	 * @since 1
	 *
	 */
	done(callbackData) {}
}



/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlCallbackProxy.js":
/*!*******************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlCallbackProxy.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]


/**
 *
 *      Clients can handle the 'done' event to get notified when
 *      the related request is done.
 *    
 */
class WlCallbackProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {WlCallbackEvents|null}
		 */
		this.listener = null
	}

	async [0] (message) {
		await this.listener.done(u(message))
	}

}
WlCallbackProxy.protocolName = 'wl_callback'

/* harmony default export */ __webpack_exports__["default"] = (WlCallbackProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlCompositorProxy.js":
/*!*********************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlCompositorProxy.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/* harmony import */ var _WlSurfaceProxy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WlSurfaceProxy */ "../../../westfield/client/runtime/src/protocol/WlSurfaceProxy.js");
/* harmony import */ var _WlRegionProxy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WlRegionProxy */ "../../../westfield/client/runtime/src/protocol/WlRegionProxy.js");
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]




/**
 *
 *      A compositor.  This object is a singleton global.  The
 *      compositor is in charge of combining the contents of multiple
 *      surfaces into one displayable output.
 *    
 */
class WlCompositorProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 *
	 *	Ask the compositor to create a new surface.
	 *      
	 *
	 * @return {WlSurfaceProxy} the new surface 
	 *
	 * @since 1
	 *
	 */
	createSurface () {
		return this._marshallConstructor(this.id, 0, _WlSurfaceProxy__WEBPACK_IMPORTED_MODULE_2__["default"], [newObject()])
	}

	/**
	 *
	 *	Ask the compositor to create a new region.
	 *      
	 *
	 * @return {WlRegionProxy} the new region 
	 *
	 * @since 1
	 *
	 */
	createRegion () {
		return this._marshallConstructor(this.id, 1, _WlRegionProxy__WEBPACK_IMPORTED_MODULE_3__["default"], [newObject()])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {WlCompositorEvents|null}
		 */
		this.listener = null
	}

}
WlCompositorProxy.protocolName = 'wl_compositor'

/* harmony default export */ __webpack_exports__["default"] = (WlCompositorProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlDataDeviceEvents.js":
/*!**********************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlDataDeviceEvents.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WlDataDeviceEvents; });
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlDataDeviceEvents {

	/**
	 *
	 *	The data_offer event introduces a new wl_data_offer object,
	 *	which will subsequently be used in either the
	 *	data_device.enter event (for drag-and-drop) or the
	 *	data_device.selection event (for selections).  Immediately
	 *	following the data_device_data_offer event, the new data_offer
	 *	object will send out data_offer.offer events to describe the
	 *	mime types it offers.
	 *      
	 *
	 * @param {number} id the new data_offer object 
	 *
	 * @since 1
	 *
	 */
	dataOffer(id) {}

	/**
	 *
	 *	This event is sent when an active drag-and-drop pointer enters
	 *	a surface owned by the client.  The position of the pointer at
	 *	enter time is provided by the x and y arguments, in surface-local
	 *	coordinates.
	 *      
	 *
	 * @param {number} serial serial number of the enter event 
	 * @param {*} surface client surface entered 
	 * @param {Fixed} x surface-local x coordinate 
	 * @param {Fixed} y surface-local y coordinate 
	 * @param {?*} id source data_offer object 
	 *
	 * @since 1
	 *
	 */
	enter(serial, surface, x, y, id) {}

	/**
	 *
	 *	This event is sent when the drag-and-drop pointer leaves the
	 *	surface and the session ends.  The client must destroy the
	 *	wl_data_offer introduced at enter time at this point.
	 *      
	 *
	 *
	 * @since 1
	 *
	 */
	leave() {}

	/**
	 *
	 *	This event is sent when the drag-and-drop pointer moves within
	 *	the currently focused surface. The new position of the pointer
	 *	is provided by the x and y arguments, in surface-local
	 *	coordinates.
	 *      
	 *
	 * @param {number} time timestamp with millisecond granularity 
	 * @param {Fixed} x surface-local x coordinate 
	 * @param {Fixed} y surface-local y coordinate 
	 *
	 * @since 1
	 *
	 */
	motion(time, x, y) {}

	/**
	 *
	 *	The event is sent when a drag-and-drop operation is ended
	 *	because the implicit grab is removed.
	 *
	 *	The drag-and-drop destination is expected to honor the last action
	 *	received through wl_data_offer.action, if the resulting action is
	 *	"copy" or "move", the destination can still perform
	 *	wl_data_offer.receive requests, and is expected to end all
	 *	transfers with a wl_data_offer.finish request.
	 *
	 *	If the resulting action is "ask", the action will not be considered
	 *	final. The drag-and-drop destination is expected to perform one last
	 *	wl_data_offer.set_actions request, or wl_data_offer.destroy in order
	 *	to cancel the operation.
	 *      
	 *
	 *
	 * @since 1
	 *
	 */
	drop() {}

	/**
	 *
	 *	The selection event is sent out to notify the client of a new
	 *	wl_data_offer for the selection for this device.  The
	 *	data_device.data_offer and the data_offer.offer events are
	 *	sent out immediately before this event to introduce the data
	 *	offer object.  The selection event is sent to a client
	 *	immediately before receiving keyboard focus and when a new
	 *	selection is set while the client has keyboard focus.  The
	 *	data_offer is valid until a new data_offer or NULL is received
	 *	or until the client loses keyboard focus.  The client must
	 *	destroy the previous selection data_offer, if any, upon receiving
	 *	this event.
	 *      
	 *
	 * @param {?*} id selection data_offer object 
	 *
	 * @since 1
	 *
	 */
	selection(id) {}
}



/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlDataDeviceManagerProxy.js":
/*!****************************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlDataDeviceManagerProxy.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/* harmony import */ var _WlDataSourceProxy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WlDataSourceProxy */ "../../../westfield/client/runtime/src/protocol/WlDataSourceProxy.js");
/* harmony import */ var _WlDataDeviceProxy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WlDataDeviceProxy */ "../../../westfield/client/runtime/src/protocol/WlDataDeviceProxy.js");
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]




/**
 *
 *      The wl_data_device_manager is a singleton global object that
 *      provides access to inter-client data transfer mechanisms such as
 *      copy-and-paste and drag-and-drop.  These mechanisms are tied to
 *      a wl_seat and this interface lets a client get a wl_data_device
 *      corresponding to a wl_seat.
 *
 *      Depending on the version bound, the objects created from the bound
 *      wl_data_device_manager object will have different requirements for
 *      functioning properly. See wl_data_source.set_actions,
 *      wl_data_offer.accept and wl_data_offer.finish for details.
 *    
 */
class WlDataDeviceManagerProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 *
	 *	Create a new data source.
	 *      
	 *
	 * @return {WlDataSourceProxy} data source to create 
	 *
	 * @since 1
	 *
	 */
	createDataSource () {
		return this._marshallConstructor(this.id, 0, _WlDataSourceProxy__WEBPACK_IMPORTED_MODULE_2__["default"], [newObject()])
	}

	/**
	 *
	 *	Create a new data device for a given seat.
	 *      
	 *
	 * @param {*} seat seat associated with the data device 
	 * @return {WlDataDeviceProxy} data device to create 
	 *
	 * @since 1
	 *
	 */
	getDataDevice (seat) {
		return this._marshallConstructor(this.id, 1, _WlDataDeviceProxy__WEBPACK_IMPORTED_MODULE_3__["default"], [newObject(), object(seat)])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {WlDataDeviceManagerEvents|null}
		 */
		this.listener = null
	}

}
WlDataDeviceManagerProxy.protocolName = 'wl_data_device_manager'

WlDataDeviceManagerProxy.DndAction = {
  /**
   * no action
   */
  none: 0,
  /**
   * copy action
   */
  copy: 1,
  /**
   * move action
   */
  move: 2,
  /**
   * ask action
   */
  ask: 4
}

/* harmony default export */ __webpack_exports__["default"] = (WlDataDeviceManagerProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlDataDeviceProxy.js":
/*!*********************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlDataDeviceProxy.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/* harmony import */ var _WlDataOfferProxy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WlDataOfferProxy */ "../../../westfield/client/runtime/src/protocol/WlDataOfferProxy.js");
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]



/**
 *
 *      There is one wl_data_device per seat which can be obtained
 *      from the global wl_data_device_manager singleton.
 *
 *      A wl_data_device provides access to inter-client data transfer
 *      mechanisms such as copy-and-paste and drag-and-drop.
 *    
 */
class WlDataDeviceProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 *
	 *	This request asks the compositor to start a drag-and-drop
	 *	operation on behalf of the client.
	 *
	 *	The source argument is the data source that provides the data
	 *	for the eventual data transfer. If source is NULL, enter, leave
	 *	and motion events are sent only to the client that initiated the
	 *	drag and the client is expected to handle the data passing
	 *	internally.
	 *
	 *	The origin surface is the surface where the drag originates and
	 *	the client must have an active implicit grab that matches the
	 *	serial.
	 *
	 *	The icon surface is an optional (can be NULL) surface that
	 *	provides an icon to be moved around with the cursor.  Initially,
	 *	the top-left corner of the icon surface is placed at the cursor
	 *	hotspot, but subsequent wl_surface.attach request can move the
	 *	relative position. Attach requests must be confirmed with
	 *	wl_surface.commit as usual. The icon surface is given the role of
	 *	a drag-and-drop icon. If the icon surface already has another role,
	 *	it raises a protocol error.
	 *
	 *	The current and pending input regions of the icon wl_surface are
	 *	cleared, and wl_surface.set_input_region is ignored until the
	 *	wl_surface is no longer used as the icon surface. When the use
	 *	as an icon ends, the current and pending input regions become
	 *	undefined, and the wl_surface is unmapped.
	 *      
	 *
	 * @param {?*} source data source for the eventual transfer 
	 * @param {*} origin surface where the drag originates 
	 * @param {?*} icon drag-and-drop icon surface 
	 * @param {number} serial serial number of the implicit grab on the origin 
	 *
	 * @since 1
	 *
	 */
	startDrag (source, origin, icon, serial) {
		this._marshall(this.id, 0, [objectOptional(source), object(origin), objectOptional(icon), uint(serial)])
	}

	/**
	 *
	 *	This request asks the compositor to set the selection
	 *	to the data from the source on behalf of the client.
	 *
	 *	To unset the selection, set the source to NULL.
	 *      
	 *
	 * @param {?*} source data source for the selection 
	 * @param {number} serial serial number of the event that triggered this request 
	 *
	 * @since 1
	 *
	 */
	setSelection (source, serial) {
		this._marshall(this.id, 1, [objectOptional(source), uint(serial)])
	}

	/**
	 *
	 *	This request destroys the data device.
	 *      
	 * @since 2
	 *
	 */
	release () {
		super.destroy()
		this._marshall(this.id, 2, [])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {WlDataDeviceEvents|null}
		 */
		this.listener = null
	}

	async [0] (message) {
		await this.listener.dataOffer(new _WlDataOfferProxy__WEBPACK_IMPORTED_MODULE_2__["default"](this._connection, n(message)))
	}

	async [1] (message) {
		await this.listener.enter(u(message), o(message, false, this._connection), f(message), f(message), o(message, true, this._connection))
	}

	async [2] (message) {
		await this.listener.leave()
	}

	async [3] (message) {
		await this.listener.motion(u(message), f(message), f(message))
	}

	async [4] (message) {
		await this.listener.drop()
	}

	async [5] (message) {
		await this.listener.selection(o(message, true, this._connection))
	}

}
WlDataDeviceProxy.protocolName = 'wl_data_device'

WlDataDeviceProxy.Error = {
  /**
   * given wl_surface has another role
   */
  role: 0
}

/* harmony default export */ __webpack_exports__["default"] = (WlDataDeviceProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlDataOfferEvents.js":
/*!*********************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlDataOfferEvents.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WlDataOfferEvents; });
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlDataOfferEvents {

	/**
	 *
	 *	Sent immediately after creating the wl_data_offer object.  One
	 *	event per offered mime type.
	 *      
	 *
	 * @param {string} mimeType offered mime type 
	 *
	 * @since 1
	 *
	 */
	offer(mimeType) {}

	/**
	 *
	 *	This event indicates the actions offered by the data source. It
	 *	will be sent right after wl_data_device.enter, or anytime the source
	 *	side changes its offered actions through wl_data_source.set_actions.
	 *      
	 *
	 * @param {number} sourceActions actions offered by the data source 
	 *
	 * @since 3
	 *
	 */
	sourceActions(sourceActions) {}

	/**
	 *
	 *	This event indicates the action selected by the compositor after
	 *	matching the source/destination side actions. Only one action (or
	 *	none) will be offered here.
	 *
	 *	This event can be emitted multiple times during the drag-and-drop
	 *	operation in response to destination side action changes through
	 *	wl_data_offer.set_actions.
	 *
	 *	This event will no longer be emitted after wl_data_device.drop
	 *	happened on the drag-and-drop destination, the client must
	 *	honor the last action received, or the last preferred one set
	 *	through wl_data_offer.set_actions when handling an "ask" action.
	 *
	 *	Compositors may also change the selected action on the fly, mainly
	 *	in response to keyboard modifier changes during the drag-and-drop
	 *	operation.
	 *
	 *	The most recent action received is always the valid one. Prior to
	 *	receiving wl_data_device.drop, the chosen action may change (e.g.
	 *	due to keyboard modifiers being pressed). At the time of receiving
	 *	wl_data_device.drop the drag-and-drop destination must honor the
	 *	last action received.
	 *
	 *	Action changes may still happen after wl_data_device.drop,
	 *	especially on "ask" actions, where the drag-and-drop destination
	 *	may choose another action afterwards. Action changes happening
	 *	at this stage are always the result of inter-client negotiation, the
	 *	compositor shall no longer be able to induce a different action.
	 *
	 *	Upon "ask" actions, it is expected that the drag-and-drop destination
	 *	may potentially choose a different action and/or mime type,
	 *	based on wl_data_offer.source_actions and finally chosen by the
	 *	user (e.g. popping up a menu with the available options). The
	 *	final wl_data_offer.set_actions and wl_data_offer.accept requests
	 *	must happen before the call to wl_data_offer.finish.
	 *      
	 *
	 * @param {number} dndAction action selected by the compositor 
	 *
	 * @since 3
	 *
	 */
	action(dndAction) {}
}



/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlDataOfferProxy.js":
/*!********************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlDataOfferProxy.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]


/**
 *
 *      A wl_data_offer represents a piece of data offered for transfer
 *      by another client (the source client).  It is used by the
 *      copy-and-paste and drag-and-drop mechanisms.  The offer
 *      describes the different mime types that the data can be
 *      converted to and provides the mechanism for transferring the
 *      data directly from the source client.
 *    
 */
class WlDataOfferProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 *
	 *	Indicate that the client can accept the given mime type, or
	 *	NULL for not accepted.
	 *
	 *	For objects of version 2 or older, this request is used by the
	 *	client to give feedback whether the client can receive the given
	 *	mime type, or NULL if none is accepted; the feedback does not
	 *	determine whether the drag-and-drop operation succeeds or not.
	 *
	 *	For objects of version 3 or newer, this request determines the
	 *	final result of the drag-and-drop operation. If the end result
	 *	is that no mime types were accepted, the drag-and-drop operation
	 *	will be cancelled and the corresponding drag source will receive
	 *	wl_data_source.cancelled. Clients may still use this event in
	 *	conjunction with wl_data_source.action for feedback.
	 *      
	 *
	 * @param {number} serial serial number of the accept request 
	 * @param {?string} mimeType mime type accepted by the client 
	 *
	 * @since 1
	 *
	 */
	accept (serial, mimeType) {
		this._marshall(this.id, 0, [uint(serial), stringOptional(mimeType)])
	}

	/**
	 *
	 *	To transfer the offered data, the client issues this request
	 *	and indicates the mime type it wants to receive.  The transfer
	 *	happens through the passed file descriptor (typically created
	 *	with the pipe system call).  The source client writes the data
	 *	in the mime type representation requested and then closes the
	 *	file descriptor.
	 *
	 *	The receiving client reads from the read end of the pipe until
	 *	EOF and then closes its end, at which point the transfer is
	 *	complete.
	 *
	 *	This request may happen multiple times for different mime types,
	 *	both before and after wl_data_device.drop. Drag-and-drop destination
	 *	clients may preemptively fetch data or examine it more closely to
	 *	determine acceptance.
	 *      
	 *
	 * @param {string} mimeType mime type desired by receiver 
	 * @param {WebFD} fd file descriptor for data transfer 
	 *
	 * @since 1
	 *
	 */
	receive (mimeType, fd) {
		this._marshall(this.id, 1, [string(mimeType), fileDescriptor(fd)])
	}

	/**
	 *
	 *	Destroy the data offer.
	 *      
	 * @since 1
	 *
	 */
	destroy () {
		super.destroy()
		this._marshall(this.id, 2, [])
	}

	/**
	 *
	 *	Notifies the compositor that the drag destination successfully
	 *	finished the drag-and-drop operation.
	 *
	 *	Upon receiving this request, the compositor will emit
	 *	wl_data_source.dnd_finished on the drag source client.
	 *
	 *	It is a client error to perform other requests than
	 *	wl_data_offer.destroy after this one. It is also an error to perform
	 *	this request after a NULL mime type has been set in
	 *	wl_data_offer.accept or no action was received through
	 *	wl_data_offer.action.
	 *      
	 * @since 3
	 *
	 */
	finish () {
		this._marshall(this.id, 3, [])
	}

	/**
	 *
	 *	Sets the actions that the destination side client supports for
	 *	this operation. This request may trigger the emission of
	 *	wl_data_source.action and wl_data_offer.action events if the compositor
	 *	needs to change the selected action.
	 *
	 *	This request can be called multiple times throughout the
	 *	drag-and-drop operation, typically in response to wl_data_device.enter
	 *	or wl_data_device.motion events.
	 *
	 *	This request determines the final result of the drag-and-drop
	 *	operation. If the end result is that no action is accepted,
	 *	the drag source will receive wl_drag_source.cancelled.
	 *
	 *	The dnd_actions argument must contain only values expressed in the
	 *	wl_data_device_manager.dnd_actions enum, and the preferred_action
	 *	argument must only contain one of those values set, otherwise it
	 *	will result in a protocol error.
	 *
	 *	While managing an "ask" action, the destination drag-and-drop client
	 *	may perform further wl_data_offer.receive requests, and is expected
	 *	to perform one last wl_data_offer.set_actions request with a preferred
	 *	action other than "ask" (and optionally wl_data_offer.accept) before
	 *	requesting wl_data_offer.finish, in order to convey the action selected
	 *	by the user. If the preferred action is not in the
	 *	wl_data_offer.source_actions mask, an error will be raised.
	 *
	 *	If the "ask" action is dismissed (e.g. user cancellation), the client
	 *	is expected to perform wl_data_offer.destroy right away.
	 *
	 *	This request can only be made on drag-and-drop offers, a protocol error
	 *	will be raised otherwise.
	 *      
	 *
	 * @param {number} dndActions actions supported by the destination client 
	 * @param {number} preferredAction action preferred by the destination client 
	 *
	 * @since 3
	 *
	 */
	setActions (dndActions, preferredAction) {
		this._marshall(this.id, 4, [uint(dndActions), uint(preferredAction)])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {WlDataOfferEvents|null}
		 */
		this.listener = null
	}

	async [0] (message) {
		await this.listener.offer(s(message, false))
	}

	async [1] (message) {
		await this.listener.sourceActions(u(message))
	}

	async [2] (message) {
		await this.listener.action(u(message))
	}

}
WlDataOfferProxy.protocolName = 'wl_data_offer'

WlDataOfferProxy.Error = {
  /**
   * finish request was called untimely
   */
  invalidFinish: 0,
  /**
   * action mask contains invalid values
   */
  invalidActionMask: 1,
  /**
   * action argument has an invalid value
   */
  invalidAction: 2,
  /**
   * offer doesn't accept this request
   */
  invalidOffer: 3
}

/* harmony default export */ __webpack_exports__["default"] = (WlDataOfferProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlDataSourceEvents.js":
/*!**********************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlDataSourceEvents.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WlDataSourceEvents; });
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlDataSourceEvents {

	/**
	 *
	 *	Sent when a target accepts pointer_focus or motion events.  If
	 *	a target does not accept any of the offered types, type is NULL.
	 *
	 *	Used for feedback during drag-and-drop.
	 *      
	 *
	 * @param {?string} mimeType mime type accepted by the target 
	 *
	 * @since 1
	 *
	 */
	target(mimeType) {}

	/**
	 *
	 *	Request for data from the client.  Send the data as the
	 *	specified mime type over the passed file descriptor, then
	 *	close it.
	 *      
	 *
	 * @param {string} mimeType mime type for the data 
	 * @param {WebFD} fd file descriptor for the data 
	 *
	 * @since 1
	 *
	 */
	send(mimeType, fd) {}

	/**
	 *
	 *	This data source is no longer valid. There are several reasons why
	 *	this could happen:
	 *
	 *	- The data source has been replaced by another data source.
	 *	- The drag-and-drop operation was performed, but the drop destination
	 *	  did not accept any of the mime types offered through
	 *	  wl_data_source.target.
	 *	- The drag-and-drop operation was performed, but the drop destination
	 *	  did not select any of the actions present in the mask offered through
	 *	  wl_data_source.action.
	 *	- The drag-and-drop operation was performed but didn't happen over a
	 *	  surface.
	 *	- The compositor cancelled the drag-and-drop operation (e.g. compositor
	 *	  dependent timeouts to avoid stale drag-and-drop transfers).
	 *
	 *	The client should clean up and destroy this data source.
	 *
	 *	For objects of version 2 or older, wl_data_source.cancelled will
	 *	only be emitted if the data source was replaced by another data
	 *	source.
	 *      
	 *
	 *
	 * @since 1
	 *
	 */
	cancelled() {}

	/**
	 *
	 *	The user performed the drop action. This event does not indicate
	 *	acceptance, wl_data_source.cancelled may still be emitted afterwards
	 *	if the drop destination does not accept any mime type.
	 *
	 *	However, this event might however not be received if the compositor
	 *	cancelled the drag-and-drop operation before this event could happen.
	 *
	 *	Note that the data_source may still be used in the future and should
	 *	not be destroyed here.
	 *      
	 *
	 *
	 * @since 3
	 *
	 */
	dndDropPerformed() {}

	/**
	 *
	 *	The drop destination finished interoperating with this data
	 *	source, so the client is now free to destroy this data source and
	 *	free all associated data.
	 *
	 *	If the action used to perform the operation was "move", the
	 *	source can now delete the transferred data.
	 *      
	 *
	 *
	 * @since 3
	 *
	 */
	dndFinished() {}

	/**
	 *
	 *	This event indicates the action selected by the compositor after
	 *	matching the source/destination side actions. Only one action (or
	 *	none) will be offered here.
	 *
	 *	This event can be emitted multiple times during the drag-and-drop
	 *	operation, mainly in response to destination side changes through
	 *	wl_data_offer.set_actions, and as the data device enters/leaves
	 *	surfaces.
	 *
	 *	It is only possible to receive this event after
	 *	wl_data_source.dnd_drop_performed if the drag-and-drop operation
	 *	ended in an "ask" action, in which case the final wl_data_source.action
	 *	event will happen immediately before wl_data_source.dnd_finished.
	 *
	 *	Compositors may also change the selected action on the fly, mainly
	 *	in response to keyboard modifier changes during the drag-and-drop
	 *	operation.
	 *
	 *	The most recent action received is always the valid one. The chosen
	 *	action may change alongside negotiation (e.g. an "ask" action can turn
	 *	into a "move" operation), so the effects of the final action must
	 *	always be applied in wl_data_offer.dnd_finished.
	 *
	 *	Clients can trigger cursor surface changes from this point, so
	 *	they reflect the current action.
	 *      
	 *
	 * @param {number} dndAction action selected by the compositor 
	 *
	 * @since 3
	 *
	 */
	action(dndAction) {}
}



/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlDataSourceProxy.js":
/*!*********************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlDataSourceProxy.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]


/**
 *
 *      The wl_data_source object is the source side of a wl_data_offer.
 *      It is created by the source client in a data transfer and
 *      provides a way to describe the offered data and a way to respond
 *      to requests to transfer the data.
 *    
 */
class WlDataSourceProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 *
	 *	This request adds a mime type to the set of mime types
	 *	advertised to targets.  Can be called several times to offer
	 *	multiple types.
	 *      
	 *
	 * @param {string} mimeType mime type offered by the data source 
	 *
	 * @since 1
	 *
	 */
	offer (mimeType) {
		this._marshall(this.id, 0, [string(mimeType)])
	}

	/**
	 *
	 *	Destroy the data source.
	 *      
	 * @since 1
	 *
	 */
	destroy () {
		super.destroy()
		this._marshall(this.id, 1, [])
	}

	/**
	 *
	 *	Sets the actions that the source side client supports for this
	 *	operation. This request may trigger wl_data_source.action and
	 *	wl_data_offer.action events if the compositor needs to change the
	 *	selected action.
	 *
	 *	The dnd_actions argument must contain only values expressed in the
	 *	wl_data_device_manager.dnd_actions enum, otherwise it will result
	 *	in a protocol error.
	 *
	 *	This request must be made once only, and can only be made on sources
	 *	used in drag-and-drop, so it must be performed before
	 *	wl_data_device.start_drag. Attempting to use the source other than
	 *	for drag-and-drop will raise a protocol error.
	 *      
	 *
	 * @param {number} dndActions actions supported by the data source 
	 *
	 * @since 3
	 *
	 */
	setActions (dndActions) {
		this._marshall(this.id, 2, [uint(dndActions)])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {WlDataSourceEvents|null}
		 */
		this.listener = null
	}

	async [0] (message) {
		await this.listener.target(s(message, true))
	}

	async [1] (message) {
		await this.listener.send(s(message, false), h(message))
	}

	async [2] (message) {
		await this.listener.cancelled()
	}

	async [3] (message) {
		await this.listener.dndDropPerformed()
	}

	async [4] (message) {
		await this.listener.dndFinished()
	}

	async [5] (message) {
		await this.listener.action(u(message))
	}

}
WlDataSourceProxy.protocolName = 'wl_data_source'

WlDataSourceProxy.Error = {
  /**
   * action mask contains invalid values
   */
  invalidActionMask: 0,
  /**
   * source doesn't accept this request
   */
  invalidSource: 1
}

/* harmony default export */ __webpack_exports__["default"] = (WlDataSourceProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlDisplayEvents.js":
/*!*******************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlDisplayEvents.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WlDisplayEvents; });
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlDisplayEvents {

	/**
	 *
	 *	The error event is sent out when a fatal (non-recoverable)
	 *	error has occurred.  The object_id argument is the object
	 *	where the error occurred, most often in response to a request
	 *	to that object.  The code identifies the error and is defined
	 *	by the object interface.  As such, each interface defines its
	 *	own set of error codes.  The message is a brief description
	 *	of the error, for (debugging) convenience.
	 *      
	 *
	 * @param {*} objectId object where the error occurred 
	 * @param {number} code error code 
	 * @param {string} message error description 
	 *
	 * @since 1
	 *
	 */
	error(objectId, code, message) {}

	/**
	 *
	 *	This event is used internally by the object ID management
	 *	logic.  When a client deletes an object, the server will send
	 *	this event to acknowledge that it has seen the delete request.
	 *	When the client receives this event, it will know that it can
	 *	safely reuse the object ID.
	 *      
	 *
	 * @param {number} id deleted object ID 
	 *
	 * @since 1
	 *
	 */
	deleteId(id) {}
}



/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlDisplayProxy.js":
/*!******************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlDisplayProxy.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/* harmony import */ var _WlCallbackProxy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WlCallbackProxy */ "../../../westfield/client/runtime/src/protocol/WlCallbackProxy.js");
/* harmony import */ var _WlRegistryProxy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WlRegistryProxy */ "../../../westfield/client/runtime/src/protocol/WlRegistryProxy.js");
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]




/**
 *
 *      The core global object.  This is a special singleton object.  It
 *      is used for internal Wayland protocol features.
 *    
 */
class WlDisplayProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 *
	 *	The sync request asks the server to emit the 'done' event
	 *	on the returned wl_callback object.  Since requests are
	 *	handled in-order and events are delivered in-order, this can
	 *	be used as a barrier to ensure all previous requests and the
	 *	resulting events have been handled.
	 *
	 *	The object returned by this request will be destroyed by the
	 *	compositor after the callback is fired and as such the client must not
	 *	attempt to use it after that point.
	 *
	 *	The callback_data passed in the callback is the event serial.
	 *      
	 *
	 * @return {WlCallbackProxy} callback object for the sync request 
	 *
	 * @since 1
	 *
	 */
	sync () {
		return this._marshallConstructor(this.id, 0, _WlCallbackProxy__WEBPACK_IMPORTED_MODULE_2__["default"], [newObject()])
	}

	/**
	 *
	 *	This request creates a registry object that allows the client
	 *	to list and bind the global objects available from the
	 *	compositor.
	 *      
	 *
	 * @return {WlRegistryProxy} global registry object 
	 *
	 * @since 1
	 *
	 */
	getRegistry () {
		return this._marshallConstructor(this.id, 1, _WlRegistryProxy__WEBPACK_IMPORTED_MODULE_3__["default"], [newObject()])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {WlDisplayEvents|null}
		 */
		this.listener = null
	}

	async [0] (message) {
		await this.listener.error(o(message, false, this._connection), u(message), s(message, false))
	}

	async [1] (message) {
		await this.listener.deleteId(u(message))
	}

}
WlDisplayProxy.protocolName = 'wl_display'

WlDisplayProxy.Error = {
  /**
   * server couldn't find object
   */
  invalidObject: 0,
  /**
   * method doesn't exist on the specified interface
   */
  invalidMethod: 1,
  /**
   * server is out of memory
   */
  noMemory: 2
}

/* harmony default export */ __webpack_exports__["default"] = (WlDisplayProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlKeyboardEvents.js":
/*!********************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlKeyboardEvents.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WlKeyboardEvents; });
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlKeyboardEvents {

	/**
	 *
	 *	This event provides a file descriptor to the client which can be
	 *	memory-mapped to provide a keyboard mapping description.
	 *      
	 *
	 * @param {number} format keymap format 
	 * @param {WebFD} fd keymap file descriptor 
	 * @param {number} size keymap size, in bytes 
	 *
	 * @since 1
	 *
	 */
	keymap(format, fd, size) {}

	/**
	 *
	 *	Notification that this seat's keyboard focus is on a certain
	 *	surface.
	 *      
	 *
	 * @param {number} serial serial number of the enter event 
	 * @param {*} surface surface gaining keyboard focus 
	 * @param {ArrayBuffer} keys the currently pressed keys 
	 *
	 * @since 1
	 *
	 */
	enter(serial, surface, keys) {}

	/**
	 *
	 *	Notification that this seat's keyboard focus is no longer on
	 *	a certain surface.
	 *
	 *	The leave notification is sent before the enter notification
	 *	for the new focus.
	 *      
	 *
	 * @param {number} serial serial number of the leave event 
	 * @param {*} surface surface that lost keyboard focus 
	 *
	 * @since 1
	 *
	 */
	leave(serial, surface) {}

	/**
	 *
	 *	A key was pressed or released.
	 *	The time argument is a timestamp with millisecond
	 *	granularity, with an undefined base.
	 *      
	 *
	 * @param {number} serial serial number of the key event 
	 * @param {number} time timestamp with millisecond granularity 
	 * @param {number} key key that produced the event 
	 * @param {number} state physical state of the key 
	 *
	 * @since 1
	 *
	 */
	key(serial, time, key, state) {}

	/**
	 *
	 *	Notifies clients that the modifier and/or group state has
	 *	changed, and it should update its local state.
	 *      
	 *
	 * @param {number} serial serial number of the modifiers event 
	 * @param {number} modsDepressed depressed modifiers 
	 * @param {number} modsLatched latched modifiers 
	 * @param {number} modsLocked locked modifiers 
	 * @param {number} group keyboard layout 
	 *
	 * @since 1
	 *
	 */
	modifiers(serial, modsDepressed, modsLatched, modsLocked, group) {}

	/**
	 *
	 *	Informs the client about the keyboard's repeat rate and delay.
	 *
	 *	This event is sent as soon as the wl_keyboard object has been created,
	 *	and is guaranteed to be received by the client before any key press
	 *	event.
	 *
	 *	Negative values for either rate or delay are illegal. A rate of zero
	 *	will disable any repeating (regardless of the value of delay).
	 *
	 *	This event can be sent later on as well with a new value if necessary,
	 *	so clients should continue listening for the event past the creation
	 *	of wl_keyboard.
	 *      
	 *
	 * @param {number} rate the rate of repeating keys in characters per second 
	 * @param {number} delay delay in milliseconds since key down until repeating starts 
	 *
	 * @since 4
	 *
	 */
	repeatInfo(rate, delay) {}
}



/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlKeyboardProxy.js":
/*!*******************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlKeyboardProxy.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]


/**
 *
 *      The wl_keyboard interface represents one or more keyboards
 *      associated with a seat.
 *    
 */
class WlKeyboardProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 * @since 3
	 *
	 */
	release () {
		super.destroy()
		this._marshall(this.id, 0, [])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {WlKeyboardEvents|null}
		 */
		this.listener = null
	}

	async [0] (message) {
		await this.listener.keymap(u(message), h(message), u(message))
	}

	async [1] (message) {
		await this.listener.enter(u(message), o(message, false, this._connection), a(message, false))
	}

	async [2] (message) {
		await this.listener.leave(u(message), o(message, false, this._connection))
	}

	async [3] (message) {
		await this.listener.key(u(message), u(message), u(message), u(message))
	}

	async [4] (message) {
		await this.listener.modifiers(u(message), u(message), u(message), u(message), u(message))
	}

	async [5] (message) {
		await this.listener.repeatInfo(i(message), i(message))
	}

}
WlKeyboardProxy.protocolName = 'wl_keyboard'

WlKeyboardProxy.KeymapFormat = {
  /**
   * no keymap; client must understand how to interpret the raw keycode
   */
  noKeymap: 0,
  /**
   * libxkbcommon compatible; to determine the xkb keycode, clients must add 8 to the key event keycode
   */
  xkbV1: 1
}

WlKeyboardProxy.KeyState = {
  /**
   * key is not pressed
   */
  released: 0,
  /**
   * key is pressed
   */
  pressed: 1
}

/* harmony default export */ __webpack_exports__["default"] = (WlKeyboardProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlOutputEvents.js":
/*!******************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlOutputEvents.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WlOutputEvents; });
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlOutputEvents {

	/**
	 *
	 *	The geometry event describes geometric properties of the output.
	 *	The event is sent when binding to the output object and whenever
	 *	any of the properties change.
	 *      
	 *
	 * @param {number} x x position within the global compositor space 
	 * @param {number} y y position within the global compositor space 
	 * @param {number} physicalWidth width in millimeters of the output 
	 * @param {number} physicalHeight height in millimeters of the output 
	 * @param {number} subpixel subpixel orientation of the output 
	 * @param {string} make textual description of the manufacturer 
	 * @param {string} model textual description of the model 
	 * @param {number} transform transform that maps framebuffer to output 
	 *
	 * @since 1
	 *
	 */
	geometry(x, y, physicalWidth, physicalHeight, subpixel, make, model, transform) {}

	/**
	 *
	 *	The mode event describes an available mode for the output.
	 *
	 *	The event is sent when binding to the output object and there
	 *	will always be one mode, the current mode.  The event is sent
	 *	again if an output changes mode, for the mode that is now
	 *	current.  In other words, the current mode is always the last
	 *	mode that was received with the current flag set.
	 *
	 *	The size of a mode is given in physical hardware units of
	 *	the output device. This is not necessarily the same as
	 *	the output size in the global compositor space. For instance,
	 *	the output may be scaled, as described in wl_output.scale,
	 *	or transformed, as described in wl_output.transform.
	 *      
	 *
	 * @param {number} flags bitfield of mode flags 
	 * @param {number} width width of the mode in hardware units 
	 * @param {number} height height of the mode in hardware units 
	 * @param {number} refresh vertical refresh rate in mHz 
	 *
	 * @since 1
	 *
	 */
	mode(flags, width, height, refresh) {}

	/**
	 *
	 *	This event is sent after all other properties have been
	 *	sent after binding to the output object and after any
	 *	other property changes done after that. This allows
	 *	changes to the output properties to be seen as
	 *	atomic, even if they happen via multiple events.
	 *      
	 *
	 *
	 * @since 2
	 *
	 */
	done() {}

	/**
	 *
	 *	This event contains scaling geometry information
	 *	that is not in the geometry event. It may be sent after
	 *	binding the output object or if the output scale changes
	 *	later. If it is not sent, the client should assume a
	 *	scale of 1.
	 *
	 *	A scale larger than 1 means that the compositor will
	 *	automatically scale surface buffers by this amount
	 *	when rendering. This is used for very high resolution
	 *	displays where applications rendering at the native
	 *	resolution would be too small to be legible.
	 *
	 *	It is intended that scaling aware clients track the
	 *	current output of a surface, and if it is on a scaled
	 *	output it should use wl_surface.set_buffer_scale with
	 *	the scale of the output. That way the compositor can
	 *	avoid scaling the surface, and the client can supply
	 *	a higher detail image.
	 *      
	 *
	 * @param {number} factor scaling factor of output 
	 *
	 * @since 2
	 *
	 */
	scale(factor) {}
}



/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlOutputProxy.js":
/*!*****************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlOutputProxy.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]


/**
 *
 *      An output describes part of the compositor geometry.  The
 *      compositor works in the 'compositor coordinate system' and an
 *      output corresponds to a rectangular area in that space that is
 *      actually visible.  This typically corresponds to a monitor that
 *      displays part of the compositor space.  This object is published
 *      as global during start up, or when a monitor is hotplugged.
 *    
 */
class WlOutputProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 *
	 *	Using this request a client can tell the server that it is not going to
	 *	use the output object anymore.
	 *      
	 * @since 3
	 *
	 */
	release () {
		super.destroy()
		this._marshall(this.id, 0, [])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {WlOutputEvents|null}
		 */
		this.listener = null
	}

	async [0] (message) {
		await this.listener.geometry(i(message), i(message), i(message), i(message), i(message), s(message, false), s(message, false), i(message))
	}

	async [1] (message) {
		await this.listener.mode(u(message), i(message), i(message), i(message))
	}

	async [2] (message) {
		await this.listener.done()
	}

	async [3] (message) {
		await this.listener.scale(i(message))
	}

}
WlOutputProxy.protocolName = 'wl_output'

WlOutputProxy.Subpixel = {
  /**
   * unknown geometry
   */
  unknown: 0,
  /**
   * no geometry
   */
  none: 1,
  /**
   * horizontal RGB
   */
  horizontalRgb: 2,
  /**
   * horizontal BGR
   */
  horizontalBgr: 3,
  /**
   * vertical RGB
   */
  verticalRgb: 4,
  /**
   * vertical BGR
   */
  verticalBgr: 5
}

WlOutputProxy.Transform = {
  /**
   * no transform
   */
  normal: 0,
  /**
   * 90 degrees counter-clockwise
   */
  90: 1,
  /**
   * 180 degrees counter-clockwise
   */
  180: 2,
  /**
   * 270 degrees counter-clockwise
   */
  270: 3,
  /**
   * 180 degree flip around a vertical axis
   */
  flipped: 4,
  /**
   * flip and rotate 90 degrees counter-clockwise
   */
  flipped90: 5,
  /**
   * flip and rotate 180 degrees counter-clockwise
   */
  flipped180: 6,
  /**
   * flip and rotate 270 degrees counter-clockwise
   */
  flipped270: 7
}

WlOutputProxy.Mode = {
  /**
   * indicates this is the current mode
   */
  current: 0x1,
  /**
   * indicates this is the preferred mode
   */
  preferred: 0x2
}

/* harmony default export */ __webpack_exports__["default"] = (WlOutputProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlPointerEvents.js":
/*!*******************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlPointerEvents.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WlPointerEvents; });
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlPointerEvents {

	/**
	 *
	 *	Notification that this seat's pointer is focused on a certain
	 *	surface.
	 *
	 *	When a seat's focus enters a surface, the pointer image
	 *	is undefined and a client should respond to this event by setting
	 *	an appropriate pointer image with the set_cursor request.
	 *      
	 *
	 * @param {number} serial serial number of the enter event 
	 * @param {*} surface surface entered by the pointer 
	 * @param {Fixed} surfaceX surface-local x coordinate 
	 * @param {Fixed} surfaceY surface-local y coordinate 
	 *
	 * @since 1
	 *
	 */
	enter(serial, surface, surfaceX, surfaceY) {}

	/**
	 *
	 *	Notification that this seat's pointer is no longer focused on
	 *	a certain surface.
	 *
	 *	The leave notification is sent before the enter notification
	 *	for the new focus.
	 *      
	 *
	 * @param {number} serial serial number of the leave event 
	 * @param {*} surface surface left by the pointer 
	 *
	 * @since 1
	 *
	 */
	leave(serial, surface) {}

	/**
	 *
	 *	Notification of pointer location change. The arguments
	 *	surface_x and surface_y are the location relative to the
	 *	focused surface.
	 *      
	 *
	 * @param {number} time timestamp with millisecond granularity 
	 * @param {Fixed} surfaceX surface-local x coordinate 
	 * @param {Fixed} surfaceY surface-local y coordinate 
	 *
	 * @since 1
	 *
	 */
	motion(time, surfaceX, surfaceY) {}

	/**
	 *
	 *	Mouse button click and release notifications.
	 *
	 *	The location of the click is given by the last motion or
	 *	enter event.
	 *	The time argument is a timestamp with millisecond
	 *	granularity, with an undefined base.
	 *
	 *	The button is a button code as defined in the Linux kernel's
	 *	linux/input-event-codes.h header file, e.g. BTN_LEFT.
	 *
	 *	Any 16-bit button code value is reserved for future additions to the
	 *	kernel's event code list. All other button codes above 0xFFFF are
	 *	currently undefined but may be used in future versions of this
	 *	protocol.
	 *      
	 *
	 * @param {number} serial serial number of the button event 
	 * @param {number} time timestamp with millisecond granularity 
	 * @param {number} button button that produced the event 
	 * @param {number} state physical state of the button 
	 *
	 * @since 1
	 *
	 */
	button(serial, time, button, state) {}

	/**
	 *
	 *	Scroll and other axis notifications.
	 *
	 *	For scroll events (vertical and horizontal scroll axes), the
	 *	value parameter is the length of a vector along the specified
	 *	axis in a coordinate space identical to those of motion events,
	 *	representing a relative movement along the specified axis.
	 *
	 *	For devices that support movements non-parallel to axes multiple
	 *	axis events will be emitted.
	 *
	 *	When applicable, for example for touch pads, the server can
	 *	choose to emit scroll events where the motion vector is
	 *	equivalent to a motion event vector.
	 *
	 *	When applicable, a client can transform its content relative to the
	 *	scroll distance.
	 *      
	 *
	 * @param {number} time timestamp with millisecond granularity 
	 * @param {number} axis axis type 
	 * @param {Fixed} value length of vector in surface-local coordinate space 
	 *
	 * @since 1
	 *
	 */
	axis(time, axis, value) {}

	/**
	 *
	 *	Indicates the end of a set of events that logically belong together.
	 *	A client is expected to accumulate the data in all events within the
	 *	frame before proceeding.
	 *
	 *	All wl_pointer events before a wl_pointer.frame event belong
	 *	logically together. For example, in a diagonal scroll motion the
	 *	compositor will send an optional wl_pointer.axis_source event, two
	 *	wl_pointer.axis events (horizontal and vertical) and finally a
	 *	wl_pointer.frame event. The client may use this information to
	 *	calculate a diagonal vector for scrolling.
	 *
	 *	When multiple wl_pointer.axis events occur within the same frame,
	 *	the motion vector is the combined motion of all events.
	 *	When a wl_pointer.axis and a wl_pointer.axis_stop event occur within
	 *	the same frame, this indicates that axis movement in one axis has
	 *	stopped but continues in the other axis.
	 *	When multiple wl_pointer.axis_stop events occur within the same
	 *	frame, this indicates that these axes stopped in the same instance.
	 *
	 *	A wl_pointer.frame event is sent for every logical event group,
	 *	even if the group only contains a single wl_pointer event.
	 *	Specifically, a client may get a sequence: motion, frame, button,
	 *	frame, axis, frame, axis_stop, frame.
	 *
	 *	The wl_pointer.enter and wl_pointer.leave events are logical events
	 *	generated by the compositor and not the hardware. These events are
	 *	also grouped by a wl_pointer.frame. When a pointer moves from one
	 *	surface to another, a compositor should group the
	 *	wl_pointer.leave event within the same wl_pointer.frame.
	 *	However, a client must not rely on wl_pointer.leave and
	 *	wl_pointer.enter being in the same wl_pointer.frame.
	 *	Compositor-specific policies may require the wl_pointer.leave and
	 *	wl_pointer.enter event being split across multiple wl_pointer.frame
	 *	groups.
	 *      
	 *
	 *
	 * @since 5
	 *
	 */
	frame() {}

	/**
	 *
	 *	Source information for scroll and other axes.
	 *
	 *	This event does not occur on its own. It is sent before a
	 *	wl_pointer.frame event and carries the source information for
	 *	all events within that frame.
	 *
	 *	The source specifies how this event was generated. If the source is
	 *	wl_pointer.axis_source.finger, a wl_pointer.axis_stop event will be
	 *	sent when the user lifts the finger off the device.
	 *
	 *	If the source is wl_pointer.axis_source.wheel,
	 *	wl_pointer.axis_source.wheel_tilt or
	 *	wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event may
	 *	or may not be sent. Whether a compositor sends an axis_stop event
	 *	for these sources is hardware-specific and implementation-dependent;
	 *	clients must not rely on receiving an axis_stop event for these
	 *	scroll sources and should treat scroll sequences from these scroll
	 *	sources as unterminated by default.
	 *
	 *	This event is optional. If the source is unknown for a particular
	 *	axis event sequence, no event is sent.
	 *	Only one wl_pointer.axis_source event is permitted per frame.
	 *
	 *	The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
	 *	not guaranteed.
	 *      
	 *
	 * @param {number} axisSource source of the axis event 
	 *
	 * @since 5
	 *
	 */
	axisSource(axisSource) {}

	/**
	 *
	 *	Stop notification for scroll and other axes.
	 *
	 *	For some wl_pointer.axis_source types, a wl_pointer.axis_stop event
	 *	is sent to notify a client that the axis sequence has terminated.
	 *	This enables the client to implement kinetic scrolling.
	 *	See the wl_pointer.axis_source documentation for information on when
	 *	this event may be generated.
	 *
	 *	Any wl_pointer.axis events with the same axis_source after this
	 *	event should be considered as the start of a new axis motion.
	 *
	 *	The timestamp is to be interpreted identical to the timestamp in the
	 *	wl_pointer.axis event. The timestamp value may be the same as a
	 *	preceding wl_pointer.axis event.
	 *      
	 *
	 * @param {number} time timestamp with millisecond granularity 
	 * @param {number} axis the axis stopped with this event 
	 *
	 * @since 5
	 *
	 */
	axisStop(time, axis) {}

	/**
	 *
	 *	Discrete step information for scroll and other axes.
	 *
	 *	This event carries the axis value of the wl_pointer.axis event in
	 *	discrete steps (e.g. mouse wheel clicks).
	 *
	 *	This event does not occur on its own, it is coupled with a
	 *	wl_pointer.axis event that represents this axis value on a
	 *	continuous scale. The protocol guarantees that each axis_discrete
	 *	event is always followed by exactly one axis event with the same
	 *	axis number within the same wl_pointer.frame. Note that the protocol
	 *	allows for other events to occur between the axis_discrete and
	 *	its coupled axis event, including other axis_discrete or axis
	 *	events.
	 *
	 *	This event is optional; continuous scrolling devices
	 *	like two-finger scrolling on touchpads do not have discrete
	 *	steps and do not generate this event.
	 *
	 *	The discrete value carries the directional information. e.g. a value
	 *	of -2 is two steps towards the negative direction of this axis.
	 *
	 *	The axis number is identical to the axis number in the associated
	 *	axis event.
	 *
	 *	The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
	 *	not guaranteed.
	 *      
	 *
	 * @param {number} axis axis type 
	 * @param {number} discrete number of steps 
	 *
	 * @since 5
	 *
	 */
	axisDiscrete(axis, discrete) {}
}



/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlPointerProxy.js":
/*!******************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlPointerProxy.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]


/**
 *
 *      The wl_pointer interface represents one or more input devices,
 *      such as mice, which control the pointer location and pointer_focus
 *      of a seat.
 *
 *      The wl_pointer interface generates motion, enter and leave
 *      events for the surfaces that the pointer is located over,
 *      and button and axis events for button presses, button releases
 *      and scrolling.
 *    
 */
class WlPointerProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 *
	 *	Set the pointer surface, i.e., the surface that contains the
	 *	pointer image (cursor). This request gives the surface the role
	 *	of a cursor. If the surface already has another role, it raises
	 *	a protocol error.
	 *
	 *	The cursor actually changes only if the pointer
	 *	focus for this device is one of the requesting client's surfaces
	 *	or the surface parameter is the current pointer surface. If
	 *	there was a previous surface set with this request it is
	 *	replaced. If surface is NULL, the pointer image is hidden.
	 *
	 *	The parameters hotspot_x and hotspot_y define the position of
	 *	the pointer surface relative to the pointer location. Its
	 *	top-left corner is always at (x, y) - (hotspot_x, hotspot_y),
	 *	where (x, y) are the coordinates of the pointer location, in
	 *	surface-local coordinates.
	 *
	 *	On surface.attach requests to the pointer surface, hotspot_x
	 *	and hotspot_y are decremented by the x and y parameters
	 *	passed to the request. Attach must be confirmed by
	 *	wl_surface.commit as usual.
	 *
	 *	The hotspot can also be updated by passing the currently set
	 *	pointer surface to this request with new values for hotspot_x
	 *	and hotspot_y.
	 *
	 *	The current and pending input regions of the wl_surface are
	 *	cleared, and wl_surface.set_input_region is ignored until the
	 *	wl_surface is no longer used as the cursor. When the use as a
	 *	cursor ends, the current and pending input regions become
	 *	undefined, and the wl_surface is unmapped.
	 *      
	 *
	 * @param {number} serial serial number of the enter event 
	 * @param {?*} surface pointer surface 
	 * @param {number} hotspotX surface-local x coordinate 
	 * @param {number} hotspotY surface-local y coordinate 
	 *
	 * @since 1
	 *
	 */
	setCursor (serial, surface, hotspotX, hotspotY) {
		this._marshall(this.id, 0, [uint(serial), objectOptional(surface), int(hotspotX), int(hotspotY)])
	}

	/**
	 *
	 *	Using this request a client can tell the server that it is not going to
	 *	use the pointer object anymore.
	 *
	 *	This request destroys the pointer proxy object, so clients must not call
	 *	wl_pointer_destroy() after using this request.
	 *      
	 * @since 3
	 *
	 */
	release () {
		super.destroy()
		this._marshall(this.id, 1, [])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {WlPointerEvents|null}
		 */
		this.listener = null
	}

	async [0] (message) {
		await this.listener.enter(u(message), o(message, false, this._connection), f(message), f(message))
	}

	async [1] (message) {
		await this.listener.leave(u(message), o(message, false, this._connection))
	}

	async [2] (message) {
		await this.listener.motion(u(message), f(message), f(message))
	}

	async [3] (message) {
		await this.listener.button(u(message), u(message), u(message), u(message))
	}

	async [4] (message) {
		await this.listener.axis(u(message), u(message), f(message))
	}

	async [5] (message) {
		await this.listener.frame()
	}

	async [6] (message) {
		await this.listener.axisSource(u(message))
	}

	async [7] (message) {
		await this.listener.axisStop(u(message), u(message))
	}

	async [8] (message) {
		await this.listener.axisDiscrete(u(message), i(message))
	}

}
WlPointerProxy.protocolName = 'wl_pointer'

WlPointerProxy.Error = {
  /**
   * given wl_surface has another role
   */
  role: 0
}

WlPointerProxy.ButtonState = {
  /**
   * the button is not pressed
   */
  released: 0,
  /**
   * the button is pressed
   */
  pressed: 1
}

WlPointerProxy.Axis = {
  /**
   * vertical axis
   */
  verticalScroll: 0,
  /**
   * horizontal axis
   */
  horizontalScroll: 1
}

WlPointerProxy.AxisSource = {
  /**
   * a physical wheel rotation
   */
  wheel: 0,
  /**
   * finger on a touch surface
   */
  finger: 1,
  /**
   * continuous coordinate space
   */
  continuous: 2,
  /**
   * a physical wheel tilt
   */
  wheelTilt: 3
}

/* harmony default export */ __webpack_exports__["default"] = (WlPointerProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlRegionProxy.js":
/*!*****************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlRegionProxy.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]


/**
 *
 *      A region object describes an area.
 *
 *      Region objects are used to describe the opaque and input
 *      regions of a surface.
 *    
 */
class WlRegionProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 *
	 *	Destroy the region.  This will invalidate the object ID.
	 *      
	 * @since 1
	 *
	 */
	destroy () {
		super.destroy()
		this._marshall(this.id, 0, [])
	}

	/**
	 *
	 *	Add the specified rectangle to the region.
	 *      
	 *
	 * @param {number} x region-local x coordinate 
	 * @param {number} y region-local y coordinate 
	 * @param {number} width rectangle width 
	 * @param {number} height rectangle height 
	 *
	 * @since 1
	 *
	 */
	add (x, y, width, height) {
		this._marshall(this.id, 1, [int(x), int(y), int(width), int(height)])
	}

	/**
	 *
	 *	Subtract the specified rectangle from the region.
	 *      
	 *
	 * @param {number} x region-local x coordinate 
	 * @param {number} y region-local y coordinate 
	 * @param {number} width rectangle width 
	 * @param {number} height rectangle height 
	 *
	 * @since 1
	 *
	 */
	subtract (x, y, width, height) {
		this._marshall(this.id, 2, [int(x), int(y), int(width), int(height)])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {WlRegionEvents|null}
		 */
		this.listener = null
	}

}
WlRegionProxy.protocolName = 'wl_region'

/* harmony default export */ __webpack_exports__["default"] = (WlRegionProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlRegistryEvents.js":
/*!********************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlRegistryEvents.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WlRegistryEvents; });
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlRegistryEvents {

	/**
	 *
	 *	Notify the client of global objects.
	 *
	 *	The event notifies the client that a global object with
	 *	the given name is now available, and it implements the
	 *	given version of the given interface.
	 *      
	 *
	 * @param {number} name numeric name of the global object 
	 * @param {string} interface interface implemented by the object 
	 * @param {number} version interface version 
	 *
	 * @since 1
	 *
	 */
	global(name, interface_, version) {}

	/**
	 *
	 *	Notify the client of removed global objects.
	 *
	 *	This event notifies the client that the global identified
	 *	by name is no longer available.  If the client bound to
	 *	the global using the bind request, the client should now
	 *	destroy that object.
	 *
	 *	The object remains valid and requests to the object will be
	 *	ignored until the client destroys it, to avoid races between
	 *	the global going away and a client sending a request to it.
	 *      
	 *
	 * @param {number} name numeric name of the global object 
	 *
	 * @since 1
	 *
	 */
	globalRemove(name) {}
}



/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlRegistryProxy.js":
/*!*******************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlRegistryProxy.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]


/**
 *
 *      The singleton global registry object.  The server has a number of
 *      global objects that are available to all clients.  These objects
 *      typically represent an actual object in the server (for example,
 *      an input device) or they are singleton objects that provide
 *      extension functionality.
 *
 *      When a client creates a registry object, the registry object
 *      will emit a global event for each global currently in the
 *      registry.  Globals come and go as a result of device or
 *      monitor hotplugs, reconfiguration or other events, and the
 *      registry will send out global and global_remove events to
 *      keep the client up to date with the changes.  To mark the end
 *      of the initial burst of events, the client can use the
 *      wl_display.sync request immediately after calling
 *      wl_display.get_registry.
 *
 *      A client can bind to a global object by using the bind
 *      request.  This creates a client-side handle that lets the object
 *      emit events to the client and lets the client invoke requests on
 *      the object.
 *    
 */
class WlRegistryProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {
	/**
	* Bind a new object to the global.
	*
	* Binds a new, client-created object to the server using the specified name as the identifier.
	*
	* @param {number} name unique numeric name of the global
	* @param {string} interface_ interface implemented by the new object
	* @param {Function} proxyClass
	* @param {number} version The version used and supported by the client
	* @return {Object} a new bounded object
	*/
	bind (name, interface_, proxyClass, version) {
		return this._marshallConstructor(this.id, 0, proxyClass, [uint(name), string(interface_), uint(version), newObject()])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {WlRegistryEvents|null}
		 */
		this.listener = null
	}

	async [0] (message) {
		await this.listener.global(u(message), s(message, false), u(message))
	}

	async [1] (message) {
		await this.listener.globalRemove(u(message))
	}

}
WlRegistryProxy.protocolName = 'wl_registry'

/* harmony default export */ __webpack_exports__["default"] = (WlRegistryProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlSeatEvents.js":
/*!****************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlSeatEvents.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WlSeatEvents; });
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlSeatEvents {

	/**
	 *
	 *	This is emitted whenever a seat gains or loses the pointer,
	 *	keyboard or touch capabilities.  The argument is a capability
	 *	enum containing the complete set of capabilities this seat has.
	 *
	 *	When the pointer capability is added, a client may create a
	 *	wl_pointer object using the wl_seat.get_pointer request. This object
	 *	will receive pointer events until the capability is removed in the
	 *	future.
	 *
	 *	When the pointer capability is removed, a client should destroy the
	 *	wl_pointer objects associated with the seat where the capability was
	 *	removed, using the wl_pointer.release request. No further pointer
	 *	events will be received on these objects.
	 *
	 *	In some compositors, if a seat regains the pointer capability and a
	 *	client has a previously obtained wl_pointer object of version 4 or
	 *	less, that object may start sending pointer events again. This
	 *	behavior is considered a misinterpretation of the intended behavior
	 *	and must not be relied upon by the client. wl_pointer objects of
	 *	version 5 or later must not send events if created before the most
	 *	recent event notifying the client of an added pointer capability.
	 *
	 *	The above behavior also applies to wl_keyboard and wl_touch with the
	 *	keyboard and touch capabilities, respectively.
	 *      
	 *
	 * @param {number} capabilities capabilities of the seat 
	 *
	 * @since 1
	 *
	 */
	capabilities(capabilities) {}

	/**
	 *
	 *	In a multiseat configuration this can be used by the client to help
	 *	identify which physical devices the seat represents. Based on
	 *	the seat configuration used by the compositor.
	 *      
	 *
	 * @param {string} name seat identifier 
	 *
	 * @since 2
	 *
	 */
	name(name) {}
}



/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlSeatProxy.js":
/*!***************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlSeatProxy.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/* harmony import */ var _WlPointerProxy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WlPointerProxy */ "../../../westfield/client/runtime/src/protocol/WlPointerProxy.js");
/* harmony import */ var _WlKeyboardProxy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./WlKeyboardProxy */ "../../../westfield/client/runtime/src/protocol/WlKeyboardProxy.js");
/* harmony import */ var _WlTouchProxy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./WlTouchProxy */ "../../../westfield/client/runtime/src/protocol/WlTouchProxy.js");
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]





/**
 *
 *      A seat is a group of keyboards, pointer and touch devices. This
 *      object is published as a global during start up, or when such a
 *      device is hot plugged.  A seat typically has a pointer and
 *      maintains a keyboard focus and a pointer focus.
 *    
 */
class WlSeatProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 *
	 *	The ID provided will be initialized to the wl_pointer interface
	 *	for this seat.
	 *
	 *	This request only takes effect if the seat has the pointer
	 *	capability, or has had the pointer capability in the past.
	 *	It is a protocol violation to issue this request on a seat that has
	 *	never had the pointer capability.
	 *      
	 *
	 * @return {WlPointerProxy} seat pointer 
	 *
	 * @since 1
	 *
	 */
	getPointer () {
		return this._marshallConstructor(this.id, 0, _WlPointerProxy__WEBPACK_IMPORTED_MODULE_2__["default"], [newObject()])
	}

	/**
	 *
	 *	The ID provided will be initialized to the wl_keyboard interface
	 *	for this seat.
	 *
	 *	This request only takes effect if the seat has the keyboard
	 *	capability, or has had the keyboard capability in the past.
	 *	It is a protocol violation to issue this request on a seat that has
	 *	never had the keyboard capability.
	 *      
	 *
	 * @return {WlKeyboardProxy} seat keyboard 
	 *
	 * @since 1
	 *
	 */
	getKeyboard () {
		return this._marshallConstructor(this.id, 1, _WlKeyboardProxy__WEBPACK_IMPORTED_MODULE_3__["default"], [newObject()])
	}

	/**
	 *
	 *	The ID provided will be initialized to the wl_touch interface
	 *	for this seat.
	 *
	 *	This request only takes effect if the seat has the touch
	 *	capability, or has had the touch capability in the past.
	 *	It is a protocol violation to issue this request on a seat that has
	 *	never had the touch capability.
	 *      
	 *
	 * @return {WlTouchProxy} seat touch interface 
	 *
	 * @since 1
	 *
	 */
	getTouch () {
		return this._marshallConstructor(this.id, 2, _WlTouchProxy__WEBPACK_IMPORTED_MODULE_4__["default"], [newObject()])
	}

	/**
	 *
	 *	Using this request a client can tell the server that it is not going to
	 *	use the seat object anymore.
	 *      
	 * @since 5
	 *
	 */
	release () {
		super.destroy()
		this._marshall(this.id, 3, [])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {WlSeatEvents|null}
		 */
		this.listener = null
	}

	async [0] (message) {
		await this.listener.capabilities(u(message))
	}

	async [1] (message) {
		await this.listener.name(s(message, false))
	}

}
WlSeatProxy.protocolName = 'wl_seat'

WlSeatProxy.Capability = {
  /**
   * the seat has pointer devices
   */
  pointer: 1,
  /**
   * the seat has one or more keyboards
   */
  keyboard: 2,
  /**
   * the seat has touch devices
   */
  touch: 4
}

/* harmony default export */ __webpack_exports__["default"] = (WlSeatProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlShellProxy.js":
/*!****************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlShellProxy.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/* harmony import */ var _WlShellSurfaceProxy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WlShellSurfaceProxy */ "../../../westfield/client/runtime/src/protocol/WlShellSurfaceProxy.js");
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]



/**
 *
 *      This interface is implemented by servers that provide
 *      desktop-style user interfaces.
 *
 *      It allows clients to associate a wl_shell_surface with
 *      a basic surface.
 *    
 */
class WlShellProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 *
	 *	Create a shell surface for an existing surface. This gives
	 *	the wl_surface the role of a shell surface. If the wl_surface
	 *	already has another role, it raises a protocol error.
	 *
	 *	Only one shell surface can be associated with a given surface.
	 *      
	 *
	 * @param {*} surface surface to be given the shell surface role 
	 * @return {WlShellSurfaceProxy} shell surface to create 
	 *
	 * @since 1
	 *
	 */
	getShellSurface (surface) {
		return this._marshallConstructor(this.id, 0, _WlShellSurfaceProxy__WEBPACK_IMPORTED_MODULE_2__["default"], [newObject(), object(surface)])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {WlShellEvents|null}
		 */
		this.listener = null
	}

}
WlShellProxy.protocolName = 'wl_shell'

WlShellProxy.Error = {
  /**
   * given wl_surface has another role
   */
  role: 0
}

/* harmony default export */ __webpack_exports__["default"] = (WlShellProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlShellSurfaceEvents.js":
/*!************************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlShellSurfaceEvents.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WlShellSurfaceEvents; });
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlShellSurfaceEvents {

	/**
	 *
	 *	Ping a client to check if it is receiving events and sending
	 *	requests. A client is expected to reply with a pong request.
	 *      
	 *
	 * @param {number} serial serial number of the ping 
	 *
	 * @since 1
	 *
	 */
	ping(serial) {}

	/**
	 *
	 *	The configure event asks the client to resize its surface.
	 *
	 *	The size is a hint, in the sense that the client is free to
	 *	ignore it if it doesn't resize, pick a smaller size (to
	 *	satisfy aspect ratio or resize in steps of NxM pixels).
	 *
	 *	The edges parameter provides a hint about how the surface
	 *	was resized. The client may use this information to decide
	 *	how to adjust its content to the new size (e.g. a scrolling
	 *	area might adjust its content position to leave the viewable
	 *	content unmoved).
	 *
	 *	The client is free to dismiss all but the last configure
	 *	event it received.
	 *
	 *	The width and height arguments specify the size of the window
	 *	in surface-local coordinates.
	 *      
	 *
	 * @param {number} edges how the surface was resized 
	 * @param {number} width new width of the surface 
	 * @param {number} height new height of the surface 
	 *
	 * @since 1
	 *
	 */
	configure(edges, width, height) {}

	/**
	 *
	 *	The popup_done event is sent out when a popup grab is broken,
	 *	that is, when the user clicks a surface that doesn't belong
	 *	to the client owning the popup surface.
	 *      
	 *
	 *
	 * @since 1
	 *
	 */
	popupDone() {}
}



/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlShellSurfaceProxy.js":
/*!***********************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlShellSurfaceProxy.js ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]


/**
 *
 *      An interface that may be implemented by a wl_surface, for
 *      implementations that provide a desktop-style user interface.
 *
 *      It provides requests to treat surfaces like toplevel, fullscreen
 *      or popup windows, move, resize or maximize them, associate
 *      metadata like title and class, etc.
 *
 *      On the server side the object is automatically destroyed when
 *      the related wl_surface is destroyed. On the client side,
 *      wl_shell_surface_destroy() must be called before destroying
 *      the wl_surface object.
 *    
 */
class WlShellSurfaceProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 *
	 *	A client must respond to a ping event with a pong request or
	 *	the client may be deemed unresponsive.
	 *      
	 *
	 * @param {number} serial serial number of the ping event 
	 *
	 * @since 1
	 *
	 */
	pong (serial) {
		this._marshall(this.id, 0, [uint(serial)])
	}

	/**
	 *
	 *	Start a pointer-driven move of the surface.
	 *
	 *	This request must be used in response to a button press event.
	 *	The server may ignore move requests depending on the state of
	 *	the surface (e.g. fullscreen or maximized).
	 *      
	 *
	 * @param {*} seat seat whose pointer is used 
	 * @param {number} serial serial number of the implicit grab on the pointer 
	 *
	 * @since 1
	 *
	 */
	move (seat, serial) {
		this._marshall(this.id, 1, [object(seat), uint(serial)])
	}

	/**
	 *
	 *	Start a pointer-driven resizing of the surface.
	 *
	 *	This request must be used in response to a button press event.
	 *	The server may ignore resize requests depending on the state of
	 *	the surface (e.g. fullscreen or maximized).
	 *      
	 *
	 * @param {*} seat seat whose pointer is used 
	 * @param {number} serial serial number of the implicit grab on the pointer 
	 * @param {number} edges which edge or corner is being dragged 
	 *
	 * @since 1
	 *
	 */
	resize (seat, serial, edges) {
		this._marshall(this.id, 2, [object(seat), uint(serial), uint(edges)])
	}

	/**
	 *
	 *	Map the surface as a toplevel surface.
	 *
	 *	A toplevel surface is not fullscreen, maximized or transient.
	 *      
	 * @since 1
	 *
	 */
	setToplevel () {
		this._marshall(this.id, 3, [])
	}

	/**
	 *
	 *	Map the surface relative to an existing surface.
	 *
	 *	The x and y arguments specify the location of the upper left
	 *	corner of the surface relative to the upper left corner of the
	 *	parent surface, in surface-local coordinates.
	 *
	 *	The flags argument controls details of the transient behaviour.
	 *      
	 *
	 * @param {*} parent parent surface 
	 * @param {number} x surface-local x coordinate 
	 * @param {number} y surface-local y coordinate 
	 * @param {number} flags transient surface behavior 
	 *
	 * @since 1
	 *
	 */
	setTransient (parent, x, y, flags) {
		this._marshall(this.id, 4, [object(parent), int(x), int(y), uint(flags)])
	}

	/**
	 *
	 *	Map the surface as a fullscreen surface.
	 *
	 *	If an output parameter is given then the surface will be made
	 *	fullscreen on that output. If the client does not specify the
	 *	output then the compositor will apply its policy - usually
	 *	choosing the output on which the surface has the biggest surface
	 *	area.
	 *
	 *	The client may specify a method to resolve a size conflict
	 *	between the output size and the surface size - this is provided
	 *	through the method parameter.
	 *
	 *	The framerate parameter is used only when the method is set
	 *	to "driver", to indicate the preferred framerate. A value of 0
	 *	indicates that the client does not care about framerate.  The
	 *	framerate is specified in mHz, that is framerate of 60000 is 60Hz.
	 *
	 *	A method of "scale" or "driver" implies a scaling operation of
	 *	the surface, either via a direct scaling operation or a change of
	 *	the output mode. This will override any kind of output scaling, so
	 *	that mapping a surface with a buffer size equal to the mode can
	 *	fill the screen independent of buffer_scale.
	 *
	 *	A method of "fill" means we don't scale up the buffer, however
	 *	any output scale is applied. This means that you may run into
	 *	an edge case where the application maps a buffer with the same
	 *	size of the output mode but buffer_scale 1 (thus making a
	 *	surface larger than the output). In this case it is allowed to
	 *	downscale the results to fit the screen.
	 *
	 *	The compositor must reply to this request with a configure event
	 *	with the dimensions for the output on which the surface will
	 *	be made fullscreen.
	 *      
	 *
	 * @param {number} method method for resolving size conflict 
	 * @param {number} framerate framerate in mHz 
	 * @param {?*} output output on which the surface is to be fullscreen 
	 *
	 * @since 1
	 *
	 */
	setFullscreen (method, framerate, output) {
		this._marshall(this.id, 5, [uint(method), uint(framerate), objectOptional(output)])
	}

	/**
	 *
	 *	Map the surface as a popup.
	 *
	 *	A popup surface is a transient surface with an added pointer
	 *	grab.
	 *
	 *	An existing implicit grab will be changed to owner-events mode,
	 *	and the popup grab will continue after the implicit grab ends
	 *	(i.e. releasing the mouse button does not cause the popup to
	 *	be unmapped).
	 *
	 *	The popup grab continues until the window is destroyed or a
	 *	mouse button is pressed in any other client's window. A click
	 *	in any of the client's surfaces is reported as normal, however,
	 *	clicks in other clients' surfaces will be discarded and trigger
	 *	the callback.
	 *
	 *	The x and y arguments specify the location of the upper left
	 *	corner of the surface relative to the upper left corner of the
	 *	parent surface, in surface-local coordinates.
	 *      
	 *
	 * @param {*} seat seat whose pointer is used 
	 * @param {number} serial serial number of the implicit grab on the pointer 
	 * @param {*} parent parent surface 
	 * @param {number} x surface-local x coordinate 
	 * @param {number} y surface-local y coordinate 
	 * @param {number} flags transient surface behavior 
	 *
	 * @since 1
	 *
	 */
	setPopup (seat, serial, parent, x, y, flags) {
		this._marshall(this.id, 6, [object(seat), uint(serial), object(parent), int(x), int(y), uint(flags)])
	}

	/**
	 *
	 *	Map the surface as a maximized surface.
	 *
	 *	If an output parameter is given then the surface will be
	 *	maximized on that output. If the client does not specify the
	 *	output then the compositor will apply its policy - usually
	 *	choosing the output on which the surface has the biggest surface
	 *	area.
	 *
	 *	The compositor will reply with a configure event telling
	 *	the expected new surface size. The operation is completed
	 *	on the next buffer attach to this surface.
	 *
	 *	A maximized surface typically fills the entire output it is
	 *	bound to, except for desktop elements such as panels. This is
	 *	the main difference between a maximized shell surface and a
	 *	fullscreen shell surface.
	 *
	 *	The details depend on the compositor implementation.
	 *      
	 *
	 * @param {?*} output output on which the surface is to be maximized 
	 *
	 * @since 1
	 *
	 */
	setMaximized (output) {
		this._marshall(this.id, 7, [objectOptional(output)])
	}

	/**
	 *
	 *	Set a short title for the surface.
	 *
	 *	This string may be used to identify the surface in a task bar,
	 *	window list, or other user interface elements provided by the
	 *	compositor.
	 *
	 *	The string must be encoded in UTF-8.
	 *      
	 *
	 * @param {string} title surface title 
	 *
	 * @since 1
	 *
	 */
	setTitle (title) {
		this._marshall(this.id, 8, [string(title)])
	}

	/**
	 *
	 *	Set a class for the surface.
	 *
	 *	The surface class identifies the general class of applications
	 *	to which the surface belongs. A common convention is to use the
	 *	file name (or the full path if it is a non-standard location) of
	 *	the application's .desktop file as the class.
	 *      
	 *
	 * @param {string} clazz surface class 
	 *
	 * @since 1
	 *
	 */
	setClass (clazz) {
		this._marshall(this.id, 9, [string(clazz)])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {WlShellSurfaceEvents|null}
		 */
		this.listener = null
	}

	async [0] (message) {
		await this.listener.ping(u(message))
	}

	async [1] (message) {
		await this.listener.configure(u(message), i(message), i(message))
	}

	async [2] (message) {
		await this.listener.popupDone()
	}

}
WlShellSurfaceProxy.protocolName = 'wl_shell_surface'

WlShellSurfaceProxy.Resize = {
  /**
   * no edge
   */
  none: 0,
  /**
   * top edge
   */
  top: 1,
  /**
   * bottom edge
   */
  bottom: 2,
  /**
   * left edge
   */
  left: 4,
  /**
   * top and left edges
   */
  topLeft: 5,
  /**
   * bottom and left edges
   */
  bottomLeft: 6,
  /**
   * right edge
   */
  right: 8,
  /**
   * top and right edges
   */
  topRight: 9,
  /**
   * bottom and right edges
   */
  bottomRight: 10
}

WlShellSurfaceProxy.Transient = {
  /**
   * do not set keyboard focus
   */
  inactive: 0x1
}

WlShellSurfaceProxy.FullscreenMethod = {
  /**
   * no preference, apply default policy
   */
  default: 0,
  /**
   * scale, preserve the surface's aspect ratio and center on output
   */
  scale: 1,
  /**
   * switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch
   */
  driver: 2,
  /**
   * no upscaling, center on output and add black borders to compensate size mismatch
   */
  fill: 3
}

/* harmony default export */ __webpack_exports__["default"] = (WlShellSurfaceProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlSubcompositorProxy.js":
/*!************************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlSubcompositorProxy.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/* harmony import */ var _WlSubsurfaceProxy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WlSubsurfaceProxy */ "../../../westfield/client/runtime/src/protocol/WlSubsurfaceProxy.js");
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]



/**
 *
 *      The global interface exposing sub-surface compositing capabilities.
 *      A wl_surface, that has sub-surfaces associated, is called the
 *      parent surface. Sub-surfaces can be arbitrarily nested and create
 *      a tree of sub-surfaces.
 *
 *      The root surface in a tree of sub-surfaces is the main
 *      surface. The main surface cannot be a sub-surface, because
 *      sub-surfaces must always have a parent.
 *
 *      A main surface with its sub-surfaces forms a (compound) window.
 *      For window management purposes, this set of wl_surface objects is
 *      to be considered as a single window, and it should also behave as
 *      such.
 *
 *      The aim of sub-surfaces is to offload some of the compositing work
 *      within a window from clients to the compositor. A prime example is
 *      a video player with decorations and video in separate wl_surface
 *      objects. This should allow the compositor to pass YUV video buffer
 *      processing to dedicated overlay hardware when possible.
 *    
 */
class WlSubcompositorProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 *
	 *	Informs the server that the client will not be using this
	 *	protocol object anymore. This does not affect any other
	 *	objects, wl_subsurface objects included.
	 *      
	 * @since 1
	 *
	 */
	destroy () {
		super.destroy()
		this._marshall(this.id, 0, [])
	}

	/**
	 *
	 *	Create a sub-surface interface for the given surface, and
	 *	associate it with the given parent surface. This turns a
	 *	plain wl_surface into a sub-surface.
	 *
	 *	The to-be sub-surface must not already have another role, and it
	 *	must not have an existing wl_subsurface object. Otherwise a protocol
	 *	error is raised.
	 *      
	 *
	 * @param {*} surface the surface to be turned into a sub-surface 
	 * @param {*} parent the parent surface 
	 * @return {WlSubsurfaceProxy} the new sub-surface object ID 
	 *
	 * @since 1
	 *
	 */
	getSubsurface (surface, parent) {
		return this._marshallConstructor(this.id, 1, _WlSubsurfaceProxy__WEBPACK_IMPORTED_MODULE_2__["default"], [newObject(), object(surface), object(parent)])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {WlSubcompositorEvents|null}
		 */
		this.listener = null
	}

}
WlSubcompositorProxy.protocolName = 'wl_subcompositor'

WlSubcompositorProxy.Error = {
  /**
   * the to-be sub-surface is invalid
   */
  badSurface: 0
}

/* harmony default export */ __webpack_exports__["default"] = (WlSubcompositorProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlSubsurfaceProxy.js":
/*!*********************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlSubsurfaceProxy.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]


/**
 *
 *      An additional interface to a wl_surface object, which has been
 *      made a sub-surface. A sub-surface has one parent surface. A
 *      sub-surface's size and position are not limited to that of the parent.
 *      Particularly, a sub-surface is not automatically clipped to its
 *      parent's area.
 *
 *      A sub-surface becomes mapped, when a non-NULL wl_buffer is applied
 *      and the parent surface is mapped. The order of which one happens
 *      first is irrelevant. A sub-surface is hidden if the parent becomes
 *      hidden, or if a NULL wl_buffer is applied. These rules apply
 *      recursively through the tree of surfaces.
 *
 *      The behaviour of a wl_surface.commit request on a sub-surface
 *      depends on the sub-surface's mode. The possible modes are
 *      synchronized and desynchronized, see methods
 *      wl_subsurface.set_sync and wl_subsurface.set_desync. Synchronized
 *      mode caches the wl_surface state to be applied when the parent's
 *      state gets applied, and desynchronized mode applies the pending
 *      wl_surface state directly. A sub-surface is initially in the
 *      synchronized mode.
 *
 *      Sub-surfaces have also other kind of state, which is managed by
 *      wl_subsurface requests, as opposed to wl_surface requests. This
 *      state includes the sub-surface position relative to the parent
 *      surface (wl_subsurface.set_position), and the stacking order of
 *      the parent and its sub-surfaces (wl_subsurface.place_above and
 *      .place_below). This state is applied when the parent surface's
 *      wl_surface state is applied, regardless of the sub-surface's mode.
 *      As the exception, set_sync and set_desync are effective immediately.
 *
 *      The main surface can be thought to be always in desynchronized mode,
 *      since it does not have a parent in the sub-surfaces sense.
 *
 *      Even if a sub-surface is in desynchronized mode, it will behave as
 *      in synchronized mode, if its parent surface behaves as in
 *      synchronized mode. This rule is applied recursively throughout the
 *      tree of surfaces. This means, that one can set a sub-surface into
 *      synchronized mode, and then assume that all its child and grand-child
 *      sub-surfaces are synchronized, too, without explicitly setting them.
 *
 *      If the wl_surface associated with the wl_subsurface is destroyed, the
 *      wl_subsurface object becomes inert. Note, that destroying either object
 *      takes effect immediately. If you need to synchronize the removal
 *      of a sub-surface to the parent surface update, unmap the sub-surface
 *      first by attaching a NULL wl_buffer, update parent, and then destroy
 *      the sub-surface.
 *
 *      If the parent wl_surface object is destroyed, the sub-surface is
 *      unmapped.
 *    
 */
class WlSubsurfaceProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 *
	 *	The sub-surface interface is removed from the wl_surface object
	 *	that was turned into a sub-surface with a
	 *	wl_subcompositor.get_subsurface request. The wl_surface's association
	 *	to the parent is deleted, and the wl_surface loses its role as
	 *	a sub-surface. The wl_surface is unmapped.
	 *      
	 * @since 1
	 *
	 */
	destroy () {
		super.destroy()
		this._marshall(this.id, 0, [])
	}

	/**
	 *
	 *	This schedules a sub-surface position change.
	 *	The sub-surface will be moved so that its origin (top left
	 *	corner pixel) will be at the location x, y of the parent surface
	 *	coordinate system. The coordinates are not restricted to the parent
	 *	surface area. Negative values are allowed.
	 *
	 *	The scheduled coordinates will take effect whenever the state of the
	 *	parent surface is applied. When this happens depends on whether the
	 *	parent surface is in synchronized mode or not. See
	 *	wl_subsurface.set_sync and wl_subsurface.set_desync for details.
	 *
	 *	If more than one set_position request is invoked by the client before
	 *	the commit of the parent surface, the position of a new request always
	 *	replaces the scheduled position from any previous request.
	 *
	 *	The initial position is 0, 0.
	 *      
	 *
	 * @param {number} x x coordinate in the parent surface 
	 * @param {number} y y coordinate in the parent surface 
	 *
	 * @since 1
	 *
	 */
	setPosition (x, y) {
		this._marshall(this.id, 1, [int(x), int(y)])
	}

	/**
	 *
	 *	This sub-surface is taken from the stack, and put back just
	 *	above the reference surface, changing the z-order of the sub-surfaces.
	 *	The reference surface must be one of the sibling surfaces, or the
	 *	parent surface. Using any other surface, including this sub-surface,
	 *	will cause a protocol error.
	 *
	 *	The z-order is double-buffered. Requests are handled in order and
	 *	applied immediately to a pending state. The final pending state is
	 *	copied to the active state the next time the state of the parent
	 *	surface is applied. When this happens depends on whether the parent
	 *	surface is in synchronized mode or not. See wl_subsurface.set_sync and
	 *	wl_subsurface.set_desync for details.
	 *
	 *	A new sub-surface is initially added as the top-most in the stack
	 *	of its siblings and parent.
	 *      
	 *
	 * @param {*} sibling the reference surface 
	 *
	 * @since 1
	 *
	 */
	placeAbove (sibling) {
		this._marshall(this.id, 2, [object(sibling)])
	}

	/**
	 *
	 *	The sub-surface is placed just below the reference surface.
	 *	See wl_subsurface.place_above.
	 *      
	 *
	 * @param {*} sibling the reference surface 
	 *
	 * @since 1
	 *
	 */
	placeBelow (sibling) {
		this._marshall(this.id, 3, [object(sibling)])
	}

	/**
	 *
	 *	Change the commit behaviour of the sub-surface to synchronized
	 *	mode, also described as the parent dependent mode.
	 *
	 *	In synchronized mode, wl_surface.commit on a sub-surface will
	 *	accumulate the committed state in a cache, but the state will
	 *	not be applied and hence will not change the compositor output.
	 *	The cached state is applied to the sub-surface immediately after
	 *	the parent surface's state is applied. This ensures atomic
	 *	updates of the parent and all its synchronized sub-surfaces.
	 *	Applying the cached state will invalidate the cache, so further
	 *	parent surface commits do not (re-)apply old state.
	 *
	 *	See wl_subsurface for the recursive effect of this mode.
	 *      
	 * @since 1
	 *
	 */
	setSync () {
		this._marshall(this.id, 4, [])
	}

	/**
	 *
	 *	Change the commit behaviour of the sub-surface to desynchronized
	 *	mode, also described as independent or freely running mode.
	 *
	 *	In desynchronized mode, wl_surface.commit on a sub-surface will
	 *	apply the pending state directly, without caching, as happens
	 *	normally with a wl_surface. Calling wl_surface.commit on the
	 *	parent surface has no effect on the sub-surface's wl_surface
	 *	state. This mode allows a sub-surface to be updated on its own.
	 *
	 *	If cached state exists when wl_surface.commit is called in
	 *	desynchronized mode, the pending state is added to the cached
	 *	state, and applied as a whole. This invalidates the cache.
	 *
	 *	Note: even if a sub-surface is set to desynchronized, a parent
	 *	sub-surface may override it to behave as synchronized. For details,
	 *	see wl_subsurface.
	 *
	 *	If a surface's parent surface behaves as desynchronized, then
	 *	the cached state is applied on set_desync.
	 *      
	 * @since 1
	 *
	 */
	setDesync () {
		this._marshall(this.id, 5, [])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {WlSubsurfaceEvents|null}
		 */
		this.listener = null
	}

}
WlSubsurfaceProxy.protocolName = 'wl_subsurface'

WlSubsurfaceProxy.Error = {
  /**
   * wl_surface is not a sibling or the parent
   */
  badSurface: 0
}

/* harmony default export */ __webpack_exports__["default"] = (WlSubsurfaceProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlSurfaceEvents.js":
/*!*******************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlSurfaceEvents.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WlSurfaceEvents; });
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlSurfaceEvents {

	/**
	 *
	 *	This is emitted whenever a surface's creation, movement, or resizing
	 *	results in some part of it being within the scanout region of an
	 *	output.
	 *
	 *	Note that a surface may be overlapping with zero or more outputs.
	 *      
	 *
	 * @param {*} output output entered by the surface 
	 *
	 * @since 1
	 *
	 */
	enter(output) {}

	/**
	 *
	 *	This is emitted whenever a surface's creation, movement, or resizing
	 *	results in it no longer having any part of it within the scanout region
	 *	of an output.
	 *      
	 *
	 * @param {*} output output left by the surface 
	 *
	 * @since 1
	 *
	 */
	leave(output) {}
}



/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlSurfaceProxy.js":
/*!******************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlSurfaceProxy.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/* harmony import */ var _WlCallbackProxy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WlCallbackProxy */ "../../../westfield/client/runtime/src/protocol/WlCallbackProxy.js");
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]



/**
 *
 *      A surface is a rectangular area that is displayed on the screen.
 *      It has a location, size and pixel contents.
 *
 *      The size of a surface (and relative positions on it) is described
 *      in surface-local coordinates, which may differ from the buffer
 *      coordinates of the pixel content, in case a buffer_transform
 *      or a buffer_scale is used.
 *
 *      A surface without a "role" is fairly useless: a compositor does
 *      not know where, when or how to present it. The role is the
 *      purpose of a wl_surface. Examples of roles are a cursor for a
 *      pointer (as set by wl_pointer.set_cursor), a drag icon
 *      (wl_data_device.start_drag), a sub-surface
 *      (wl_subcompositor.get_subsurface), and a window as defined by a
 *      shell protocol (e.g. wl_shell.get_shell_surface).
 *
 *      A surface can have only one role at a time. Initially a
 *      wl_surface does not have a role. Once a wl_surface is given a
 *      role, it is set permanently for the whole lifetime of the
 *      wl_surface object. Giving the current role again is allowed,
 *      unless explicitly forbidden by the relevant interface
 *      specification.
 *
 *      Surface roles are given by requests in other interfaces such as
 *      wl_pointer.set_cursor. The request should explicitly mention
 *      that this request gives a role to a wl_surface. Often, this
 *      request also creates a new protocol object that represents the
 *      role and adds additional functionality to wl_surface. When a
 *      client wants to destroy a wl_surface, they must destroy this 'role
 *      object' before the wl_surface.
 *
 *      Destroying the role object does not remove the role from the
 *      wl_surface, but it may stop the wl_surface from "playing the role".
 *      For instance, if a wl_subsurface object is destroyed, the wl_surface
 *      it was created for will be unmapped and forget its position and
 *      z-order. It is allowed to create a wl_subsurface for the same
 *      wl_surface again, but it is not allowed to use the wl_surface as
 *      a cursor (cursor is a different role than sub-surface, and role
 *      switching is not allowed).
 *    
 */
class WlSurfaceProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 *
	 *	Deletes the surface and invalidates its object ID.
	 *      
	 * @since 1
	 *
	 */
	destroy () {
		super.destroy()
		this._marshall(this.id, 0, [])
	}

	/**
	 *
	 *	Set a buffer as the content of this surface.
	 *
	 *	The new size of the surface is calculated based on the buffer
	 *	size transformed by the inverse buffer_transform and the
	 *	inverse buffer_scale. This means that the supplied buffer
	 *	must be an integer multiple of the buffer_scale.
	 *
	 *	The x and y arguments specify the location of the new pending
	 *	buffer's upper left corner, relative to the current buffer's upper
	 *	left corner, in surface-local coordinates. In other words, the
	 *	x and y, combined with the new surface size define in which
	 *	directions the surface's size changes.
	 *
	 *	Surface contents are double-buffered state, see wl_surface.commit.
	 *
	 *	The initial surface contents are void; there is no content.
	 *	wl_surface.attach assigns the given wl_buffer as the pending
	 *	wl_buffer. wl_surface.commit makes the pending wl_buffer the new
	 *	surface contents, and the size of the surface becomes the size
	 *	calculated from the wl_buffer, as described above. After commit,
	 *	there is no pending buffer until the next attach.
	 *
	 *	Committing a pending wl_buffer allows the compositor to read the
	 *	pixels in the wl_buffer. The compositor may access the pixels at
	 *	any time after the wl_surface.commit request. When the compositor
	 *	will not access the pixels anymore, it will send the
	 *	wl_buffer.release event. Only after receiving wl_buffer.release,
	 *	the client may reuse the wl_buffer. A wl_buffer that has been
	 *	attached and then replaced by another attach instead of committed
	 *	will not receive a release event, and is not used by the
	 *	compositor.
	 *
	 *	Destroying the wl_buffer after wl_buffer.release does not change
	 *	the surface contents. However, if the client destroys the
	 *	wl_buffer before receiving the wl_buffer.release event, the surface
	 *	contents become undefined immediately.
	 *
	 *	If wl_surface.attach is sent with a NULL wl_buffer, the
	 *	following wl_surface.commit will remove the surface content.
	 *      
	 *
	 * @param {?*} buffer buffer of surface contents 
	 * @param {number} x surface-local x coordinate 
	 * @param {number} y surface-local y coordinate 
	 *
	 * @since 1
	 *
	 */
	attach (buffer, x, y) {
		this._marshall(this.id, 1, [objectOptional(buffer), int(x), int(y)])
	}

	/**
	 *
	 *	This request is used to describe the regions where the pending
	 *	buffer is different from the current surface contents, and where
	 *	the surface therefore needs to be repainted. The compositor
	 *	ignores the parts of the damage that fall outside of the surface.
	 *
	 *	Damage is double-buffered state, see wl_surface.commit.
	 *
	 *	The damage rectangle is specified in surface-local coordinates,
	 *	where x and y specify the upper left corner of the damage rectangle.
	 *
	 *	The initial value for pending damage is empty: no damage.
	 *	wl_surface.damage adds pending damage: the new pending damage
	 *	is the union of old pending damage and the given rectangle.
	 *
	 *	wl_surface.commit assigns pending damage as the current damage,
	 *	and clears pending damage. The server will clear the current
	 *	damage as it repaints the surface.
	 *
	 *	Alternatively, damage can be posted with wl_surface.damage_buffer
	 *	which uses buffer coordinates instead of surface coordinates,
	 *	and is probably the preferred and intuitive way of doing this.
	 *      
	 *
	 * @param {number} x surface-local x coordinate 
	 * @param {number} y surface-local y coordinate 
	 * @param {number} width width of damage rectangle 
	 * @param {number} height height of damage rectangle 
	 *
	 * @since 1
	 *
	 */
	damage (x, y, width, height) {
		this._marshall(this.id, 2, [int(x), int(y), int(width), int(height)])
	}

	/**
	 *
	 *	Request a notification when it is a good time to start drawing a new
	 *	frame, by creating a frame callback. This is useful for throttling
	 *	redrawing operations, and driving animations.
	 *
	 *	When a client is animating on a wl_surface, it can use the 'frame'
	 *	request to get notified when it is a good time to draw and commit the
	 *	next frame of animation. If the client commits an update earlier than
	 *	that, it is likely that some updates will not make it to the display,
	 *	and the client is wasting resources by drawing too often.
	 *
	 *	The frame request will take effect on the next wl_surface.commit.
	 *	The notification will only be posted for one frame unless
	 *	requested again. For a wl_surface, the notifications are posted in
	 *	the order the frame requests were committed.
	 *
	 *	The server must send the notifications so that a client
	 *	will not send excessive updates, while still allowing
	 *	the highest possible update rate for clients that wait for the reply
	 *	before drawing again. The server should give some time for the client
	 *	to draw and commit after sending the frame callback events to let it
	 *	hit the next output refresh.
	 *
	 *	A server should avoid signaling the frame callbacks if the
	 *	surface is not visible in any way, e.g. the surface is off-screen,
	 *	or completely obscured by other opaque surfaces.
	 *
	 *	The object returned by this request will be destroyed by the
	 *	compositor after the callback is fired and as such the client must not
	 *	attempt to use it after that point.
	 *
	 *	The callback_data passed in the callback is the current time, in
	 *	milliseconds, with an undefined base.
	 *      
	 *
	 * @return {WlCallbackProxy} callback object for the frame request 
	 *
	 * @since 1
	 *
	 */
	frame () {
		return this._marshallConstructor(this.id, 3, _WlCallbackProxy__WEBPACK_IMPORTED_MODULE_2__["default"], [newObject()])
	}

	/**
	 *
	 *	This request sets the region of the surface that contains
	 *	opaque content.
	 *
	 *	The opaque region is an optimization hint for the compositor
	 *	that lets it optimize the redrawing of content behind opaque
	 *	regions.  Setting an opaque region is not required for correct
	 *	behaviour, but marking transparent content as opaque will result
	 *	in repaint artifacts.
	 *
	 *	The opaque region is specified in surface-local coordinates.
	 *
	 *	The compositor ignores the parts of the opaque region that fall
	 *	outside of the surface.
	 *
	 *	Opaque region is double-buffered state, see wl_surface.commit.
	 *
	 *	wl_surface.set_opaque_region changes the pending opaque region.
	 *	wl_surface.commit copies the pending region to the current region.
	 *	Otherwise, the pending and current regions are never changed.
	 *
	 *	The initial value for an opaque region is empty. Setting the pending
	 *	opaque region has copy semantics, and the wl_region object can be
	 *	destroyed immediately. A NULL wl_region causes the pending opaque
	 *	region to be set to empty.
	 *      
	 *
	 * @param {?*} region opaque region of the surface 
	 *
	 * @since 1
	 *
	 */
	setOpaqueRegion (region) {
		this._marshall(this.id, 4, [objectOptional(region)])
	}

	/**
	 *
	 *	This request sets the region of the surface that can receive
	 *	pointer and touch events.
	 *
	 *	Input events happening outside of this region will try the next
	 *	surface in the server surface stack. The compositor ignores the
	 *	parts of the input region that fall outside of the surface.
	 *
	 *	The input region is specified in surface-local coordinates.
	 *
	 *	Input region is double-buffered state, see wl_surface.commit.
	 *
	 *	wl_surface.set_input_region changes the pending input region.
	 *	wl_surface.commit copies the pending region to the current region.
	 *	Otherwise the pending and current regions are never changed,
	 *	except cursor and icon surfaces are special cases, see
	 *	wl_pointer.set_cursor and wl_data_device.start_drag.
	 *
	 *	The initial value for an input region is infinite. That means the
	 *	whole surface will accept input. Setting the pending input region
	 *	has copy semantics, and the wl_region object can be destroyed
	 *	immediately. A NULL wl_region causes the input region to be set
	 *	to infinite.
	 *      
	 *
	 * @param {?*} region input region of the surface 
	 *
	 * @since 1
	 *
	 */
	setInputRegion (region) {
		this._marshall(this.id, 5, [objectOptional(region)])
	}

	/**
	 *
	 *	Surface state (input, opaque, and damage regions, attached buffers,
	 *	etc.) is double-buffered. Protocol requests modify the pending state,
	 *	as opposed to the current state in use by the compositor. A commit
	 *	request atomically applies all pending state, replacing the current
	 *	state. After commit, the new pending state is as documented for each
	 *	related request.
	 *
	 *	On commit, a pending wl_buffer is applied first, and all other state
	 *	second. This means that all coordinates in double-buffered state are
	 *	relative to the new wl_buffer coming into use, except for
	 *	wl_surface.attach itself. If there is no pending wl_buffer, the
	 *	coordinates are relative to the current surface contents.
	 *
	 *	All requests that need a commit to become effective are documented
	 *	to affect double-buffered state.
	 *
	 *	Other interfaces may add further double-buffered surface state.
	 *      
	 *
	 * @param {number} serial serial number of the commit 
	 *
	 * @since 1
	 *
	 */
	commit (serial) {
		this._marshall(this.id, 6, [uint(serial)])
	}

	/**
	 *
	 *	This request sets an optional transformation on how the compositor
	 *	interprets the contents of the buffer attached to the surface. The
	 *	accepted values for the transform parameter are the values for
	 *	wl_output.transform.
	 *
	 *	Buffer transform is double-buffered state, see wl_surface.commit.
	 *
	 *	A newly created surface has its buffer transformation set to normal.
	 *
	 *	wl_surface.set_buffer_transform changes the pending buffer
	 *	transformation. wl_surface.commit copies the pending buffer
	 *	transformation to the current one. Otherwise, the pending and current
	 *	values are never changed.
	 *
	 *	The purpose of this request is to allow clients to render content
	 *	according to the output transform, thus permitting the compositor to
	 *	use certain optimizations even if the display is rotated. Using
	 *	hardware overlays and scanning out a client buffer for fullscreen
	 *	surfaces are examples of such optimizations. Those optimizations are
	 *	highly dependent on the compositor implementation, so the use of this
	 *	request should be considered on a case-by-case basis.
	 *
	 *	Note that if the transform value includes 90 or 270 degree rotation,
	 *	the width of the buffer will become the surface height and the height
	 *	of the buffer will become the surface width.
	 *
	 *	If transform is not one of the values from the
	 *	wl_output.transform enum the invalid_transform protocol error
	 *	is raised.
	 *      
	 *
	 * @param {number} transform transform for interpreting buffer contents 
	 *
	 * @since 2
	 *
	 */
	setBufferTransform (transform) {
		this._marshall(this.id, 7, [int(transform)])
	}

	/**
	 *
	 *	This request sets an optional scaling factor on how the compositor
	 *	interprets the contents of the buffer attached to the window.
	 *
	 *	Buffer scale is double-buffered state, see wl_surface.commit.
	 *
	 *	A newly created surface has its buffer scale set to 1.
	 *
	 *	wl_surface.set_buffer_scale changes the pending buffer scale.
	 *	wl_surface.commit copies the pending buffer scale to the current one.
	 *	Otherwise, the pending and current values are never changed.
	 *
	 *	The purpose of this request is to allow clients to supply higher
	 *	resolution buffer data for use on high resolution outputs. It is
	 *	intended that you pick the same buffer scale as the scale of the
	 *	output that the surface is displayed on. This means the compositor
	 *	can avoid scaling when rendering the surface on that output.
	 *
	 *	Note that if the scale is larger than 1, then you have to attach
	 *	a buffer that is larger (by a factor of scale in each dimension)
	 *	than the desired surface size.
	 *
	 *	If scale is not positive the invalid_scale protocol error is
	 *	raised.
	 *      
	 *
	 * @param {number} scale positive scale for interpreting buffer contents 
	 *
	 * @since 3
	 *
	 */
	setBufferScale (scale) {
		this._marshall(this.id, 8, [int(scale)])
	}

	/**
	 *
	 *	This request is used to describe the regions where the pending
	 *	buffer is different from the current surface contents, and where
	 *	the surface therefore needs to be repainted. The compositor
	 *	ignores the parts of the damage that fall outside of the surface.
	 *
	 *	Damage is double-buffered state, see wl_surface.commit.
	 *
	 *	The damage rectangle is specified in buffer coordinates,
	 *	where x and y specify the upper left corner of the damage rectangle.
	 *
	 *	The initial value for pending damage is empty: no damage.
	 *	wl_surface.damage_buffer adds pending damage: the new pending
	 *	damage is the union of old pending damage and the given rectangle.
	 *
	 *	wl_surface.commit assigns pending damage as the current damage,
	 *	and clears pending damage. The server will clear the current
	 *	damage as it repaints the surface.
	 *
	 *	This request differs from wl_surface.damage in only one way - it
	 *	takes damage in buffer coordinates instead of surface-local
	 *	coordinates. While this generally is more intuitive than surface
	 *	coordinates, it is especially desirable when using wp_viewport
	 *	or when a drawing library (like EGL) is unaware of buffer scale
	 *	and buffer transform.
	 *
	 *	Note: Because buffer transformation changes and damage requests may
	 *	be interleaved in the protocol stream, it is impossible to determine
	 *	the actual mapping between surface and buffer damage until
	 *	wl_surface.commit time. Therefore, compositors wishing to take both
	 *	kinds of damage into account will have to accumulate damage from the
	 *	two requests separately and only transform from one to the other
	 *	after receiving the wl_surface.commit.
	 *      
	 *
	 * @param {number} x buffer-local x coordinate 
	 * @param {number} y buffer-local y coordinate 
	 * @param {number} width width of damage rectangle 
	 * @param {number} height height of damage rectangle 
	 *
	 * @since 4
	 *
	 */
	damageBuffer (x, y, width, height) {
		this._marshall(this.id, 9, [int(x), int(y), int(width), int(height)])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {WlSurfaceEvents|null}
		 */
		this.listener = null
	}

	async [0] (message) {
		await this.listener.enter(o(message, false, this._connection))
	}

	async [1] (message) {
		await this.listener.leave(o(message, false, this._connection))
	}

}
WlSurfaceProxy.protocolName = 'wl_surface'

WlSurfaceProxy.Error = {
  /**
   * buffer scale value is invalid
   */
  invalidScale: 0,
  /**
   * buffer transform value is invalid
   */
  invalidTransform: 1
}

/* harmony default export */ __webpack_exports__["default"] = (WlSurfaceProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlTouchEvents.js":
/*!*****************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlTouchEvents.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WlTouchEvents; });
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */

/**
 * @interface
 */
class WlTouchEvents {

	/**
	 *
	 *	A new touch point has appeared on the surface. This touch point is
	 *	assigned a unique ID. Future events from this touch point reference
	 *	this ID. The ID ceases to be valid after a touch up event and may be
	 *	reused in the future.
	 *      
	 *
	 * @param {number} serial serial number of the touch down event 
	 * @param {number} time timestamp with millisecond granularity 
	 * @param {*} surface surface touched 
	 * @param {number} id the unique ID of this touch point 
	 * @param {Fixed} x surface-local x coordinate 
	 * @param {Fixed} y surface-local y coordinate 
	 *
	 * @since 1
	 *
	 */
	down(serial, time, surface, id, x, y) {}

	/**
	 *
	 *	The touch point has disappeared. No further events will be sent for
	 *	this touch point and the touch point's ID is released and may be
	 *	reused in a future touch down event.
	 *      
	 *
	 * @param {number} serial serial number of the touch up event 
	 * @param {number} time timestamp with millisecond granularity 
	 * @param {number} id the unique ID of this touch point 
	 *
	 * @since 1
	 *
	 */
	up(serial, time, id) {}

	/**
	 *
	 *	A touch point has changed coordinates.
	 *      
	 *
	 * @param {number} time timestamp with millisecond granularity 
	 * @param {number} id the unique ID of this touch point 
	 * @param {Fixed} x surface-local x coordinate 
	 * @param {Fixed} y surface-local y coordinate 
	 *
	 * @since 1
	 *
	 */
	motion(time, id, x, y) {}

	/**
	 *
	 *	Indicates the end of a set of events that logically belong together.
	 *	A client is expected to accumulate the data in all events within the
	 *	frame before proceeding.
	 *
	 *	A wl_touch.frame terminates at least one event but otherwise no
	 *	guarantee is provided about the set of events within a frame. A client
	 *	must assume that any state not updated in a frame is unchanged from the
	 *	previously known state.
	 *      
	 *
	 *
	 * @since 1
	 *
	 */
	frame() {}

	/**
	 *
	 *	Sent if the compositor decides the touch stream is a global
	 *	gesture. No further events are sent to the clients from that
	 *	particular gesture. Touch cancellation applies to all touch points
	 *	currently active on this client's surface. The client is
	 *	responsible for finalizing the touch points, future touch points on
	 *	this surface may reuse the touch point ID.
	 *      
	 *
	 *
	 * @since 1
	 *
	 */
	cancel() {}

	/**
	 *
	 *	Sent when a touchpoint has changed its shape.
	 *
	 *	This event does not occur on its own. It is sent before a
	 *	wl_touch.frame event and carries the new shape information for
	 *	any previously reported, or new touch points of that frame.
	 *
	 *	Other events describing the touch point such as wl_touch.down,
	 *	wl_touch.motion or wl_touch.orientation may be sent within the
	 *	same wl_touch.frame. A client should treat these events as a single
	 *	logical touch point update. The order of wl_touch.shape,
	 *	wl_touch.orientation and wl_touch.motion is not guaranteed.
	 *	A wl_touch.down event is guaranteed to occur before the first
	 *	wl_touch.shape event for this touch ID but both events may occur within
	 *	the same wl_touch.frame.
	 *
	 *	A touchpoint shape is approximated by an ellipse through the major and
	 *	minor axis length. The major axis length describes the longer diameter
	 *	of the ellipse, while the minor axis length describes the shorter
	 *	diameter. Major and minor are orthogonal and both are specified in
	 *	surface-local coordinates. The center of the ellipse is always at the
	 *	touchpoint location as reported by wl_touch.down or wl_touch.move.
	 *
	 *	This event is only sent by the compositor if the touch device supports
	 *	shape reports. The client has to make reasonable assumptions about the
	 *	shape if it did not receive this event.
	 *      
	 *
	 * @param {number} id the unique ID of this touch point 
	 * @param {Fixed} major length of the major axis in surface-local coordinates 
	 * @param {Fixed} minor length of the minor axis in surface-local coordinates 
	 *
	 * @since 6
	 *
	 */
	shape(id, major, minor) {}

	/**
	 *
	 *	Sent when a touchpoint has changed its orientation.
	 *
	 *	This event does not occur on its own. It is sent before a
	 *	wl_touch.frame event and carries the new shape information for
	 *	any previously reported, or new touch points of that frame.
	 *
	 *	Other events describing the touch point such as wl_touch.down,
	 *	wl_touch.motion or wl_touch.shape may be sent within the
	 *	same wl_touch.frame. A client should treat these events as a single
	 *	logical touch point update. The order of wl_touch.shape,
	 *	wl_touch.orientation and wl_touch.motion is not guaranteed.
	 *	A wl_touch.down event is guaranteed to occur before the first
	 *	wl_touch.orientation event for this touch ID but both events may occur
	 *	within the same wl_touch.frame.
	 *
	 *	The orientation describes the clockwise angle of a touchpoint's major
	 *	axis to the positive surface y-axis and is normalized to the -180 to
	 *	+180 degree range. The granularity of orientation depends on the touch
	 *	device, some devices only support binary rotation values between 0 and
	 *	90 degrees.
	 *
	 *	This event is only sent by the compositor if the touch device supports
	 *	orientation reports.
	 *      
	 *
	 * @param {number} id the unique ID of this touch point 
	 * @param {Fixed} orientation angle between major axis and positive surface y-axis in degrees 
	 *
	 * @since 6
	 *
	 */
	orientation(id, orientation) {}
}



/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/WlTouchProxy.js":
/*!****************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/WlTouchProxy.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/*
 *
 *    Copyright © 2008-2011 Kristian Høgsberg
 *    Copyright © 2010-2011 Intel Corporation
 *    Copyright © 2012-2013 Collabora, Ltd.
 *
 *    Permission is hereby granted, free of charge, to any person
 *    obtaining a copy of this software and associated documentation files
 *    (the "Software"), to deal in the Software without restriction,
 *    including without limitation the rights to use, copy, modify, merge,
 *    publish, distribute, sublicense, and/or sell copies of the Software,
 *    and to permit persons to whom the Software is furnished to do so,
 *    subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the
 *    next paragraph) shall be included in all copies or substantial
 *    portions of the Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 *    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 *    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 *    NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 *    BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 *    ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 *    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *    SOFTWARE.
 *  
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]


/**
 *
 *      The wl_touch interface represents a touchscreen
 *      associated with a seat.
 *
 *      Touch interactions can consist of one or more contacts.
 *      For each contact, a series of events is generated, starting
 *      with a down event, followed by zero or more motion events,
 *      and ending with an up event. Events relating to the same
 *      contact point can be identified by the ID of the sequence.
 *    
 */
class WlTouchProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 * @since 3
	 *
	 */
	release () {
		super.destroy()
		this._marshall(this.id, 0, [])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {WlTouchEvents|null}
		 */
		this.listener = null
	}

	async [0] (message) {
		await this.listener.down(u(message), u(message), o(message, false, this._connection), i(message), f(message), f(message))
	}

	async [1] (message) {
		await this.listener.up(u(message), u(message), i(message))
	}

	async [2] (message) {
		await this.listener.motion(u(message), i(message), f(message), f(message))
	}

	async [3] (message) {
		await this.listener.frame()
	}

	async [4] (message) {
		await this.listener.cancel()
	}

	async [5] (message) {
		await this.listener.shape(i(message), f(message), f(message))
	}

	async [6] (message) {
		await this.listener.orientation(i(message), f(message))
	}

}
WlTouchProxy.protocolName = 'wl_touch'

/* harmony default export */ __webpack_exports__["default"] = (WlTouchProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/XdgPopupEvents.js":
/*!******************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/XdgPopupEvents.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return XdgPopupEvents; });
/*
 *
 *    Copyright © 2008-2013 Kristian Høgsberg
 *    Copyright © 2013      Rafael Antognolli
 *    Copyright © 2013      Jasper St. Pierre
 *    Copyright © 2010-2013 Intel Corporation
 *    Copyright © 2015-2017 Samsung Electronics Co., Ltd
 *    Copyright © 2015-2017 Red Hat Inc.
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
 *    to deal in the Software without restriction, including without limitation
 *    the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *    and/or sell copies of the Software, and to permit persons to whom the
 *    Software is furnished to do so, subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the next
 *    paragraph) shall be included in all copies or substantial portions of the
 *    Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *    DEALINGS IN THE SOFTWARE.
 *  
 */

/**
 * @interface
 */
class XdgPopupEvents {

	/**
	 *
	 *	This event asks the popup surface to configure itself given the
	 *	configuration. The configured state should not be applied immediately.
	 *	See xdg_surface.configure for details.
	 *
	 *	The x and y arguments represent the position the popup was placed at
	 *	given the xdg_positioner rule, relative to the upper left corner of the
	 *	window geometry of the parent surface.
	 *      
	 *
	 * @param {number} x x position relative to parent surface window geometry 
	 * @param {number} y y position relative to parent surface window geometry 
	 * @param {number} width window geometry width 
	 * @param {number} height window geometry height 
	 *
	 * @since 1
	 *
	 */
	configure(x, y, width, height) {}

	/**
	 *
	 *	The popup_done event is sent out when a popup is dismissed by the
	 *	compositor. The client should destroy the xdg_popup object at this
	 *	point.
	 *      
	 *
	 *
	 * @since 1
	 *
	 */
	popupDone() {}
}



/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/XdgPopupProxy.js":
/*!*****************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/XdgPopupProxy.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/*
 *
 *    Copyright © 2008-2013 Kristian Høgsberg
 *    Copyright © 2013      Rafael Antognolli
 *    Copyright © 2013      Jasper St. Pierre
 *    Copyright © 2010-2013 Intel Corporation
 *    Copyright © 2015-2017 Samsung Electronics Co., Ltd
 *    Copyright © 2015-2017 Red Hat Inc.
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
 *    to deal in the Software without restriction, including without limitation
 *    the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *    and/or sell copies of the Software, and to permit persons to whom the
 *    Software is furnished to do so, subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the next
 *    paragraph) shall be included in all copies or substantial portions of the
 *    Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *    DEALINGS IN THE SOFTWARE.
 *  
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]


/**
 *
 *      A popup surface is a short-lived, temporary surface. It can be used to
 *      implement for example menus, popovers, tooltips and other similar user
 *      interface concepts.
 *
 *      A popup can be made to take an explicit grab. See xdg_popup.grab for
 *      details.
 *
 *      When the popup is dismissed, a popup_done event will be sent out, and at
 *      the same time the surface will be unmapped. See the xdg_popup.popup_done
 *      event for details.
 *
 *      Explicitly destroying the xdg_popup object will also dismiss the popup and
 *      unmap the surface. Clients that want to dismiss the popup when another
 *      surface of their own is clicked should dismiss the popup using the destroy
 *      request.
 *
 *      The parent surface must have either the xdg_toplevel or xdg_popup surface
 *      role.
 *
 *      A newly created xdg_popup will be stacked on top of all previously created
 *      xdg_popup surfaces associated with the same xdg_toplevel.
 *
 *      The parent of an xdg_popup must be mapped (see the xdg_surface
 *      description) before the xdg_popup itself.
 *
 *      The x and y arguments passed when creating the popup object specify
 *      where the top left of the popup should be placed, relative to the
 *      local surface coordinates of the parent surface. See
 *      xdg_surface.get_popup. An xdg_popup must intersect with or be at least
 *      partially adjacent to its parent surface.
 *
 *      The client must call wl_surface.commit on the corresponding wl_surface
 *      for the xdg_popup state to take effect.
 *    
 */
class XdgPopupProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 *
	 *	This destroys the popup. Explicitly destroying the xdg_popup
	 *	object will also dismiss the popup, and unmap the surface.
	 *
	 *	If this xdg_popup is not the "topmost" popup, a protocol error
	 *	will be sent.
	 *      
	 * @since 1
	 *
	 */
	destroy () {
		super.destroy()
		this._marshall(this.id, 0, [])
	}

	/**
	 *
	 *	This request makes the created popup take an explicit grab. An explicit
	 *	grab will be dismissed when the user dismisses the popup, or when the
	 *	client destroys the xdg_popup. This can be done by the user clicking
	 *	outside the surface, using the keyboard, or even locking the screen
	 *	through closing the lid or a timeout.
	 *
	 *	If the compositor denies the grab, the popup will be immediately
	 *	dismissed.
	 *
	 *	This request must be used in response to some sort of user action like a
	 *	button press, key press, or touch down event. The serial number of the
	 *	event should be passed as 'serial'.
	 *
	 *	The parent of a grabbing popup must either be an xdg_toplevel surface or
	 *	another xdg_popup with an explicit grab. If the parent is another
	 *	xdg_popup it means that the popups are nested, with this popup now being
	 *	the topmost popup.
	 *
	 *	Nested popups must be destroyed in the reverse order they were created
	 *	in, e.g. the only popup you are allowed to destroy at all times is the
	 *	topmost one.
	 *
	 *	When compositors choose to dismiss a popup, they may dismiss every
	 *	nested grabbing popup as well. When a compositor dismisses popups, it
	 *	will follow the same dismissing order as required from the client.
	 *
	 *	The parent of a grabbing popup must either be another xdg_popup with an
	 *	active explicit grab, or an xdg_popup or xdg_toplevel, if there are no
	 *	explicit grabs already taken.
	 *
	 *	If the topmost grabbing popup is destroyed, the grab will be returned to
	 *	the parent of the popup, if that parent previously had an explicit grab.
	 *
	 *	If the parent is a grabbing popup which has already been dismissed, this
	 *	popup will be immediately dismissed. If the parent is a popup that did
	 *	not take an explicit grab, an error will be raised.
	 *
	 *	During a popup grab, the client owning the grab will receive pointer
	 *	and touch events for all their surfaces as normal (similar to an
	 *	"owner-events" grab in X11 parlance), while the top most grabbing popup
	 *	will always have keyboard focus.
	 *      
	 *
	 * @param {*} seat the wl_seat of the user event 
	 * @param {number} serial the serial of the user event 
	 *
	 * @since 1
	 *
	 */
	grab (seat, serial) {
		this._marshall(this.id, 1, [object(seat), uint(serial)])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {XdgPopupEvents|null}
		 */
		this.listener = null
	}

	async [0] (message) {
		await this.listener.configure(i(message), i(message), i(message), i(message))
	}

	async [1] (message) {
		await this.listener.popupDone()
	}

}
XdgPopupProxy.protocolName = 'xdg_popup'

XdgPopupProxy.Error = {
  /**
   * tried to grab after being mapped
   */
  invalidGrab: 0
}

/* harmony default export */ __webpack_exports__["default"] = (XdgPopupProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/XdgPositionerProxy.js":
/*!**********************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/XdgPositionerProxy.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/*
 *
 *    Copyright © 2008-2013 Kristian Høgsberg
 *    Copyright © 2013      Rafael Antognolli
 *    Copyright © 2013      Jasper St. Pierre
 *    Copyright © 2010-2013 Intel Corporation
 *    Copyright © 2015-2017 Samsung Electronics Co., Ltd
 *    Copyright © 2015-2017 Red Hat Inc.
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
 *    to deal in the Software without restriction, including without limitation
 *    the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *    and/or sell copies of the Software, and to permit persons to whom the
 *    Software is furnished to do so, subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the next
 *    paragraph) shall be included in all copies or substantial portions of the
 *    Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *    DEALINGS IN THE SOFTWARE.
 *  
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]


/**
 *
 *      The xdg_positioner provides a collection of rules for the placement of a
 *      child surface relative to a parent surface. Rules can be defined to ensure
 *      the child surface remains within the visible area's borders, and to
 *      specify how the child surface changes its position, such as sliding along
 *      an axis, or flipping around a rectangle. These positioner-created rules are
 *      constrained by the requirement that a child surface must intersect with or
 *      be at least partially adjacent to its parent surface.
 *
 *      See the various requests for details about possible rules.
 *
 *      At the time of the request, the compositor makes a copy of the rules
 *      specified by the xdg_positioner. Thus, after the request is complete the
 *      xdg_positioner object can be destroyed or reused; further changes to the
 *      object will have no effect on previous usages.
 *
 *      For an xdg_positioner object to be considered complete, it must have a
 *      non-zero size set by set_size, and a non-zero anchor rectangle set by
 *      set_anchor_rect. Passing an incomplete xdg_positioner object when
 *      positioning a surface raises an error.
 *    
 */
class XdgPositionerProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 *
	 *	Notify the compositor that the xdg_positioner will no longer be used.
	 *      
	 * @since 1
	 *
	 */
	destroy () {
		super.destroy()
		this._marshall(this.id, 0, [])
	}

	/**
	 *
	 *	Set the size of the surface that is to be positioned with the positioner
	 *	object. The size is in surface-local coordinates and corresponds to the
	 *	window geometry. See xdg_surface.set_window_geometry.
	 *
	 *	If a zero or negative size is set the invalid_input error is raised.
	 *      
	 *
	 * @param {number} width width of positioned rectangle 
	 * @param {number} height height of positioned rectangle 
	 *
	 * @since 1
	 *
	 */
	setSize (width, height) {
		this._marshall(this.id, 1, [int(width), int(height)])
	}

	/**
	 *
	 *	Specify the anchor rectangle within the parent surface that the child
	 *	surface will be placed relative to. The rectangle is relative to the
	 *	window geometry as defined by xdg_surface.set_window_geometry of the
	 *	parent surface.
	 *
	 *	When the xdg_positioner object is used to position a child surface, the
	 *	anchor rectangle may not extend outside the window geometry of the
	 *	positioned child's parent surface.
	 *
	 *	If a negative size is set the invalid_input error is raised.
	 *      
	 *
	 * @param {number} x x position of anchor rectangle 
	 * @param {number} y y position of anchor rectangle 
	 * @param {number} width width of anchor rectangle 
	 * @param {number} height height of anchor rectangle 
	 *
	 * @since 1
	 *
	 */
	setAnchorRect (x, y, width, height) {
		this._marshall(this.id, 2, [int(x), int(y), int(width), int(height)])
	}

	/**
	 *
	 *	Defines the anchor point for the anchor rectangle. The specified anchor
	 *	is used derive an anchor point that the child surface will be
	 *	positioned relative to. If a corner anchor is set (e.g. 'top_left' or
	 *	'bottom_right'), the anchor point will be at the specified corner;
	 *	otherwise, the derived anchor point will be centered on the specified
	 *	edge, or in the center of the anchor rectangle if no edge is specified.
	 *      
	 *
	 * @param {number} anchor anchor 
	 *
	 * @since 1
	 *
	 */
	setAnchor (anchor) {
		this._marshall(this.id, 3, [uint(anchor)])
	}

	/**
	 *
	 *	Defines in what direction a surface should be positioned, relative to
	 *	the anchor point of the parent surface. If a corner gravity is
	 *	specified (e.g. 'bottom_right' or 'top_left'), then the child surface
	 *	will be placed towards the specified gravity; otherwise, the child
	 *	surface will be centered over the anchor point on any axis that had no
	 *	gravity specified.
	 *      
	 *
	 * @param {number} gravity gravity direction 
	 *
	 * @since 1
	 *
	 */
	setGravity (gravity) {
		this._marshall(this.id, 4, [uint(gravity)])
	}

	/**
	 *
	 *	Specify how the window should be positioned if the originally intended
	 *	position caused the surface to be constrained, meaning at least
	 *	partially outside positioning boundaries set by the compositor. The
	 *	adjustment is set by constructing a bitmask describing the adjustment to
	 *	be made when the surface is constrained on that axis.
	 *
	 *	If no bit for one axis is set, the compositor will assume that the child
	 *	surface should not change its position on that axis when constrained.
	 *
	 *	If more than one bit for one axis is set, the order of how adjustments
	 *	are applied is specified in the corresponding adjustment descriptions.
	 *
	 *	The default adjustment is none.
	 *      
	 *
	 * @param {number} constraintAdjustment bit mask of constraint adjustments 
	 *
	 * @since 1
	 *
	 */
	setConstraintAdjustment (constraintAdjustment) {
		this._marshall(this.id, 5, [uint(constraintAdjustment)])
	}

	/**
	 *
	 *	Specify the surface position offset relative to the position of the
	 *	anchor on the anchor rectangle and the anchor on the surface. For
	 *	example if the anchor of the anchor rectangle is at (x, y), the surface
	 *	has the gravity bottom|right, and the offset is (ox, oy), the calculated
	 *	surface position will be (x + ox, y + oy). The offset position of the
	 *	surface is the one used for constraint testing. See
	 *	set_constraint_adjustment.
	 *
	 *	An example use case is placing a popup menu on top of a user interface
	 *	element, while aligning the user interface element of the parent surface
	 *	with some user interface element placed somewhere in the popup surface.
	 *      
	 *
	 * @param {number} x surface position x offset 
	 * @param {number} y surface position y offset 
	 *
	 * @since 1
	 *
	 */
	setOffset (x, y) {
		this._marshall(this.id, 6, [int(x), int(y)])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {XdgPositionerEvents|null}
		 */
		this.listener = null
	}

}
XdgPositionerProxy.protocolName = 'xdg_positioner'

XdgPositionerProxy.Error = {
  /**
   * invalid input provided
   */
  invalidInput: 0
}

XdgPositionerProxy.Anchor = {
  /**
   * 
   */
  none: 0,
  /**
   * 
   */
  top: 1,
  /**
   * 
   */
  bottom: 2,
  /**
   * 
   */
  left: 3,
  /**
   * 
   */
  right: 4,
  /**
   * 
   */
  topLeft: 5,
  /**
   * 
   */
  bottomLeft: 6,
  /**
   * 
   */
  topRight: 7,
  /**
   * 
   */
  bottomRight: 8
}

XdgPositionerProxy.Gravity = {
  /**
   * 
   */
  none: 0,
  /**
   * 
   */
  top: 1,
  /**
   * 
   */
  bottom: 2,
  /**
   * 
   */
  left: 3,
  /**
   * 
   */
  right: 4,
  /**
   * 
   */
  topLeft: 5,
  /**
   * 
   */
  bottomLeft: 6,
  /**
   * 
   */
  topRight: 7,
  /**
   * 
   */
  bottomRight: 8
}

XdgPositionerProxy.ConstraintAdjustment = {
  /**
   * 
   */
  none: 0,
  /**
   * 
   */
  slideX: 1,
  /**
   * 
   */
  slideY: 2,
  /**
   * 
   */
  flipX: 4,
  /**
   * 
   */
  flipY: 8,
  /**
   * 
   */
  resizeX: 16,
  /**
   * 
   */
  resizeY: 32
}

/* harmony default export */ __webpack_exports__["default"] = (XdgPositionerProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/XdgSurfaceEvents.js":
/*!********************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/XdgSurfaceEvents.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return XdgSurfaceEvents; });
/*
 *
 *    Copyright © 2008-2013 Kristian Høgsberg
 *    Copyright © 2013      Rafael Antognolli
 *    Copyright © 2013      Jasper St. Pierre
 *    Copyright © 2010-2013 Intel Corporation
 *    Copyright © 2015-2017 Samsung Electronics Co., Ltd
 *    Copyright © 2015-2017 Red Hat Inc.
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
 *    to deal in the Software without restriction, including without limitation
 *    the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *    and/or sell copies of the Software, and to permit persons to whom the
 *    Software is furnished to do so, subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the next
 *    paragraph) shall be included in all copies or substantial portions of the
 *    Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *    DEALINGS IN THE SOFTWARE.
 *  
 */

/**
 * @interface
 */
class XdgSurfaceEvents {

	/**
	 *
	 *	The configure event marks the end of a configure sequence. A configure
	 *	sequence is a set of one or more events configuring the state of the
	 *	xdg_surface, including the final xdg_surface.configure event.
	 *
	 *	Where applicable, xdg_surface surface roles will during a configure
	 *	sequence extend this event as a latched state sent as events before the
	 *	xdg_surface.configure event. Such events should be considered to make up
	 *	a set of atomically applied configuration states, where the
	 *	xdg_surface.configure commits the accumulated state.
	 *
	 *	Clients should arrange their surface for the new states, and then send
	 *	an ack_configure request with the serial sent in this configure event at
	 *	some point before committing the new surface.
	 *
	 *	If the client receives multiple configure events before it can respond
	 *	to one, it is free to discard all but the last event it received.
	 *      
	 *
	 * @param {number} serial serial of the configure event 
	 *
	 * @since 1
	 *
	 */
	configure(serial) {}
}



/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/XdgSurfaceProxy.js":
/*!*******************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/XdgSurfaceProxy.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/* harmony import */ var _XdgToplevelProxy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./XdgToplevelProxy */ "../../../westfield/client/runtime/src/protocol/XdgToplevelProxy.js");
/* harmony import */ var _XdgPopupProxy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./XdgPopupProxy */ "../../../westfield/client/runtime/src/protocol/XdgPopupProxy.js");
/*
 *
 *    Copyright © 2008-2013 Kristian Høgsberg
 *    Copyright © 2013      Rafael Antognolli
 *    Copyright © 2013      Jasper St. Pierre
 *    Copyright © 2010-2013 Intel Corporation
 *    Copyright © 2015-2017 Samsung Electronics Co., Ltd
 *    Copyright © 2015-2017 Red Hat Inc.
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
 *    to deal in the Software without restriction, including without limitation
 *    the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *    and/or sell copies of the Software, and to permit persons to whom the
 *    Software is furnished to do so, subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the next
 *    paragraph) shall be included in all copies or substantial portions of the
 *    Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *    DEALINGS IN THE SOFTWARE.
 *  
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]




/**
 *
 *      An interface that may be implemented by a wl_surface, for
 *      implementations that provide a desktop-style user interface.
 *
 *      It provides a base set of functionality required to construct user
 *      interface elements requiring management by the compositor, such as
 *      toplevel windows, menus, etc. The types of functionality are split into
 *      xdg_surface roles.
 *
 *      Creating an xdg_surface does not set the role for a wl_surface. In order
 *      to map an xdg_surface, the client must create a role-specific object
 *      using, e.g., get_toplevel, get_popup. The wl_surface for any given
 *      xdg_surface can have at most one role, and may not be assigned any role
 *      not based on xdg_surface.
 *
 *      A role must be assigned before any other requests are made to the
 *      xdg_surface object.
 *
 *      The client must call wl_surface.commit on the corresponding wl_surface
 *      for the xdg_surface state to take effect.
 *
 *      Creating an xdg_surface from a wl_surface which has a buffer attached or
 *      committed is a client error, and any attempts by a client to attach or
 *      manipulate a buffer prior to the first xdg_surface.configure call must
 *      also be treated as errors.
 *
 *      Mapping an xdg_surface-based role surface is defined as making it
 *      possible for the surface to be shown by the compositor. Note that
 *      a mapped surface is not guaranteed to be visible once it is mapped.
 *
 *      For an xdg_surface to be mapped by the compositor, the following
 *      conditions must be met:
 *      (1) the client has assigned an xdg_surface-based role to the surface
 *      (2) the client has set and committed the xdg_surface state and the
 *	  role-dependent state to the surface
 *      (3) the client has committed a buffer to the surface
 *
 *      A newly-unmapped surface is considered to have met condition (1) out
 *      of the 3 required conditions for mapping a surface if its role surface
 *      has not been destroyed.
 *    
 */
class XdgSurfaceProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 *
	 *	Destroy the xdg_surface object. An xdg_surface must only be destroyed
	 *	after its role object has been destroyed.
	 *      
	 * @since 1
	 *
	 */
	destroy () {
		super.destroy()
		this._marshall(this.id, 0, [])
	}

	/**
	 *
	 *	This creates an xdg_toplevel object for the given xdg_surface and gives
	 *	the associated wl_surface the xdg_toplevel role.
	 *
	 *	See the documentation of xdg_toplevel for more details about what an
	 *	xdg_toplevel is and how it is used.
	 *      
	 *
	 * @return {XdgToplevelProxy}  
	 *
	 * @since 1
	 *
	 */
	getToplevel () {
		return this._marshallConstructor(this.id, 1, _XdgToplevelProxy__WEBPACK_IMPORTED_MODULE_2__["default"], [newObject()])
	}

	/**
	 *
	 *	This creates an xdg_popup object for the given xdg_surface and gives
	 *	the associated wl_surface the xdg_popup role.
	 *
	 *	If null is passed as a parent, a parent surface must be specified using
	 *	some other protocol, before committing the initial state.
	 *
	 *	See the documentation of xdg_popup for more details about what an
	 *	xdg_popup is and how it is used.
	 *      
	 *
	 * @param {?*} parent  
	 * @param {*} positioner  
	 * @return {XdgPopupProxy}  
	 *
	 * @since 1
	 *
	 */
	getPopup (parent, positioner) {
		return this._marshallConstructor(this.id, 2, _XdgPopupProxy__WEBPACK_IMPORTED_MODULE_3__["default"], [newObject(), objectOptional(parent), object(positioner)])
	}

	/**
	 *
	 *	The window geometry of a surface is its "visible bounds" from the
	 *	user's perspective. Client-side decorations often have invisible
	 *	portions like drop-shadows which should be ignored for the
	 *	purposes of aligning, placing and constraining windows.
	 *
	 *	The window geometry is double buffered, and will be applied at the
	 *	time wl_surface.commit of the corresponding wl_surface is called.
	 *
	 *	When maintaining a position, the compositor should treat the (x, y)
	 *	coordinate of the window geometry as the top left corner of the window.
	 *	A client changing the (x, y) window geometry coordinate should in
	 *	general not alter the position of the window.
	 *
	 *	Once the window geometry of the surface is set, it is not possible to
	 *	unset it, and it will remain the same until set_window_geometry is
	 *	called again, even if a new subsurface or buffer is attached.
	 *
	 *	If never set, the value is the full bounds of the surface,
	 *	including any subsurfaces. This updates dynamically on every
	 *	commit. This unset is meant for extremely simple clients.
	 *
	 *	The arguments are given in the surface-local coordinate space of
	 *	the wl_surface associated with this xdg_surface.
	 *
	 *	The width and height must be greater than zero. Setting an invalid size
	 *	will raise an error. When applied, the effective window geometry will be
	 *	the set window geometry clamped to the bounding rectangle of the
	 *	combined geometry of the surface of the xdg_surface and the associated
	 *	subsurfaces.
	 *      
	 *
	 * @param {number} x  
	 * @param {number} y  
	 * @param {number} width  
	 * @param {number} height  
	 *
	 * @since 1
	 *
	 */
	setWindowGeometry (x, y, width, height) {
		this._marshall(this.id, 3, [int(x), int(y), int(width), int(height)])
	}

	/**
	 *
	 *	When a configure event is received, if a client commits the
	 *	surface in response to the configure event, then the client
	 *	must make an ack_configure request sometime before the commit
	 *	request, passing along the serial of the configure event.
	 *
	 *	For instance, for toplevel surfaces the compositor might use this
	 *	information to move a surface to the top left only when the client has
	 *	drawn itself for the maximized or fullscreen state.
	 *
	 *	If the client receives multiple configure events before it
	 *	can respond to one, it only has to ack the last configure event.
	 *
	 *	A client is not required to commit immediately after sending
	 *	an ack_configure request - it may even ack_configure several times
	 *	before its next surface commit.
	 *
	 *	A client may send multiple ack_configure requests before committing, but
	 *	only the last request sent before a commit indicates which configure
	 *	event the client really is responding to.
	 *      
	 *
	 * @param {number} serial the serial from the configure event 
	 *
	 * @since 1
	 *
	 */
	ackConfigure (serial) {
		this._marshall(this.id, 4, [uint(serial)])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {XdgSurfaceEvents|null}
		 */
		this.listener = null
	}

	async [0] (message) {
		await this.listener.configure(u(message))
	}

}
XdgSurfaceProxy.protocolName = 'xdg_surface'

XdgSurfaceProxy.Error = {
  /**
   * 
   */
  notConstructed: 1,
  /**
   * 
   */
  alreadyConstructed: 2,
  /**
   * 
   */
  unconfiguredBuffer: 3
}

/* harmony default export */ __webpack_exports__["default"] = (XdgSurfaceProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/XdgToplevelEvents.js":
/*!*********************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/XdgToplevelEvents.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return XdgToplevelEvents; });
/*
 *
 *    Copyright © 2008-2013 Kristian Høgsberg
 *    Copyright © 2013      Rafael Antognolli
 *    Copyright © 2013      Jasper St. Pierre
 *    Copyright © 2010-2013 Intel Corporation
 *    Copyright © 2015-2017 Samsung Electronics Co., Ltd
 *    Copyright © 2015-2017 Red Hat Inc.
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
 *    to deal in the Software without restriction, including without limitation
 *    the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *    and/or sell copies of the Software, and to permit persons to whom the
 *    Software is furnished to do so, subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the next
 *    paragraph) shall be included in all copies or substantial portions of the
 *    Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *    DEALINGS IN THE SOFTWARE.
 *  
 */

/**
 * @interface
 */
class XdgToplevelEvents {

	/**
	 *
	 *	This configure event asks the client to resize its toplevel surface or
	 *	to change its state. The configured state should not be applied
	 *	immediately. See xdg_surface.configure for details.
	 *
	 *	The width and height arguments specify a hint to the window
	 *	about how its surface should be resized in window geometry
	 *	coordinates. See set_window_geometry.
	 *
	 *	If the width or height arguments are zero, it means the client
	 *	should decide its own window dimension. This may happen when the
	 *	compositor needs to configure the state of the surface but doesn't
	 *	have any information about any previous or expected dimension.
	 *
	 *	The states listed in the event specify how the width/height
	 *	arguments should be interpreted, and possibly how it should be
	 *	drawn.
	 *
	 *	Clients must send an ack_configure in response to this event. See
	 *	xdg_surface.configure and xdg_surface.ack_configure for details.
	 *      
	 *
	 * @param {number} width  
	 * @param {number} height  
	 * @param {ArrayBuffer} states  
	 *
	 * @since 1
	 *
	 */
	configure(width, height, states) {}

	/**
	 *
	 *	The close event is sent by the compositor when the user
	 *	wants the surface to be closed. This should be equivalent to
	 *	the user clicking the close button in client-side decorations,
	 *	if your application has any.
	 *
	 *	This is only a request that the user intends to close the
	 *	window. The client may choose to ignore this request, or show
	 *	a dialog to ask the user to save their data, etc.
	 *      
	 *
	 *
	 * @since 1
	 *
	 */
	close() {}
}



/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/XdgToplevelProxy.js":
/*!********************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/XdgToplevelProxy.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/*
 *
 *    Copyright © 2008-2013 Kristian Høgsberg
 *    Copyright © 2013      Rafael Antognolli
 *    Copyright © 2013      Jasper St. Pierre
 *    Copyright © 2010-2013 Intel Corporation
 *    Copyright © 2015-2017 Samsung Electronics Co., Ltd
 *    Copyright © 2015-2017 Red Hat Inc.
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
 *    to deal in the Software without restriction, including without limitation
 *    the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *    and/or sell copies of the Software, and to permit persons to whom the
 *    Software is furnished to do so, subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the next
 *    paragraph) shall be included in all copies or substantial portions of the
 *    Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *    DEALINGS IN THE SOFTWARE.
 *  
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]


/**
 *
 *      This interface defines an xdg_surface role which allows a surface to,
 *      among other things, set window-like properties such as maximize,
 *      fullscreen, and minimize, set application-specific metadata like title and
 *      id, and well as trigger user interactive operations such as interactive
 *      resize and move.
 *
 *      Unmapping an xdg_toplevel means that the surface cannot be shown
 *      by the compositor until it is explicitly mapped again.
 *      All active operations (e.g., move, resize) are canceled and all
 *      attributes (e.g. title, state, stacking, ...) are discarded for
 *      an xdg_toplevel surface when it is unmapped.
 *
 *      Attaching a null buffer to a toplevel unmaps the surface.
 *    
 */
class XdgToplevelProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 *
	 *	This request destroys the role surface and unmaps the surface;
	 *	see "Unmapping" behavior in interface section for details.
	 *      
	 * @since 1
	 *
	 */
	destroy () {
		super.destroy()
		this._marshall(this.id, 0, [])
	}

	/**
	 *
	 *	Set the "parent" of this surface. This surface should be stacked
	 *	above the parent surface and all other ancestor surfaces.
	 *
	 *	Parent windows should be set on dialogs, toolboxes, or other
	 *	"auxiliary" surfaces, so that the parent is raised when the dialog
	 *	is raised.
	 *
	 *	Setting a null parent for a child window removes any parent-child
	 *	relationship for the child. Setting a null parent for a window which
	 *	currently has no parent is a no-op.
	 *
	 *	If the parent is unmapped then its children are managed as
	 *	though the parent of the now-unmapped parent has become the
	 *	parent of this surface. If no parent exists for the now-unmapped
	 *	parent then the children are managed as though they have no
	 *	parent surface.
	 *      
	 *
	 * @param {?*} parent  
	 *
	 * @since 1
	 *
	 */
	setParent (parent) {
		this._marshall(this.id, 1, [objectOptional(parent)])
	}

	/**
	 *
	 *	Set a short title for the surface.
	 *
	 *	This string may be used to identify the surface in a task bar,
	 *	window list, or other user interface elements provided by the
	 *	compositor.
	 *
	 *	The string must be encoded in UTF-8.
	 *      
	 *
	 * @param {string} title  
	 *
	 * @since 1
	 *
	 */
	setTitle (title) {
		this._marshall(this.id, 2, [string(title)])
	}

	/**
	 *
	 *	Set an application identifier for the surface.
	 *
	 *	The app ID identifies the general class of applications to which
	 *	the surface belongs. The compositor can use this to group multiple
	 *	surfaces together, or to determine how to launch a new application.
	 *
	 *	For D-Bus activatable applications, the app ID is used as the D-Bus
	 *	service name.
	 *
	 *	The compositor shell will try to group application surfaces together
	 *	by their app ID. As a best practice, it is suggested to select app
	 *	ID's that match the basename of the application's .desktop file.
	 *	For example, "org.freedesktop.FooViewer" where the .desktop file is
	 *	"org.freedesktop.FooViewer.desktop".
	 *
	 *	See the desktop-entry specification [0] for more details on
	 *	application identifiers and how they relate to well-known D-Bus
	 *	names and .desktop files.
	 *
	 *	[0] http://standards.freedesktop.org/desktop-entry-spec/
	 *      
	 *
	 * @param {string} appId  
	 *
	 * @since 1
	 *
	 */
	setAppId (appId) {
		this._marshall(this.id, 3, [string(appId)])
	}

	/**
	 *
	 *	Clients implementing client-side decorations might want to show
	 *	a context menu when right-clicking on the decorations, giving the
	 *	user a menu that they can use to maximize or minimize the window.
	 *
	 *	This request asks the compositor to pop up such a window menu at
	 *	the given position, relative to the local surface coordinates of
	 *	the parent surface. There are no guarantees as to what menu items
	 *	the window menu contains.
	 *
	 *	This request must be used in response to some sort of user action
	 *	like a button press, key press, or touch down event.
	 *      
	 *
	 * @param {*} seat the wl_seat of the user event 
	 * @param {number} serial the serial of the user event 
	 * @param {number} x the x position to pop up the window menu at 
	 * @param {number} y the y position to pop up the window menu at 
	 *
	 * @since 1
	 *
	 */
	showWindowMenu (seat, serial, x, y) {
		this._marshall(this.id, 4, [object(seat), uint(serial), int(x), int(y)])
	}

	/**
	 *
	 *	Start an interactive, user-driven move of the surface.
	 *
	 *	This request must be used in response to some sort of user action
	 *	like a button press, key press, or touch down event. The passed
	 *	serial is used to determine the type of interactive move (touch,
	 *	pointer, etc).
	 *
	 *	The server may ignore move requests depending on the state of
	 *	the surface (e.g. fullscreen or maximized), or if the passed serial
	 *	is no longer valid.
	 *
	 *	If triggered, the surface will lose the focus of the device
	 *	(wl_pointer, wl_touch, etc) used for the move. It is up to the
	 *	compositor to visually indicate that the move is taking place, such as
	 *	updating a pointer cursor, during the move. There is no guarantee
	 *	that the device focus will return when the move is completed.
	 *      
	 *
	 * @param {*} seat the wl_seat of the user event 
	 * @param {number} serial the serial of the user event 
	 *
	 * @since 1
	 *
	 */
	move (seat, serial) {
		this._marshall(this.id, 5, [object(seat), uint(serial)])
	}

	/**
	 *
	 *	Start a user-driven, interactive resize of the surface.
	 *
	 *	This request must be used in response to some sort of user action
	 *	like a button press, key press, or touch down event. The passed
	 *	serial is used to determine the type of interactive resize (touch,
	 *	pointer, etc).
	 *
	 *	The server may ignore resize requests depending on the state of
	 *	the surface (e.g. fullscreen or maximized).
	 *
	 *	If triggered, the client will receive configure events with the
	 *	"resize" state enum value and the expected sizes. See the "resize"
	 *	enum value for more details about what is required. The client
	 *	must also acknowledge configure events using "ack_configure". After
	 *	the resize is completed, the client will receive another "configure"
	 *	event without the resize state.
	 *
	 *	If triggered, the surface also will lose the focus of the device
	 *	(wl_pointer, wl_touch, etc) used for the resize. It is up to the
	 *	compositor to visually indicate that the resize is taking place,
	 *	such as updating a pointer cursor, during the resize. There is no
	 *	guarantee that the device focus will return when the resize is
	 *	completed.
	 *
	 *	The edges parameter specifies how the surface should be resized,
	 *	and is one of the values of the resize_edge enum. The compositor
	 *	may use this information to update the surface position for
	 *	example when dragging the top left corner. The compositor may also
	 *	use this information to adapt its behavior, e.g. choose an
	 *	appropriate cursor image.
	 *      
	 *
	 * @param {*} seat the wl_seat of the user event 
	 * @param {number} serial the serial of the user event 
	 * @param {number} edges which edge or corner is being dragged 
	 *
	 * @since 1
	 *
	 */
	resize (seat, serial, edges) {
		this._marshall(this.id, 6, [object(seat), uint(serial), uint(edges)])
	}

	/**
	 *
	 *	Set a maximum size for the window.
	 *
	 *	The client can specify a maximum size so that the compositor does
	 *	not try to configure the window beyond this size.
	 *
	 *	The width and height arguments are in window geometry coordinates.
	 *	See xdg_surface.set_window_geometry.
	 *
	 *	Values set in this way are double-buffered. They will get applied
	 *	on the next commit.
	 *
	 *	The compositor can use this information to allow or disallow
	 *	different states like maximize or fullscreen and draw accurate
	 *	animations.
	 *
	 *	Similarly, a tiling window manager may use this information to
	 *	place and resize client windows in a more effective way.
	 *
	 *	The client should not rely on the compositor to obey the maximum
	 *	size. The compositor may decide to ignore the values set by the
	 *	client and request a larger size.
	 *
	 *	If never set, or a value of zero in the request, means that the
	 *	client has no expected maximum size in the given dimension.
	 *	As a result, a client wishing to reset the maximum size
	 *	to an unspecified state can use zero for width and height in the
	 *	request.
	 *
	 *	Requesting a maximum size to be smaller than the minimum size of
	 *	a surface is illegal and will result in a protocol error.
	 *
	 *	The width and height must be greater than or equal to zero. Using
	 *	strictly negative values for width and height will result in a
	 *	protocol error.
	 *      
	 *
	 * @param {number} width  
	 * @param {number} height  
	 *
	 * @since 1
	 *
	 */
	setMaxSize (width, height) {
		this._marshall(this.id, 7, [int(width), int(height)])
	}

	/**
	 *
	 *	Set a minimum size for the window.
	 *
	 *	The client can specify a minimum size so that the compositor does
	 *	not try to configure the window below this size.
	 *
	 *	The width and height arguments are in window geometry coordinates.
	 *	See xdg_surface.set_window_geometry.
	 *
	 *	Values set in this way are double-buffered. They will get applied
	 *	on the next commit.
	 *
	 *	The compositor can use this information to allow or disallow
	 *	different states like maximize or fullscreen and draw accurate
	 *	animations.
	 *
	 *	Similarly, a tiling window manager may use this information to
	 *	place and resize client windows in a more effective way.
	 *
	 *	The client should not rely on the compositor to obey the minimum
	 *	size. The compositor may decide to ignore the values set by the
	 *	client and request a smaller size.
	 *
	 *	If never set, or a value of zero in the request, means that the
	 *	client has no expected minimum size in the given dimension.
	 *	As a result, a client wishing to reset the minimum size
	 *	to an unspecified state can use zero for width and height in the
	 *	request.
	 *
	 *	Requesting a minimum size to be larger than the maximum size of
	 *	a surface is illegal and will result in a protocol error.
	 *
	 *	The width and height must be greater than or equal to zero. Using
	 *	strictly negative values for width and height will result in a
	 *	protocol error.
	 *      
	 *
	 * @param {number} width  
	 * @param {number} height  
	 *
	 * @since 1
	 *
	 */
	setMinSize (width, height) {
		this._marshall(this.id, 8, [int(width), int(height)])
	}

	/**
	 *
	 *	Maximize the surface.
	 *
	 *	After requesting that the surface should be maximized, the compositor
	 *	will respond by emitting a configure event with the "maximized" state
	 *	and the required window geometry. The client should then update its
	 *	content, drawing it in a maximized state, i.e. without shadow or other
	 *	decoration outside of the window geometry. The client must also
	 *	acknowledge the configure when committing the new content (see
	 *	ack_configure).
	 *
	 *	It is up to the compositor to decide how and where to maximize the
	 *	surface, for example which output and what region of the screen should
	 *	be used.
	 *
	 *	If the surface was already maximized, the compositor will still emit
	 *	a configure event with the "maximized" state.
	 *
	 *	If the surface is in a fullscreen state, this request has no direct
	 *	effect. It will alter the state the surface is returned to when
	 *	unmaximized if not overridden by the compositor.
	 *      
	 * @since 1
	 *
	 */
	setMaximized () {
		this._marshall(this.id, 9, [])
	}

	/**
	 *
	 *	Unmaximize the surface.
	 *
	 *	After requesting that the surface should be unmaximized, the compositor
	 *	will respond by emitting a configure event without the "maximized"
	 *	state. If available, the compositor will include the window geometry
	 *	dimensions the window had prior to being maximized in the configure
	 *	event. The client must then update its content, drawing it in a
	 *	regular state, i.e. potentially with shadow, etc. The client must also
	 *	acknowledge the configure when committing the new content (see
	 *	ack_configure).
	 *
	 *	It is up to the compositor to position the surface after it was
	 *	unmaximized; usually the position the surface had before maximizing, if
	 *	applicable.
	 *
	 *	If the surface was already not maximized, the compositor will still
	 *	emit a configure event without the "maximized" state.
	 *
	 *	If the surface is in a fullscreen state, this request has no direct
	 *	effect. It will alter the state the surface is returned to when
	 *	unmaximized if not overridden by the compositor.
	 *      
	 * @since 1
	 *
	 */
	unsetMaximized () {
		this._marshall(this.id, 10, [])
	}

	/**
	 *
	 *	Make the surface fullscreen.
	 *
	 *	After requesting that the surface should be fullscreened, the
	 *	compositor will respond by emitting a configure event with the
	 *	"fullscreen" state and the fullscreen window geometry. The client must
	 *	also acknowledge the configure when committing the new content (see
	 *	ack_configure).
	 *
	 *	The output passed by the request indicates the client's preference as
	 *	to which display it should be set fullscreen on. If this value is NULL,
	 *	it's up to the compositor to choose which display will be used to map
	 *	this surface.
	 *
	 *	If the surface doesn't cover the whole output, the compositor will
	 *	position the surface in the center of the output and compensate with
	 *	with border fill covering the rest of the output. The content of the
	 *	border fill is undefined, but should be assumed to be in some way that
	 *	attempts to blend into the surrounding area (e.g. solid black).
	 *
	 *	If the fullscreened surface is not opaque, the compositor must make
	 *	sure that other screen content not part of the same surface tree (made
	 *	up of subsurfaces, popups or similarly coupled surfaces) are not
	 *	visible below the fullscreened surface.
	 *      
	 *
	 * @param {?*} output  
	 *
	 * @since 1
	 *
	 */
	setFullscreen (output) {
		this._marshall(this.id, 11, [objectOptional(output)])
	}

	/**
	 *
	 *	Make the surface no longer fullscreen.
	 *
	 *	After requesting that the surface should be unfullscreened, the
	 *	compositor will respond by emitting a configure event without the
	 *	"fullscreen" state.
	 *
	 *	Making a surface unfullscreen sets states for the surface based on the following:
	 *	* the state(s) it may have had before becoming fullscreen
	 *	* any state(s) decided by the compositor
	 *	* any state(s) requested by the client while the surface was fullscreen
	 *
	 *	The compositor may include the previous window geometry dimensions in
	 *	the configure event, if applicable.
	 *
	 *	The client must also acknowledge the configure when committing the new
	 *	content (see ack_configure).
	 *      
	 * @since 1
	 *
	 */
	unsetFullscreen () {
		this._marshall(this.id, 12, [])
	}

	/**
	 *
	 *	Request that the compositor minimize your surface. There is no
	 *	way to know if the surface is currently minimized, nor is there
	 *	any way to unset minimization on this surface.
	 *
	 *	If you are looking to throttle redrawing when minimized, please
	 *	instead use the wl_surface.frame event for this, as this will
	 *	also work with live previews on windows in Alt-Tab, Expose or
	 *	similar compositor features.
	 *      
	 * @since 1
	 *
	 */
	setMinimized () {
		this._marshall(this.id, 13, [])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {XdgToplevelEvents|null}
		 */
		this.listener = null
	}

	async [0] (message) {
		await this.listener.configure(i(message), i(message), a(message, false))
	}

	async [1] (message) {
		await this.listener.close()
	}

}
XdgToplevelProxy.protocolName = 'xdg_toplevel'

XdgToplevelProxy.ResizeEdge = {
  /**
   * 
   */
  none: 0,
  /**
   * 
   */
  top: 1,
  /**
   * 
   */
  bottom: 2,
  /**
   * 
   */
  left: 4,
  /**
   * 
   */
  topLeft: 5,
  /**
   * 
   */
  bottomLeft: 6,
  /**
   * 
   */
  right: 8,
  /**
   * 
   */
  topRight: 9,
  /**
   * 
   */
  bottomRight: 10
}

XdgToplevelProxy.State = {
  /**
   * the surface is maximized
   */
  maximized: 1,
  /**
   * the surface is fullscreen
   */
  fullscreen: 2,
  /**
   * the surface is being resized
   */
  resizing: 3,
  /**
   * the surface is now activated
   */
  activated: 4
}

/* harmony default export */ __webpack_exports__["default"] = (XdgToplevelProxy);


/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/XdgWmBaseEvents.js":
/*!*******************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/XdgWmBaseEvents.js ***!
  \*******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return XdgWmBaseEvents; });
/*
 *
 *    Copyright © 2008-2013 Kristian Høgsberg
 *    Copyright © 2013      Rafael Antognolli
 *    Copyright © 2013      Jasper St. Pierre
 *    Copyright © 2010-2013 Intel Corporation
 *    Copyright © 2015-2017 Samsung Electronics Co., Ltd
 *    Copyright © 2015-2017 Red Hat Inc.
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
 *    to deal in the Software without restriction, including without limitation
 *    the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *    and/or sell copies of the Software, and to permit persons to whom the
 *    Software is furnished to do so, subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the next
 *    paragraph) shall be included in all copies or substantial portions of the
 *    Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *    DEALINGS IN THE SOFTWARE.
 *  
 */

/**
 * @interface
 */
class XdgWmBaseEvents {

	/**
	 *
	 *	The ping event asks the client if it's still alive. Pass the
	 *	serial specified in the event back to the compositor by sending
	 *	a "pong" request back with the specified serial. See xdg_wm_base.ping.
	 *
	 *	Compositors can use this to determine if the client is still
	 *	alive. It's unspecified what will happen if the client doesn't
	 *	respond to the ping request, or in what timeframe. Clients should
	 *	try to respond in a reasonable amount of time.
	 *
	 *	A compositor is free to ping in any way it wants, but a client must
	 *	always respond to any xdg_wm_base object it created.
	 *      
	 *
	 * @param {number} serial pass this to the pong request 
	 *
	 * @since 1
	 *
	 */
	ping(serial) {}
}



/***/ }),

/***/ "../../../westfield/client/runtime/src/protocol/XdgWmBaseProxy.js":
/*!******************************************************************************!*\
  !*** /home/erik/git/westfield/client/runtime/src/protocol/XdgWmBaseProxy.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-common */ "../../../westfield/common/index.js");
/* harmony import */ var _Proxy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Proxy */ "../../../westfield/client/runtime/src/protocol/Proxy.js");
/* harmony import */ var _XdgPositionerProxy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./XdgPositionerProxy */ "../../../westfield/client/runtime/src/protocol/XdgPositionerProxy.js");
/* harmony import */ var _XdgSurfaceProxy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./XdgSurfaceProxy */ "../../../westfield/client/runtime/src/protocol/XdgSurfaceProxy.js");
/*
 *
 *    Copyright © 2008-2013 Kristian Høgsberg
 *    Copyright © 2013      Rafael Antognolli
 *    Copyright © 2013      Jasper St. Pierre
 *    Copyright © 2010-2013 Intel Corporation
 *    Copyright © 2015-2017 Samsung Electronics Co., Ltd
 *    Copyright © 2015-2017 Red Hat Inc.
 *
 *    Permission is hereby granted, free of charge, to any person obtaining a
 *    copy of this software and associated documentation files (the "Software"),
 *    to deal in the Software without restriction, including without limitation
 *    the rights to use, copy, modify, merge, publish, distribute, sublicense,
 *    and/or sell copies of the Software, and to permit persons to whom the
 *    Software is furnished to do so, subject to the following conditions:
 *
 *    The above copyright notice and this permission notice (including the next
 *    paragraph) shall be included in all copies or substantial portions of the
 *    Software.
 *
 *    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 *    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *    DEALINGS IN THE SOFTWARE.
 *  
 */


const { uint, uintOptional, int, intOptional, fixed, 
	fixedOptional, object, objectOptional, newObject, string, 
	stringOptional, array, arrayOptional, 
	fileDescriptorOptional, fileDescriptor, 
h, u, i, f, o, n, s, a } = westfield_runtime_common__WEBPACK_IMPORTED_MODULE_0__["Connection"]




/**
 *
 *      The xdg_wm_base interface is exposed as a global object enabling clients
 *      to turn their wl_surfaces into windows in a desktop environment. It
 *      defines the basic functionality needed for clients and the compositor to
 *      create windows that can be dragged, resized, maximized, etc, as well as
 *      creating transient windows such as popup menus.
 *    
 */
class XdgWmBaseProxy extends _Proxy__WEBPACK_IMPORTED_MODULE_1__["default"] {

	/**
	 *
	 *	Destroy this xdg_wm_base object.
	 *
	 *	Destroying a bound xdg_wm_base object while there are surfaces
	 *	still alive created by this xdg_wm_base object instance is illegal
	 *	and will result in a protocol error.
	 *      
	 * @since 1
	 *
	 */
	destroy () {
		super.destroy()
		this._marshall(this.id, 0, [])
	}

	/**
	 *
	 *	Create a positioner object. A positioner object is used to position
	 *	surfaces relative to some parent surface. See the interface description
	 *	and xdg_surface.get_popup for details.
	 *      
	 *
	 * @return {XdgPositionerProxy}  
	 *
	 * @since 1
	 *
	 */
	createPositioner () {
		return this._marshallConstructor(this.id, 1, _XdgPositionerProxy__WEBPACK_IMPORTED_MODULE_2__["default"], [newObject()])
	}

	/**
	 *
	 *	This creates an xdg_surface for the given surface. While xdg_surface
	 *	itself is not a role, the corresponding surface may only be assigned
	 *	a role extending xdg_surface, such as xdg_toplevel or xdg_popup.
	 *
	 *	This creates an xdg_surface for the given surface. An xdg_surface is
	 *	used as basis to define a role to a given surface, such as xdg_toplevel
	 *	or xdg_popup. It also manages functionality shared between xdg_surface
	 *	based surface roles.
	 *
	 *	See the documentation of xdg_surface for more details about what an
	 *	xdg_surface is and how it is used.
	 *      
	 *
	 * @param {*} surface  
	 * @return {XdgSurfaceProxy}  
	 *
	 * @since 1
	 *
	 */
	getXdgSurface (surface) {
		return this._marshallConstructor(this.id, 2, _XdgSurfaceProxy__WEBPACK_IMPORTED_MODULE_3__["default"], [newObject(), object(surface)])
	}

	/**
	 *
	 *	A client must respond to a ping event with a pong request or
	 *	the client may be deemed unresponsive. See xdg_wm_base.ping.
	 *      
	 *
	 * @param {number} serial serial of the ping event 
	 *
	 * @since 1
	 *
	 */
	pong (serial) {
		this._marshall(this.id, 3, [uint(serial)])
	}

	/**
	 * Do not construct proxies directly. Instead use one of the factory methods from other proxies.
	 *@param {Display}display
	 *@param {Connection}connection
	 *@param {number}id
	 */
	constructor (display, connection, id) {
		super(display, connection, id)
		/**
		 * @type {XdgWmBaseEvents|null}
		 */
		this.listener = null
	}

	async [0] (message) {
		await this.listener.ping(u(message))
	}

}
XdgWmBaseProxy.protocolName = 'xdg_wm_base'

XdgWmBaseProxy.Error = {
  /**
   * given wl_surface has another role
   */
  role: 0,
  /**
   * xdg_wm_base was destroyed before children
   */
  defunctSurfaces: 1,
  /**
   * the client tried to map or destroy a non-topmost popup
   */
  notTheTopmostPopup: 2,
  /**
   * the client specified an invalid popup parent surface
   */
  invalidPopupParent: 3,
  /**
   * the client provided an invalid surface state
   */
  invalidSurfaceState: 4,
  /**
   * the client provided an invalid positioner
   */
  invalidPositioner: 5
}

/* harmony default export */ __webpack_exports__["default"] = (XdgWmBaseProxy);


/***/ }),

/***/ "../../../westfield/common/index.js":
/*!************************************************!*\
  !*** /home/erik/git/westfield/common/index.js ***!
  \************************************************/
/*! exports provided: Connection, Fixed, WebFD, WlObject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_Connection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/Connection */ "../../../westfield/common/src/Connection.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Connection", function() { return _src_Connection__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _src_Fixed__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/Fixed */ "../../../westfield/common/src/Fixed.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Fixed", function() { return _src_Fixed__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _src_WebFD__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/WebFD */ "../../../westfield/common/src/WebFD.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebFD", function() { return _src_WebFD__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _src_WlObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/WlObject */ "../../../westfield/common/src/WlObject.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WlObject", function() { return _src_WlObject__WEBPACK_IMPORTED_MODULE_3__["default"]; });








/***/ }),

/***/ "../../../westfield/common/src/Connection.js":
/*!*********************************************************!*\
  !*** /home/erik/git/westfield/common/src/Connection.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Fixed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Fixed */ "../../../westfield/common/src/Fixed.js");
/*
MIT License

Copyright (c) 2017 Erik De Rijcke

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/





class Connection {
  /**
   * @param {number} arg
   * @returns {{value: number, type: 'u', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}):void}}
   */
  static uint (arg) {
    return {
      value: arg,
      type: 'u',
      size: 4,
      optional: false,
      /**
       *
       * @param {{buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = this.value
        wireMsg.bufferOffset += this.size
      }
    }
  }

  /**
   *
   * @param {number} arg
   * @returns {{value: number, type: 'u', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}):void}}
   *
   */
  static uintOptional (arg) {
    return {
      value: arg,
      type: 'u',
      size: 4,
      optional: true,
      /**
       *
       * @param {{buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = (arg === null ? 0 : this.value)
        wireMsg.bufferOffset += this.size
      }
    }
  }

  /**
   *
   * @param {WebFD} arg
   * @returns {{value: number, type: 'h', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}):void}}
   *
   */
  static fileDescriptor (arg) {
    return {
      value: arg,
      type: 'h',
      size: 0, // file descriptors are not added to the message size because they are somewhat considered meta data.
      optional: false,
      /**
       *
       * @param {{buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        wireMsg.fds.push(this.value)
      }
    }
  }

  /**
   *
   * @param {number} arg
   * @returns {{value: number, type: 'h', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}):void}}
   *
   */
  static fileDescriptorOptional (arg) {
    return {
      value: arg,
      type: 'h',
      size: 0, // file descriptors are not added to the message size because they are not part of the unix socket message buffer.
      optional: true,
      /**
       *
       * @param {{buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        wireMsg.fds.push(this.value)
      }
    }
  }

  /**
   *
   * @param {number} arg
   * @returns {{value: number, type: 'i', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}):void}}
   *
   */
  static int (arg) {
    return {
      value: arg,
      type: 'i',
      size: 4,
      optional: false,
      /**
       *
       * @param {{buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        new Int32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = this.value
        wireMsg.bufferOffset += this.size
      }
    }
  }

  /**
   *
   * @param {number} arg
   * @returns {{value: number, type: 'i', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}):void}}
   *
   */
  static intOptional (arg) {
    return {
      value: arg,
      type: 'i',
      size: 4,
      optional: true,
      /**
       *
       * @param {{buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        new Int32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = (arg === null ? 0 : this.value)
        wireMsg.bufferOffset += this.size
      }
    }
  }

  /**
   *
   * @param {Fixed} arg
   * @returns {{value: Fixed, type: 'f', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}):void}}
   */
  static fixed (arg) {
    return {
      value: arg,
      type: 'f',
      size: 4,
      optional: false,
      /**
       *
       * @param {{buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        new Int32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = this.value._raw
        wireMsg.bufferOffset += this.size
      }
    }
  }

  /**
   *
   * @param {Fixed} arg
   * @returns {{value: Fixed, type: 'f', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}):void}}
   */
  static fixedOptional (arg) {
    return {
      value: arg,
      type: 'f',
      size: 4,
      optional: true,
      /**
       *
       * @param {{buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        new Int32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = (arg === null ? 0 : this.value._raw)
        wireMsg.bufferOffset += this.size
      }
    }
  }

  /**
   *
   * @param {Resource} arg
   * @returns {{value: Resource, type: 'o', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}):void}}
   *
   */
  static object (arg) {
    return {
      value: arg,
      type: 'o',
      size: 4,
      optional: false,
      /**
       *
       * @param {{buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = this.value.id
        wireMsg.bufferOffset += this.size
      }
    }
  }

  /**
   *
   * @param {Resource} arg
   * @returns {{value: Resource, type: 'o', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}):void}}
   *
   */
  static objectOptional (arg) {
    return {
      value: arg,
      type: 'o',
      size: 4,
      optional: true,
      /**
       *
       * @param {{buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = (arg === null ? 0 : this.value.id)
        wireMsg.bufferOffset += this.size
      }
    }
  }

  /**
   * @returns {{value: number, type: 'n', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}):void}}
   */
  static newObject () {
    return {
      value: 0, // id filled in by _marshallConstructor
      type: 'n',
      size: 4,
      optional: false,
      /**
       * @param {{buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = this.value
        wireMsg.bufferOffset += this.size
      }
    }
  }

  /**
   *
   * @param {string} arg
   * @returns {{value: string, type: 's', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}):void}}
   *
   */
  static string (arg) {
    return {
      value: `${arg}\0`,
      type: 's',
      size: 4 + (function () {
        // fancy logic to calculate size with padding to a multiple of 4 bytes (int).
        // length+1 for null terminator
        return (arg.length + 1 + 3) & ~3
      })(),
      optional: false,
      /**
       * @param {{buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = this.value.length

        const strLen = this.value.length
        const buf8 = new Uint8Array(wireMsg.buffer, wireMsg.bufferOffset + 4, strLen)
        for (let i = 0; i < strLen; i++) {
          buf8[i] = this.value[i].codePointAt(0)
        }
        wireMsg.bufferOffset += this.size
      }
    }
  }

  /**
   *
   * @param {String} arg
   * @returns {{value: *, type: 's', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}):void}}
   *
   */
  static stringOptional (arg) {
    return {
      value: `${arg}\0`,
      type: 's',
      size: 4 + (function () {
        if (arg === null) {
          return 0
        } else {
          // fancy logic to calculate size with padding to a multiple of 4 bytes (int).
          // length+1 for null terminator
          return (arg.length + 1 + 3) & ~3
        }
      })(),
      optional: true,
      /**
       *
       * @param {{buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        if (this.value === null) {
          new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = 0
        } else {
          new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = this.value.length

          const strLen = this.value.length
          const buf8 = new Uint8Array(wireMsg.buffer, wireMsg.bufferOffset + 4, strLen)
          for (let i = 0; i < strLen; i++) {
            buf8[i] = this.value[i].codePointAt(0)
          }
        }
        wireMsg.bufferOffset += this.size
      }
    }
  }

  /**
   *
   * @param {TypedArray} arg
   * @returns {{value: *, type: 'a', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}):void}}
   *
   */
  static array (arg) {
    return {
      value: arg,
      type: 'a',
      size: 4 + (function () {
        // fancy logic to calculate size with padding to a multiple of 4 bytes (int).
        return (arg.byteLength + 3) & ~3
      })(),
      optional: false,
      /**
       *
       * @param {{buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}} wireMsg
       * @private
       */
      _marshallArg: function (wireMsg) {
        new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = this.value.byteLength

        const byteLength = this.value.byteLength
        new Uint8Array(wireMsg.buffer, wireMsg.bufferOffset + 4, byteLength).set(new Uint8Array(this.value.buffer, 0, byteLength))

        wireMsg.bufferOffset += this.size
      }
    }
  }

  /**
   *
   * @param {TypedArray} arg
   * @returns {{value: *, type: 'a', size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}):void}}
   *
   */
  static arrayOptional (arg) {
    return {
      value: arg,
      type: 'a',
      size: 4 + (function () {
        if (arg === null) {
          return 0
        } else {
          // fancy logic to calculate size with padding to a multiple of 4 bytes (int).
          return (arg.byteLength + 3) & ~3
        }
      })(),
      optional: true,
      _marshallArg: function (wireMsg) {
        if (this.value === null) {
          new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = 0
        } else {
          new Uint32Array(wireMsg.buffer, wireMsg.bufferOffset, 1)[0] = this.value.byteLength

          const byteLength = this.value.byteLength
          new Uint8Array(wireMsg.buffer, wireMsg.bufferOffset + 4, byteLength).set(new Uint8Array(this.value.buffer, 0, byteLength))
        }
        wireMsg.bufferOffset += this.size
      }
    }
  }

  /**
   * @param {{buffer: Uint32Array, fds: Array<WebFD>, bufferOffset: number, consumed: number, size: number}} message
   * @param {number}consumption
   * @private
   */
  static _checkMessageSize (message, consumption) {
    if (message.consumed + consumption > message.size) {
      throw new Error(`Request too short.`)
    } else {
      message.consumed += consumption
    }
  }

  /**
   *
   * @param {{buffer: Uint32Array, fds: Array<WebFD>, bufferOffset: number, consumed: number, size: number}} message
   * @returns {number}
   */
  static u (message) { // unsigned integer {number}
    Connection._checkMessageSize(message, 4)
    return message.buffer[message.bufferOffset++]
  }

  /**
   *
   * @param {{buffer: Uint32Array, fds: Array<WebFD>, bufferOffset: number, consumed: number, size: number}} message
   * @returns {number}
   */
  static i (message) {
    Connection._checkMessageSize(message, 4)
    const arg = new Int32Array(message.buffer.buffer, message.buffer.byteOffset + (message.bufferOffset * Uint32Array.BYTES_PER_ELEMENT), 1)[0]
    message.bufferOffset += 1
    return arg
  }

  /**
   *
   * @param {{buffer: Uint32Array, fds: Array<WebFD>, bufferOffset: number, consumed: number, size: number}} message
   * @returns {Fixed}
   */
  static f (message) {
    Connection._checkMessageSize(message, 4)
    const arg = new Int32Array(message.buffer.buffer, message.buffer.byteOffset + (message.bufferOffset * Uint32Array.BYTES_PER_ELEMENT), 1)[0]
    message.bufferOffset += 1
    return new _Fixed__WEBPACK_IMPORTED_MODULE_0__["default"](arg >> 0)
  }

  /**
   *
   * @param {{buffer: Uint32Array, fds: Array<WebFD>, bufferOffset: number, consumed: number, size: number}} message
   * @param {Boolean} optional
   * @param {Connection}connection
   * @returns {WlObject}
   */
  static o (message, optional, connection) {
    Connection._checkMessageSize(message, 4)
    const arg = message.buffer[message.bufferOffset++]
    if (optional && arg === 0) {
      return null
    } else {
      const wlObject = connection.wlObjects[arg]
      if (wlObject) {
        return wlObject
      } else {
        throw new Error(`Unknown object id ${arg}`)
      }
    }
  }

  /**
   * @param {{buffer: Uint32Array, fds: Array<WebFD>, bufferOffset: number, consumed: number, size: number}} message
   * @returns {number}
   */
  static n (message) {
    Connection._checkMessageSize(message, 4)
    return message.buffer[message.bufferOffset++]
  }

  /**
   *
   * @param {{buffer: Uint32Array, fds: Array<WebFD>, bufferOffset: number, consumed: number, size: number}} message
   * @param {Boolean} optional
   * @returns {String}
   */
  static s (message, optional) { // {String}
    Connection._checkMessageSize(message, 4)
    const stringSize = message.buffer[message.bufferOffset++]
    if (optional && stringSize === 0) {
      return null
    } else {
      const alignedSize = ((stringSize + 3) & ~3)
      Connection._checkMessageSize(message, alignedSize)
      // size -1 to eliminate null byte
      const byteArray = new Uint8Array(message.buffer.buffer, message.buffer.byteOffset + (message.bufferOffset * Uint32Array.BYTES_PER_ELEMENT), stringSize - 1)
      message.bufferOffset += (alignedSize / 4)
      return String.fromCharCode(...byteArray)
    }
  }

  /**
   *
   * @param {{buffer: Uint32Array, fds: Array<WebFD>, bufferOffset: number, consumed: number, size: number}} message
   * @param {Boolean} optional
   * @returns {ArrayBuffer}
   */
  static a (message, optional) {
    Connection._checkMessageSize(message, 4)
    const arraySize = message.buffer[message.bufferOffset++]
    if (optional && arraySize === 0) {
      return null
    } else {
      const alignedSize = ((arraySize + 3) & ~3)
      Connection._checkMessageSize(message, alignedSize)
      const arg = message.buffer.buffer.slice(message.buffer.byteOffset + (message.bufferOffset * Uint32Array.BYTES_PER_ELEMENT), message.buffer.byteOffset + (message.bufferOffset * Uint32Array.BYTES_PER_ELEMENT) + arraySize)
      message.bufferOffset += alignedSize
      return arg
    }
  }

  /**
   *
   * @param {{buffer: Uint32Array, fds: Array<WebFD>, bufferOffset: number, consumed: number, size: number}} message
   * @returns {WebFD}
   */
  static h (message) { // file descriptor {number}
    if (message.fds.length > 0) {
      return message.fds.shift()
    } else {
      throw new Error('Not enough file descriptors in message object.')
    }
  }

  constructor () {
    /**
     * @type {Object.<number,WlObject>}
     */
    this.wlObjects = {}
    /**
     * @type {boolean}
     * @private
     */
    this.closed = false
    /**
     * @type {Array<{buffer: ArrayBuffer, fds: Array<WebFD>}>}
     * @private
     */
    this._outMessages = []
    /**
     * @type {Array<{buffer: Uint32Array, fds: Array<WebFD>}>}
     * @private
     */
    this._inMessages = []
  }

  /**
   *
   * @param {number} id
   * @param {number} opcode
   * @param {number} size
   * @param {Array<{value: *, type: string, size: number, optional: boolean, _marshallArg: function({buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}):void}>} argsArray
   */
  marshallMsg (id, opcode, size, argsArray) {
    /**
     * @type {{buffer: ArrayBuffer, fds: Array<WebFD>, bufferOffset: number}}
     */
    const wireMsg = {
      buffer: new ArrayBuffer(size),
      fds: [],
      bufferOffset: 0
    }

    // write actual wire message
    const bufu32 = new Uint32Array(wireMsg.buffer)
    const bufu16 = new Uint16Array(wireMsg.buffer)
    bufu32[0] = id
    bufu16[2] = opcode
    bufu16[3] = size
    wireMsg.bufferOffset = 8

    // write actual argument value to buffer
    argsArray.forEach((arg) => arg._marshallArg(wireMsg))
    this.onSend(wireMsg)
  }

  /**
   * Handle received wire messages.
   * @param {{buffer: Uint32Array, fds: Array<WebFD>}} incomingWireMessages
   * @return {Promise<void>}
   * @throws Error If an illegal client request is received ie. bad length or missing file descriptor.
   */
  async message (incomingWireMessages) {
    if (this.closed) { return }

    // more than one message in queue means the message loop is in await, don't concurrently process the new
    // message, instead return early and let the resume-from-await pick up the newly queued message.
    if (this._inMessages.push(incomingWireMessages) > 1) { return }

    while (this._inMessages.length) {
      const wireMessages = /** @type {{buffer: Uint32Array, fds: Array<WebFD>, bufferOffset: number, consumed: number, size: number}} */this._inMessages[0]
      wireMessages.bufferOffset = 0
      wireMessages.consumed = 0
      wireMessages.size = 0
      while (wireMessages.bufferOffset < wireMessages.buffer.length) {
        const id = wireMessages.buffer[wireMessages.bufferOffset]
        const sizeOpcode = wireMessages.buffer[wireMessages.bufferOffset + 1]
        wireMessages.size = sizeOpcode >>> 16
        const opcode = sizeOpcode & 0x0000FFFF

        if (wireMessages.size > wireMessages.buffer.byteLength) {
          throw new Error('Request buffer too small')
        }

        const wlObject = this.wlObjects[id]
        if (wlObject) {
          wireMessages.bufferOffset += 2
          wireMessages.consumed = 8
          try {
            await wlObject[opcode](wireMessages)
          } catch (e) {
            console.error(`
wlObject: ${wlObject.constructor.name}[${opcode}](..)
name: ${e.name} message: ${e.message} text: ${e.text}
error object stack: 
${e.stack}
`)
            throw e
          }
          if (this.closed) { return }
        } else {
          throw new Error(`invalid object ${id}`)
        }
      }
      this._inMessages.shift()
    }

    this.flush()
  }

  /**
   * This doesn't actually send the message, but queues it so it can be send on flush.
   * @param {{buffer: ArrayBuffer, fds: Array<WebFD>}}wireMsg a single wire message event.
   */
  onSend (wireMsg) {
    if (this.closed) { return }

    this._outMessages.push(wireMsg)
  }

  /**
   * Empty the queue of wire messages and send them to the other end.
   */
  flush () {
    if (this.closed) { return }
    if (this._outMessages.length === 0) { return }

    this.onFlush(this._outMessages)
    this._outMessages = []
  }

  /**
   * Callback when this connection wishes to send data to the other end. This callback can be used to send the given
   * array buffers using any transport mechanism.
   * @param {Array<{buffer: ArrayBuffer, fds: Array<WebFD>}>}wireMessages
   */
  onFlush (wireMessages) {}

  close () {
    if (this.closed) { return }

    // destroy resources in descending order
    Object.values(this.wlObjects).sort((a, b) => a.id - b.id).forEach((wlObject) => wlObject.destroy())

    this._outMessages = null
    this._inMessages = null
    this.closed = true
  }

  /**
   *
   * @param {WlObject} wlObject
   */
  registerWlObject (wlObject) {
    if (this.closed) { return }
    if (wlObject.id in this.wlObjects) { throw new Error(`Illegal object id: ${wlObject.id}. Already registered.`) }
    this.wlObjects[wlObject.id] = wlObject
  }

  /**
   *
   * @param {WlObject} wlObject
   */
  unregisterWlObject (wlObject) {
    if (this.closed) { return }
    delete this.wlObjects[wlObject.id]
  }
}

/* harmony default export */ __webpack_exports__["default"] = (Connection);

/***/ }),

/***/ "../../../westfield/common/src/Fixed.js":
/*!****************************************************!*\
  !*** /home/erik/git/westfield/common/src/Fixed.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/*
MIT License

Copyright (c) 2017 Erik De Rijcke

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



class Fixed {
  /**
   * @param {number}number
   * @return {Fixed}
   */
  static parse (number) {
    return new Fixed((number * 256.0) >> 0)
  }

  /**
   * Represent fixed as a signed 24-bit integer.
   *
   * @returns {number}
   */
  asInt () {
    return ((this._raw / 256.0) >> 0)
  }

  /**
   * Represent fixed as a signed 24-bit number with an 8-bit fractional part.
   *
   * @returns {number}
   */
  asDouble () {
    return this._raw / 256.0
  }

  /**
   * use parseFixed instead
   * @param {number}raw
   */
  constructor (raw) {
    this._raw = raw
  }
}

/* harmony default export */ __webpack_exports__["default"] = (Fixed);

/***/ }),

/***/ "../../../westfield/common/src/WebFD.js":
/*!****************************************************!*\
  !*** /home/erik/git/westfield/common/src/WebFD.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/*
MIT License

Copyright (c) 2017 Erik De Rijcke

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



class WebFD {
  /**
   * @param {number}fd
   * @param {'ImageBitmap'|'ArrayBuffer'|'MessagePort'}fdType
   * @param {string}fdDomainUUID
   * @param {function(WebFD): Promise<Transferable>}onGetTransferable
   * @param {function(WebFD): Promise<void>} onClose
   */
  constructor (fd, fdType, fdDomainUUID, onGetTransferable, onClose) {
    /**
     * @type {number}
     */
    this.fd = fd
    /**
     * @type {string}
     */
    this.fdType = fdType
    /**
     * @type {string}
     */
    this.fdDomainUUID = fdDomainUUID
    /**
     * @type {function(WebFD): Promise<Transferable>}
     * @private
     */
    this._onGetTransferable = onGetTransferable
    /**
     * @type {function(WebFD): Promise<void>}
     * @private
     */
    this._onClose = onClose
  }

  /**
   * @return {Promise<Transferable>}
   */
  async getTransferable () {
    return await this._onGetTransferable(this)
  }

  /**
   * @return {Promise<void>}
   */
  async close () {
    await this._onClose(this)
  }
}

/* harmony default export */ __webpack_exports__["default"] = (WebFD);

/***/ }),

/***/ "../../../westfield/common/src/WlObject.js":
/*!*******************************************************!*\
  !*** /home/erik/git/westfield/common/src/WlObject.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/*
MIT License

Copyright (c) 2017 Erik De Rijcke

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/



class WlObject {
  constructor (id) {
    this.id = id
    /**
     * @type {Promise<void>}
     * @private
     */
    this._destroyPromise = new Promise(resolve => this._destroyResolver = resolve)
    /**
     * @type {Array<function(Resource):void>}
     * @private
     */
    this._destroyListeners = []
    this._destroyPromise.then(() => this._destroyListeners.forEach(destroyListener => destroyListener(this)))
  }

  destroy () {
    this._destroyResolver()
  }

  /**
   * @param {function(Resource):void}destroyListener
   */
  addDestroyListener (destroyListener) {
    this._destroyListeners.push(destroyListener)
  }

  /**
   * @param {function(Resource):void}destroyListener
   */
  removeDestroyListener (destroyListener) {
    this._destroyListeners = this._destroyListeners.filter((item) => { return item !== destroyListener })
  }

  /**
   * @return {Promise<void>}
   */
  onDestroy () {
    return this._destroyPromise
  }
}

/* harmony default export */ __webpack_exports__["default"] = (WlObject);

/***/ }),

/***/ "./node_modules/gl-matrix/esm/common.js":
/*!**********************************************!*\
  !*** ./node_modules/gl-matrix/esm/common.js ***!
  \**********************************************/
/*! exports provided: EPSILON, ARRAY_TYPE, RANDOM, setMatrixArrayType, toRadian, equals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON", function() { return EPSILON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARRAY_TYPE", function() { return ARRAY_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RANDOM", function() { return RANDOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setMatrixArrayType", function() { return setMatrixArrayType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRadian", function() { return toRadian; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */

function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}

/***/ }),

/***/ "./node_modules/gl-matrix/esm/index.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-matrix/esm/index.js ***!
  \*********************************************/
/*! exports provided: glMatrix, mat2, mat2d, mat3, mat4, quat, quat2, vec2, vec3, vec4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "glMatrix", function() { return _common_js__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _mat2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat2.js */ "./node_modules/gl-matrix/esm/mat2.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2", function() { return _mat2_js__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _mat2d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat2d.js */ "./node_modules/gl-matrix/esm/mat2d.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2d", function() { return _mat2d_js__WEBPACK_IMPORTED_MODULE_2__; });
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mat3.js */ "./node_modules/gl-matrix/esm/mat3.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat3", function() { return _mat3_js__WEBPACK_IMPORTED_MODULE_3__; });
/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mat4.js */ "./node_modules/gl-matrix/esm/mat4.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat4", function() { return _mat4_js__WEBPACK_IMPORTED_MODULE_4__; });
/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./quat.js */ "./node_modules/gl-matrix/esm/quat.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat", function() { return _quat_js__WEBPACK_IMPORTED_MODULE_5__; });
/* harmony import */ var _quat2_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./quat2.js */ "./node_modules/gl-matrix/esm/quat2.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat2", function() { return _quat2_js__WEBPACK_IMPORTED_MODULE_6__; });
/* harmony import */ var _vec2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./vec2.js */ "./node_modules/gl-matrix/esm/vec2.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec2", function() { return _vec2_js__WEBPACK_IMPORTED_MODULE_7__; });
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./vec3.js */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec3", function() { return _vec3_js__WEBPACK_IMPORTED_MODULE_8__; });
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./vec4.js */ "./node_modules/gl-matrix/esm/vec4.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec4", function() { return _vec4_js__WEBPACK_IMPORTED_MODULE_9__; });












/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat2.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat2.js ***!
  \********************************************/
/*! exports provided: create, clone, copy, identity, fromValues, set, transpose, invert, adjoint, determinant, multiply, rotate, scale, fromRotation, fromScaling, str, frob, LDU, add, subtract, exactEquals, equals, multiplyScalar, multiplyScalarAndAdd, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LDU", function() { return LDU; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */

function fromValues(m00, m01, m10, m11) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */

function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}
/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}
/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3]; // Calculate the determinant

  var det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;
  return out;
}
/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */

function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;
  return out;
}
/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}
/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}
/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}
/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
}
/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}
/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Alias for {@link mat2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat2.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat2d.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat2d.js ***!
  \*********************************************/
/*! exports provided: create, clone, copy, identity, fromValues, set, invert, determinant, multiply, rotate, scale, translate, fromRotation, fromScaling, fromTranslation, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 2x3 Matrix
 * @module mat2d
 *
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[4] = 0;
    out[5] = 0;
  }

  out[0] = 1;
  out[3] = 1;
  return out;
}
/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}
/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */

function fromValues(a, b, c, d, tx, ty) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */

function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}
/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */

function invert(out, a) {
  var aa = a[0],
      ab = a[1],
      ac = a[2],
      ad = a[3];
  var atx = a[4],
      aty = a[5];
  var det = aa * ad - ab * ac;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}
/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}
/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */

function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}
/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/

function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}
/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/

function translate(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}
/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ')';
}
/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1);
}
/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}
/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5));
}
/**
 * Alias for {@link mat2d.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat2d.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat3.js ***!
  \********************************************/
/*! exports provided: create, fromMat4, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, rotate, scale, fromTranslation, fromRotation, fromScaling, fromMat2d, fromQuat, normalFromMat4, projection, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat4", function() { return fromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat2d", function() { return fromMat2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat", function() { return fromQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalFromMat4", function() { return normalFromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projection", function() { return projection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */

function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */

function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */

function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */

function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
;
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/

function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/

function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */

function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/mat4.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/mat4.js ***!
  \********************************************/
/*! exports provided: create, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, scale, rotate, rotateX, rotateY, rotateZ, fromTranslation, fromScaling, fromRotation, fromXRotation, fromYRotation, fromZRotation, fromRotationTranslation, fromQuat2, getTranslation, getScaling, getRotation, fromRotationTranslationScale, fromRotationTranslationScaleOrigin, fromQuat, frustum, perspective, perspectiveFromFieldOfView, ortho, lookAt, targetTo, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromXRotation", function() { return fromXRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromYRotation", function() { return fromYRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromZRotation", function() { return fromZRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslation", function() { return fromRotationTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat2", function() { return fromQuat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTranslation", function() { return getTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScaling", function() { return getScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRotation", function() { return getRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationScale", function() { return fromRotationTranslationScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationScaleOrigin", function() { return fromRotationTranslationScaleOrigin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat", function() { return fromQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frustum", function() { return frustum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspective", function() { return perspective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspectiveFromFieldOfView", function() { return perspectiveFromFieldOfView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ortho", function() { return ortho; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lookAt", function() { return lookAt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "targetTo", function() { return targetTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */

function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */

function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */

function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.sqrt(x * x + y * y + z * z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.sqrt(x * x + y * y + z * z);
  var s, c, t;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */

function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {quat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */

function fromQuat2(out, a) {
  var translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  var trace = mat[0] + mat[5] + mat[10];
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S;
    out[2] = (mat[1] - mat[4]) / S;
  } else if (mat[0] > mat[5] && mat[0] > mat[10]) {
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S;
    out[2] = (mat[8] + mat[2]) / S;
  } else if (mat[5] > mat[10]) {
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S;
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S;
  } else {
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */

function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */

function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */

function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] && Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] && Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */

function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
;
/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/esm/quat.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/quat.js ***!
  \********************************************/
/*! exports provided: create, identity, setAxisAngle, getAxisAngle, multiply, rotateX, rotateY, rotateZ, calculateW, slerp, random, invert, conjugate, fromMat3, fromEuler, str, clone, fromValues, copy, set, add, mul, scale, dot, lerp, length, len, squaredLength, sqrLen, normalize, exactEquals, equals, rotationTo, sqlerp, setAxes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxisAngle", function() { return setAxisAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAxisAngle", function() { return getAxisAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateW", function() { return calculateW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slerp", function() { return slerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conjugate", function() { return conjugate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat3", function() { return fromMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromEuler", function() { return fromEuler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotationTo", function() { return rotationTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqlerp", function() { return sqlerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxes", function() { return setAxes; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat3.js */ "./node_modules/gl-matrix/esm/mat3.js");
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vec3.js */ "./node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vec4.js */ "./node_modules/gl-matrix/esm/vec4.js");




/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/

function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */

function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);

  if (s > _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }

  return rad;
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */

function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */

function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var u2 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var u3 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */

function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */

function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */

var clone = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["clone"];
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

var fromValues = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["fromValues"];
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */

var copy = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["copy"];
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

var set = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["set"];
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */

var add = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["add"];
/**
 * Alias for {@link quat.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

var scale = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["scale"];
/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["dot"];
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

var lerp = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["lerp"];
/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 */

var length = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["length"];
/**
 * Alias for {@link quat.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["squaredLength"];
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

var normalize = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["normalize"];
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var exactEquals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["exactEquals"];
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var equals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["equals"];
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */

var rotationTo = function () {
  var tmpvec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["create"]();
  var xUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](1, 0, 0);
  var yUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](0, 1, 0);
  return function (out, a, b) {
    var dot = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["dot"](a, b);

    if (dot < -0.999999) {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, xUnitVec3, a);
      if (_vec3_js__WEBPACK_IMPORTED_MODULE_2__["len"](tmpvec3) < 0.000001) _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, yUnitVec3, a);
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["normalize"](tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */

var setAxes = function () {
  var matr = _mat3_js__WEBPACK_IMPORTED_MODULE_1__["create"]();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();

/***/ }),

/***/ "./node_modules/gl-matrix/esm/quat2.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-matrix/esm/quat2.js ***!
  \*********************************************/
/*! exports provided: create, clone, fromValues, fromRotationTranslationValues, fromRotationTranslation, fromTranslation, fromRotation, fromMat4, copy, identity, set, getReal, getDual, setReal, setDual, getTranslation, translate, rotateX, rotateY, rotateZ, rotateByQuatAppend, rotateByQuatPrepend, rotateAroundAxis, add, multiply, mul, scale, dot, lerp, invert, conjugate, length, len, squaredLength, sqrLen, normalize, str, exactEquals, equals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationValues", function() { return fromRotationTranslationValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslation", function() { return fromRotationTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat4", function() { return fromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getReal", function() { return getReal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDual", function() { return getDual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setReal", function() { return setReal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setDual", function() { return setDual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTranslation", function() { return getTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateByQuatAppend", function() { return rotateByQuatAppend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateByQuatPrepend", function() { return rotateByQuatPrepend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateAroundAxis", function() { return rotateAroundAxis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conjugate", function() { return conjugate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");
/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quat.js */ "./node_modules/gl-matrix/esm/quat.js");
/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat4.js */ "./node_modules/gl-matrix/esm/mat4.js");



/**
 * Dual Quaternion<br>
 * Format: [real, dual]<br>
 * Quaternion format: XYZW<br>
 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
 * @module quat2
 */

/**
 * Creates a new identity dual quat
 *
 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
 */

function create() {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }

  dq[3] = 1;
  return dq;
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat2} a dual quaternion to clone
 * @returns {quat2} new dual quaternion
 * @function
 */

function clone(a) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = a[0];
  dq[1] = a[1];
  dq[2] = a[2];
  dq[3] = a[3];
  dq[4] = a[4];
  dq[5] = a[5];
  dq[6] = a[6];
  dq[7] = a[7];
  return dq;
}
/**
 * Creates a new dual quat initialized with the given values
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  dq[4] = x2;
  dq[5] = y2;
  dq[6] = z2;
  dq[7] = w2;
  return dq;
}
/**
 * Creates a new dual quat from the given values (quat and translation)
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component (translation)
 * @param {Number} y2 Y component (translation)
 * @param {Number} z2 Z component (translation)
 * @returns {quat2} new dual quaternion
 * @function
 */

function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  var ax = x2 * 0.5,
      ay = y2 * 0.5,
      az = z2 * 0.5;
  dq[4] = ax * w1 + ay * z1 - az * y1;
  dq[5] = ay * w1 + az * x1 - ax * z1;
  dq[6] = az * w1 + ax * y1 - ay * x1;
  dq[7] = -ax * x1 - ay * y1 - az * z1;
  return dq;
}
/**
 * Creates a dual quat from a quaternion and a translation
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {quat} q quaternion
 * @param {vec3} t tranlation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotationTranslation(out, q, t) {
  var ax = t[0] * 0.5,
      ay = t[1] * 0.5,
      az = t[2] * 0.5,
      bx = q[0],
      by = q[1],
      bz = q[2],
      bw = q[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Creates a dual quat from a translation
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {vec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromTranslation(out, t) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = t[0] * 0.5;
  out[5] = t[1] * 0.5;
  out[6] = t[2] * 0.5;
  out[7] = 0;
  return out;
}
/**
 * Creates a dual quat from a quaternion
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {quat} q the quaternion
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */

function fromRotation(out, q) {
  out[0] = q[0];
  out[1] = q[1];
  out[2] = q[2];
  out[3] = q[3];
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Creates a new dual quat from a matrix (4x4)
 *
 * @param {quat2} out the dual quaternion
 * @param {mat4} a the matrix
 * @returns {quat2} dual quat receiving operation result
 * @function
 */

function fromMat4(out, a) {
  //TODO Optimize this
  var outer = _quat_js__WEBPACK_IMPORTED_MODULE_1__["create"]();
  _mat4_js__WEBPACK_IMPORTED_MODULE_2__["getRotation"](outer, a);
  var t = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  _mat4_js__WEBPACK_IMPORTED_MODULE_2__["getTranslation"](t, a);
  fromRotationTranslation(out, outer, t);
  return out;
}
/**
 * Copy the values from one dual quat to another
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the source dual quaternion
 * @returns {quat2} out
 * @function
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  return out;
}
/**
 * Set a dual quat to the identity dual quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @returns {quat2} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}
/**
 * Set the components of a dual quat to the given values
 *
 * @param {quat2} out the receiving quaternion
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} out
 * @function
 */

function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {
  out[0] = x1;
  out[1] = y1;
  out[2] = z1;
  out[3] = w1;
  out[4] = x2;
  out[5] = y2;
  out[6] = z2;
  out[7] = w2;
  return out;
}
/**
 * Gets the real part of a dual quat
 * @param  {quat} out real part
 * @param  {quat2} a Dual Quaternion
 * @return {quat} real part
 */

var getReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__["copy"];
/**
 * Gets the dual part of a dual quat
 * @param  {quat} out dual part
 * @param  {quat2} a Dual Quaternion
 * @return {quat} dual part
 */

function getDual(out, a) {
  out[0] = a[4];
  out[1] = a[5];
  out[2] = a[6];
  out[3] = a[7];
  return out;
}
/**
 * Set the real component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat} q a quaternion representing the real part
 * @returns {quat2} out
 * @function
 */

var setReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__["copy"];
/**
 * Set the dual component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat} q a quaternion representing the dual part
 * @returns {quat2} out
 * @function
 */

function setDual(out, q) {
  out[4] = q[0];
  out[5] = q[1];
  out[6] = q[2];
  out[7] = q[3];
  return out;
}
/**
 * Gets the translation of a normalized dual quat
 * @param  {vec3} out translation
 * @param  {quat2} a Dual Quaternion to be decomposed
 * @return {vec3} translation
 */

function getTranslation(out, a) {
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3];
  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  return out;
}
/**
 * Translates a dual quat by the given vector
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to translate
 * @param {vec3} v vector to translate by
 * @returns {quat2} out
 */

function translate(out, a, v) {
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3],
      bx1 = v[0] * 0.5,
      by1 = v[1] * 0.5,
      bz1 = v[2] * 0.5,
      ax2 = a[4],
      ay2 = a[5],
      az2 = a[6],
      aw2 = a[7];
  out[0] = ax1;
  out[1] = ay1;
  out[2] = az1;
  out[3] = aw1;
  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
  return out;
}
/**
 * Rotates a dual quat around the X axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateX(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateX"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Y axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateY(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateY"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat around the Z axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */

function rotateZ(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateZ"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (a * q)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {quat} q quaternion to rotate by
 * @returns {quat2} out
 */

function rotateByQuatAppend(out, a, q) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
  ax = a[4];
  ay = a[5];
  az = a[6];
  aw = a[7];
  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
  return out;
}
/**
 * Rotates a dual quat by a given quaternion (q * a)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat} q quaternion to rotate by
 * @param {quat2} a the dual quaternion to rotate
 * @returns {quat2} out
 */

function rotateByQuatPrepend(out, q, a) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      bx = a[0],
      by = a[1],
      bz = a[2],
      bw = a[3];
  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
  bx = a[4];
  by = a[5];
  bz = a[6];
  bw = a[7];
  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
  return out;
}
/**
 * Rotates a dual quat around a given axis. Does the normalisation automatically
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {vec3} axis the axis to rotate around
 * @param {Number} rad how far the rotation should be
 * @returns {quat2} out
 */

function rotateAroundAxis(out, a, axis, rad) {
  //Special case for rad = 0
  if (Math.abs(rad) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return copy(out, a);
  }

  var axisLength = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);
  rad = rad * 0.5;
  var s = Math.sin(rad);
  var bx = s * axis[0] / axisLength;
  var by = s * axis[1] / axisLength;
  var bz = s * axis[2] / axisLength;
  var bw = Math.cos(rad);
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3];
  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  out[4] = ax * bw + aw * bx + ay * bz - az * by;
  out[5] = ay * bw + aw * by + az * bx - ax * bz;
  out[6] = az * bw + aw * bz + ax * by - ay * bx;
  out[7] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Adds two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {quat2} out
 * @function
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  return out;
}
/**
 * Multiplies two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {quat2} out
 */

function multiply(out, a, b) {
  var ax0 = a[0],
      ay0 = a[1],
      az0 = a[2],
      aw0 = a[3],
      bx1 = b[4],
      by1 = b[5],
      bz1 = b[6],
      bw1 = b[7],
      ax1 = a[4],
      ay1 = a[5],
      az1 = a[6],
      aw1 = a[7],
      bx0 = b[0],
      by0 = b[1],
      bz0 = b[2],
      bw0 = b[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}
/**
 * Alias for {@link quat2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a dual quat by a scalar number
 *
 * @param {quat2} out the receiving dual quat
 * @param {quat2} a the dual quat to scale
 * @param {Number} b amount to scale the dual quat by
 * @returns {quat2} out
 * @function
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  return out;
}
/**
 * Calculates the dot product of two dual quat's (The dot product of the real parts)
 *
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _quat_js__WEBPACK_IMPORTED_MODULE_1__["dot"];
/**
 * Performs a linear interpolation between two dual quats's
 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
 *
 * @param {quat2} out the receiving dual quat
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat2} out
 */

function lerp(out, a, b, t) {
  var mt = 1 - t;
  if (dot(a, b) < 0) t = -t;
  out[0] = a[0] * mt + b[0] * t;
  out[1] = a[1] * mt + b[1] * t;
  out[2] = a[2] * mt + b[2] * t;
  out[3] = a[3] * mt + b[3] * t;
  out[4] = a[4] * mt + b[4] * t;
  out[5] = a[5] * mt + b[5] * t;
  out[6] = a[6] * mt + b[6] * t;
  out[7] = a[7] * mt + b[7] * t;
  return out;
}
/**
 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a dual quat to calculate inverse of
 * @returns {quat2} out
 */

function invert(out, a) {
  var sqlen = squaredLength(a);
  out[0] = -a[0] / sqlen;
  out[1] = -a[1] / sqlen;
  out[2] = -a[2] / sqlen;
  out[3] = a[3] / sqlen;
  out[4] = -a[4] / sqlen;
  out[5] = -a[5] / sqlen;
  out[6] = -a[6] / sqlen;
  out[7] = a[7] / sqlen;
  return out;
}
/**
 * Calculates the conjugate of a dual quat
 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat2} a quat to calculate conjugate of
 * @returns {quat2} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  out[4] = -a[4];
  out[5] = -a[5];
  out[6] = -a[6];
  out[7] = a[7];
  return out;
}
/**
 * Calculates the length of a dual quat
 *
 * @param {quat2} a dual quat to calculate length of
 * @returns {Number} length of a
 * @function
 */

var length = _quat_js__WEBPACK_IMPORTED_MODULE_1__["length"];
/**
 * Alias for {@link quat2.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a dual quat
 *
 * @param {quat2} a dual quat to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _quat_js__WEBPACK_IMPORTED_MODULE_1__["squaredLength"];
/**
 * Alias for {@link quat2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a dual quat
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a dual quaternion to normalize
 * @returns {quat2} out
 * @function
 */

function normalize(out, a) {
  var magnitude = squaredLength(a);

  if (magnitude > 0) {
    magnitude = Math.sqrt(magnitude);
    var a0 = a[0] / magnitude;
    var a1 = a[1] / magnitude;
    var a2 = a[2] / magnitude;
    var a3 = a[3] / magnitude;
    var b0 = a[4];
    var b1 = a[5];
    var b2 = a[6];
    var b3 = a[7];
    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = (b0 - a0 * a_dot_b) / magnitude;
    out[5] = (b1 - a1 * a_dot_b) / magnitude;
    out[6] = (b2 - a2 * a_dot_b) / magnitude;
    out[7] = (b3 - a3 * a_dot_b) / magnitude;
  }

  return out;
}
/**
 * Returns a string representation of a dual quatenion
 *
 * @param {quat2} a dual quaternion to represent as a string
 * @returns {String} string representation of the dual quat
 */

function str(a) {
  return 'quat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ')';
}
/**
 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat2} a the first dual quaternion.
 * @param {quat2} b the second dual quaternion.
 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}
/**
 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
 *
 * @param {quat2} a the first dual quat.
 * @param {quat2} b the second dual quat.
 * @returns {Boolean} true if the dual quats are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7));
}

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec2.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec2.js ***!
  \********************************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat2, transformMat2d, transformMat3, transformMat4, rotate, angle, zero, str, exactEquals, equals, len, sub, mul, div, dist, sqrDist, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat2", function() { return transformMat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat2d", function() { return transformMat2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat3", function() { return transformMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angle", function() { return angle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.sqrt(x * x + y * y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1];
  return Math.sqrt(x * x + y * y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {vec2} a The vec2 point to rotate
 * @param {vec2} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec2} out
 */

function rotate(out, a, b, c) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(c),
      cosC = Math.cos(c); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {vec2} a The first operand
 * @param {vec2} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1];
  var len1 = x1 * x1 + y1 * y1;

  if (len1 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len1 = 1 / Math.sqrt(len1);
  }

  var len2 = x2 * x2 + y2 * y2;

  if (len2 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len2 = 1 / Math.sqrt(len2);
  }

  var cosine = (x1 * x2 + y1 * y2) * len1 * len2;

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'vec2(' + a[0] + ', ' + a[1] + ')';
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec3.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec3.js ***!
  \********************************************/
/*! exports provided: create, clone, length, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, squaredLength, negate, inverse, normalize, dot, cross, lerp, hermite, bezier, random, transformMat4, transformMat3, transformQuat, rotateX, rotateY, rotateZ, angle, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hermite", function() { return hermite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bezier", function() { return bezier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat3", function() { return transformMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformQuat", function() { return transformQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angle", function() { return angle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.sqrt(x * x + y * y + z * z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 * Math.PI;
  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateX(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
  r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateY(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateZ(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
  r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var tempA = fromValues(a[0], a[1], a[2]);
  var tempB = fromValues(b[0], b[1], b[2]);
  normalize(tempA, tempA);
  normalize(tempB, tempB);
  var cosine = dot(tempA, tempB);

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/gl-matrix/esm/vec4.js":
/*!********************************************!*\
  !*** ./node_modules/gl-matrix/esm/vec4.js ***!
  \********************************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat4, transformQuat, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformQuat", function() { return transformQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/esm/common.js");

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */

function fromValues(x, y, z, w) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */

function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.sqrt(x * x + y * y + z * z + w * w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.sqrt(x * x + y * y + z * z + w * w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {vec4} result the receiving vector
 * @param {vec4} U the first vector
 * @param {vec4} V the second vector
 * @param {vec4} W the third vector
 * @returns {vec4} result
 */

function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
;
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */

function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    v2 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    v4 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */

function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var westfield_runtime_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! westfield-runtime-client */ "../../../westfield/client/runtime/index.js");
/* harmony import */ var _webgl_demo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgl-demo */ "./src/webgl-demo.js");




/**
 * @implements GrWebGLBufferEvents
 * @implements WlBufferEvents
 */
class GLBuffer {
  /**
   * @param {GrWebGlProxy}webGL
   * @param {OffscreenCanvas}offscreenCanvas
   * @param {GLBufferPool}glBufferPool
   * @return {GLBuffer}
   */
  static create (webGL, offscreenCanvas) {
    const proxy = webGL.createWebGlBuffer()
    const bufferProxy = webGL.createBuffer(proxy)

    const glBuffer = new GLBuffer(proxy, bufferProxy, offscreenCanvas)

    proxy.listener = glBuffer
    bufferProxy.listener = glBuffer

    return glBuffer
  }

  /**
   * @param {GrWebGLBufferProxy}proxy
   * @param {WlBufferProxy}bufferProxy
   * @param {OffscreenCanvas}offscreenCanvas
   */
  constructor (proxy, bufferProxy, offscreenCanvas) {
    /**
     * @type {GrWebGLBufferProxy}
     */
    this.proxy = proxy
    /**
     * @type {WlBufferProxy}
     */
    this.bufferProxy = bufferProxy
    /**
     * @type {OffscreenCanvas}
     * @private
     */
    this._offscreenCanvas = offscreenCanvas
  }

  transfer () {
    this.proxy.transfer(westfield_runtime_client__WEBPACK_IMPORTED_MODULE_0__["webFS"].fromImageBitmap(this._offscreenCanvas.transferToImageBitmap()))
  }

  /**
   *
   *  Sent when this wl_buffer is no longer used by the compositor.
   *  The client is now free to reuse or destroy this buffer and its
   *  backing storage.
   *
   *  If a client receives a release event before the frame callback
   *  requested in the same wl_surface.commit that attaches this
   *  wl_buffer to a surface, then the client is immediately free to
   *  reuse the buffer and its backing storage, and does not need a
   *  second buffer for the next surface content update. Typically
   *  this is possible, when the compositor maintains a copy of the
   *  wl_surface contents, e.g. as a GL texture. This is an important
   *  optimization for GL(ES) compositors with wl_shm clients.
   *
   *
   *
   * @since 1
   *
   */
  release () { /* NOOP */ }
}

/**
 * @implements WlRegistryEvents
 * @implements WlShellSurfaceEvents
 * @implements WlSeatEvents
 * @implements WlPointerEvents
 */
class Window {
  /**
   * @param {number}width
   * @param {number}height
   * @return {Window}
   */
  static create (width, height) {
    const registry = westfield_runtime_client__WEBPACK_IMPORTED_MODULE_0__["display"].getRegistry()
    const offscreenCanvas = new OffscreenCanvas(width, height)
    const gl = /** @type {WebGLRenderingContext} */offscreenCanvas.getContext('webgl')
    const window = new Window(registry, offscreenCanvas, gl)
    registry.listener = window
    return window
  }

  /**
   * @param {WlRegistryProxy}registry
   * @param {OffscreenCanvas} offscreenCanvas
   * @param {WebGLRenderingContext}gl
   */
  constructor (registry, offscreenCanvas, gl) {
    /**
     * @type {WlRegistryProxy}
     * @protected
     */
    this._registry = registry
    /**
     * @type {OffscreenCanvas}
     */
    this._offscreenCanvas = offscreenCanvas
    /**
     * @type {WebGLRenderingContext}
     * @protected
     */
    this._gl = gl
    /**
     * @type {GrWebGlProxy|null}
     * @private
     */
    this._webGL = null
    /**
     * @type {WlCompositorProxy|null}
     * @private
     */
    this._compositor = null
    /**
     * @type {WlShellProxy|null}
     * @private
     */
    this._shell = null
    /**
     * @type {WlSeatProxy}
     * @private
     */
    this._seat = null
    /**
     * @type {WlSurfaceProxy|null}
     * @private
     */
    this._surface = null
    /**
     * @type {WlShellSurfaceProxy|null}
     * @private
     */
    this._shellSurface = null
    /**
     * @type {GLBuffer}
     * @private
     */
    this._glBuffer = null
  }

  /**
   *
   *  Notify the client of global objects.
   *
   *  The event notifies the client that a global object with
   *  the given name is now available, and it implements the
   *  given version of the given interface.
   *
   *
   * @param {number} name numeric name of the global object
   * @param {string} interface_ interface implemented by the object
   * @param {number} version interface version
   *
   * @since 1
   *
   */
  global (name, interface_, version) {
    switch (interface_) {
      case westfield_runtime_client__WEBPACK_IMPORTED_MODULE_0__["WlCompositorProxy"].protocolName: {
        this._compositor = this._registry.bind(name, westfield_runtime_client__WEBPACK_IMPORTED_MODULE_0__["WlCompositorProxy"].protocolName, westfield_runtime_client__WEBPACK_IMPORTED_MODULE_0__["WlCompositorProxy"], version)
        this._surface = this._compositor.createSurface()
        this._onFrame = Object(westfield_runtime_client__WEBPACK_IMPORTED_MODULE_0__["frame"])(this._surface)
        break
      }

      case westfield_runtime_client__WEBPACK_IMPORTED_MODULE_0__["GrWebGlProxy"].protocolName: {
        this._webGL = this._registry.bind(name, westfield_runtime_client__WEBPACK_IMPORTED_MODULE_0__["GrWebGlProxy"].protocolName, westfield_runtime_client__WEBPACK_IMPORTED_MODULE_0__["GrWebGlProxy"], version)
        this._glBuffer = GLBuffer.create(this._webGL, this._offscreenCanvas)
        break
      }

      case westfield_runtime_client__WEBPACK_IMPORTED_MODULE_0__["WlShellProxy"].protocolName: {
        this._shell = this._registry.bind(name, westfield_runtime_client__WEBPACK_IMPORTED_MODULE_0__["WlShellProxy"].protocolName, westfield_runtime_client__WEBPACK_IMPORTED_MODULE_0__["WlShellProxy"], version)
        break
      }

      case westfield_runtime_client__WEBPACK_IMPORTED_MODULE_0__["WlSeatProxy"].protocolName: {
        this._seat = this._registry.bind(name, westfield_runtime_client__WEBPACK_IMPORTED_MODULE_0__["WlSeatProxy"].protocolName, westfield_runtime_client__WEBPACK_IMPORTED_MODULE_0__["WlSeatProxy"], version)
        this._seat.listener = this
      }
    }
  }

  init () {
    this._shellSurface = this._shell.getShellSurface(this._surface)
    this._shellSurface.listener = this
    this._shellSurface.setToplevel()
    this._shellSurface.setTitle('Simple WebGL')
    this._drawState = Object(_webgl_demo__WEBPACK_IMPORTED_MODULE_1__["initDraw"])(this._gl)
  }

  /**
   * @param {number}time
   */
  async draw (time) {
    requestAnimationFrame(() => {
      Object(_webgl_demo__WEBPACK_IMPORTED_MODULE_1__["drawScene"])(this._gl, this._drawState, time)
      this._glBuffer.transfer()
      this._surface.attach(this._glBuffer.bufferProxy, 0, 0)
      this._surface.damage(0, 0, this._offscreenCanvas.width, this._offscreenCanvas.height)

      // Wait for the compositor to signal that we can draw the next frame.
      // Note that using 'await' here would result in a deadlock as the event loop would be blocked, and the event
      // that resolves the await state would never be picked up by the blocked event loop.
      this._onFrame().then(time => this.draw(time))

      // serial is only required if our buffer contents would take a long time to send to the compositor ie. in a network remote case
      this._surface.commit(0)
      westfield_runtime_client__WEBPACK_IMPORTED_MODULE_0__["display"].flush()
    })
  }

  /**
   * @param {number}name
   */
  globalRemove (name) {
    // FIXME keep track of the name number of the globals we bind so we can do cleanup if a global should go away.
  }

  /**
   *
   *  The configure event asks the client to resize its surface.
   *
   *  The size is a hint, in the sense that the client is free to
   *  ignore it if it doesn't resize, pick a smaller size (to
   *  satisfy aspect ratio or resize in steps of NxM pixels).
   *
   *  The edges parameter provides a hint about how the surface
   *  was resized. The client may use this information to decide
   *  how to adjust its content to the new size (e.g. a scrolling
   *  area might adjust its content position to leave the viewable
   *  content unmoved).
   *
   *  The client is free to dismiss all but the last configure
   *  event it received.
   *
   *  The width and height arguments specify the size of the window
   *  in surface-local coordinates.
   *
   *
   * @param {number} edges how the surface was resized
   * @param {number} width new width of the surface
   * @param {number} height new height of the surface
   *
   * @since 1
   *
   */
  configure (edges, width, height) { /* NOOP */ }

  /**
   *
   *  Ping a client to check if it is receiving events and sending
   *  requests. A client is expected to reply with a pong request.
   *
   *
   * @param {number} serial serial number of the ping
   *
   * @since 1
   *
   */
  ping (serial) {
    this._shellSurface.pong(serial)
  }

  /**
   *
   *  The popup_done event is sent out when a popup grab is broken,
   *  that is, when the user clicks a surface that doesn't belong
   *  to the client owning the popup surface.
   *
   *
   *
   * @since 1
   *
   */
  popupDone () { /* NOOP */ }

  /**
   *
   *  This is emitted whenever a seat gains or loses the pointer,
   *  keyboard or touch capabilities.  The argument is a capability
   *  enum containing the complete set of capabilities this seat has.
   *
   *  When the pointer capability is added, a client may create a
   *  wl_pointer object using the wl_seat.get_pointer request. This object
   *  will receive pointer events until the capability is removed in the
   *  future.
   *
   *  When the pointer capability is removed, a client should destroy the
   *  wl_pointer objects associated with the seat where the capability was
   *  removed, using the wl_pointer.release request. No further pointer
   *  events will be received on these objects.
   *
   *  In some compositors, if a seat regains the pointer capability and a
   *  client has a previously obtained wl_pointer object of version 4 or
   *  less, that object may start sending pointer events again. This
   *  behavior is considered a misinterpretation of the intended behavior
   *  and must not be relied upon by the client. wl_pointer objects of
   *  version 5 or later must not send events if created before the most
   *  recent event notifying the client of an added pointer capability.
   *
   *  The above behavior also applies to wl_keyboard and wl_touch with the
   *  keyboard and touch capabilities, respectively.
   *
   *
   * @param {number} capabilities capabilities of the seat
   *
   * @since 1
   *
   */
  capabilities (capabilities) {
    if (capabilities & westfield_runtime_client__WEBPACK_IMPORTED_MODULE_0__["WlSeatProxy"].Capability.pointer) {
      this._pointer = this._seat.getPointer()
      this._pointer.listener = this
    } else if (this._pointer) {
      this._pointer.release()
      this._pointer = null
    }
  }

  /**
   *
   *  In a multiseat configuration this can be used by the client to help
   *  identify which physical devices the seat represents. Based on
   *  the seat configuration used by the compositor.
   *
   *
   * @param {string} name seat identifier
   *
   * @since 2
   *
   */
  name (name) { /* NOOP */ }

  axis (time, axis, value) { /* NOOP */ }

  axisDiscrete (axis, discrete) { /* NOOP */ }

  axisSource (axisSource) { /* NOOP */ }

  axisStop (time, axis) { /* NOOP */ }

  button (serial, time, button, state) {
    if (state & westfield_runtime_client__WEBPACK_IMPORTED_MODULE_0__["WlPointerProxy"].ButtonState.pressed) {
      this._shellSurface.move(this._seat, serial)
    }
  }

  enter (serial, surface, surfaceX, surfaceY) { /* NOOP */ }

  frame () { /* NOOP */ }

  leave (serial, surface) { /* NOOP */ }

  motion (time, surfaceX, surfaceY) { /* NOOP */ }
}

async function main () {
  // create a new window with some buffers
  const window = Window.create(800, 600)

  // create a sync promise
  const syncPromise = westfield_runtime_client__WEBPACK_IMPORTED_MODULE_0__["display"].sync()

  // flush out window creation & sync requests to the compositor
  westfield_runtime_client__WEBPACK_IMPORTED_MODULE_0__["display"].flush()

  // wait for compositor to have processed all our outgoing requests
  await syncPromise

  // Now begin drawing after the compositor is done processing all our requests
  window.init()
  window.draw(0)
  westfield_runtime_client__WEBPACK_IMPORTED_MODULE_0__["display"].flush()

  // wait for the display connection to close
  try {
    await westfield_runtime_client__WEBPACK_IMPORTED_MODULE_0__["display"].onClose()
    console.log('Application exit.')
  } catch (e) {
    console.error('Application terminated with error.')
    console.error(e.stackTrace)
  }
}

main()


/***/ }),

/***/ "./src/webgl-demo.js":
/*!***************************!*\
  !*** ./src/webgl-demo.js ***!
  \***************************/
/*! exports provided: initDraw, drawScene */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "initDraw", function() { return initDraw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "drawScene", function() { return drawScene; });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/esm/index.js");


//
// initBuffers
//
// Initialize the buffers we'll need. For this demo, we just
// have one object -- a simple two-dimensional square.
//
function initBuffers (gl) {
  // Create a buffer for the square's positions.
  const positionBuffer = gl.createBuffer()

  // Select the positionBuffer as the one to apply buffer
  // operations to from here out.
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)

  // Now create an array of positions for the square.
  const positions = [
    1.0, 1.0,
    -1.0, 1.0,
    1.0, -1.0,
    -1.0, -1.0
  ]

  // Now pass the list of positions into WebGL to build the
  // shape. We do this by creating a Float32Array from the
  // JavaScript array, then use it to fill the current buffer.
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW)

  // Now set up the colors for the vertices
  const colors = [
    1.0, 1.0, 1.0, 1.0, // white
    1.0, 0.0, 0.0, 1.0, // red
    0.0, 1.0, 0.0, 1.0, // green
    0.0, 0.0, 1.0, 1.0 // blue
  ]

  const colorBuffer = gl.createBuffer()
  gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer)
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW)

  return {
    position: positionBuffer,
    color: colorBuffer
  }
}

/**
 * @param gl
 * @param {{programInfo: {uniformLocations: {projectionMatrix: (WebGLUniformLocation|WebGLUniformLocation), modelViewMatrix: (WebGLUniformLocation|WebGLUniformLocation)}, attribLocations: {vertexColor: GLint, vertexPosition: GLint}, program: *}, buffers: {color, position}}} programState
 * @param time
 */
function drawScene (gl, { programInfo, buffers }, time) {
  const squareRotation = time * 0.001
  gl.clearColor(0.0, 0.0, 0.0, 0.7) // Clear to black, fully opaque
  gl.clearDepth(1.0) // Clear everything
  gl.enable(gl.DEPTH_TEST) // Enable depth testing
  gl.depthFunc(gl.LEQUAL) // Near things obscure far things

  // Clear the canvas before we start drawing on it.
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

  // Create a perspective matrix, a special matrix that is
  // used to simulate the distortion of perspective in a camera.
  // Our field of view is 45 degrees, with a width/height
  // ratio that matches the display size of the canvas
  // and we only want to see objects between 0.1 units
  // and 100 units away from the camera.
  const fieldOfView = 45 * Math.PI / 180 // in radians
  const aspect = gl.canvas.width / gl.canvas.height
  const zNear = 0.1
  const zFar = 100.0
  const projectionMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create()

  // note: glmatrix.js always has the first argument
  // as the destination to receive the result.
  gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].perspective(projectionMatrix,
    fieldOfView,
    aspect,
    zNear,
    zFar)

  // Set the drawing position to the "identity" point, which is
  // the center of the scene.
  const modelViewMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].create()

  // Now move the drawing position a bit to where we want to
  // start drawing the square.

  gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].translate(modelViewMatrix, // destination matrix
    modelViewMatrix, // matrix to translate
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(-0.0, 0.0, -6.0)) // amount to translate
  gl_matrix__WEBPACK_IMPORTED_MODULE_0__["mat4"].rotate(modelViewMatrix, // destination matrix
    modelViewMatrix, // matrix to rotate
    squareRotation, // amount to rotate in radians
    gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec3"].fromValues(0, 0, 1)) // axis to rotate around

  // Tell WebGL how to pull out the positions from the position
  // buffer into the vertexPosition attribute
  {
    const numComponents = 2
    const type = gl.FLOAT
    const normalize = false
    const stride = 0
    const offset = 0
    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position)
    gl.vertexAttribPointer(
      programInfo.attribLocations.vertexPosition,
      numComponents,
      type,
      normalize,
      stride,
      offset)
    gl.enableVertexAttribArray(
      programInfo.attribLocations.vertexPosition)
  }

  // Tell WebGL how to pull out the colors from the color buffer
  // into the vertexColor attribute.
  {
    const numComponents = 4
    const type = gl.FLOAT
    const normalize = false
    const stride = 0
    const offset = 0
    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color)
    gl.vertexAttribPointer(
      programInfo.attribLocations.vertexColor,
      numComponents,
      type,
      normalize,
      stride,
      offset)
    gl.enableVertexAttribArray(
      programInfo.attribLocations.vertexColor)
  }

  // Tell WebGL to use our program when drawing
  gl.useProgram(programInfo.program)

  // Set the shader uniforms
  gl.uniformMatrix4fv(
    programInfo.uniformLocations.projectionMatrix,
    false,
    projectionMatrix)
  gl.uniformMatrix4fv(
    programInfo.uniformLocations.modelViewMatrix,
    false,
    modelViewMatrix)

  const offset = 0
  const vertexCount = 4
  gl.drawArrays(gl.TRIANGLE_STRIP, offset, vertexCount)
}

//
// Initialize a shader program, so WebGL knows how to draw our data
//
function initShaderProgram (gl, vsSource, fsSource) {
  const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource)
  const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource)

  // Create the shader program
  const shaderProgram = gl.createProgram()
  gl.attachShader(shaderProgram, vertexShader)
  gl.attachShader(shaderProgram, fragmentShader)
  gl.linkProgram(shaderProgram)

  // If creating the shader program failed, alert
  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
    console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram))
    return null
  }

  return shaderProgram
}

//
// creates a shader of the given type, uploads the source and
// compiles it.
//
function loadShader (gl, type, source) {
  const shader = gl.createShader(type)

  // Send the source to the shader object
  gl.shaderSource(shader, source)

  // Compile the shader program
  gl.compileShader(shader)

  // See if it compiled successfully
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader))
    gl.deleteShader(shader)
    return null
  }

  return shader
}

/**
 * @param {WebGLRenderingContext}gl
 * @return {{programInfo: {uniformLocations: {projectionMatrix: (WebGLUniformLocation|WebGLUniformLocation), modelViewMatrix: (WebGLUniformLocation|WebGLUniformLocation)}, attribLocations: {vertexColor: GLint, vertexPosition: GLint}, program: *}, buffers: {color, position}}}
 */
function initDraw (gl) {
  // Vertex shader program
  const vsSource = `
    attribute vec4 aVertexPosition;
    attribute vec4 aVertexColor;

    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;

    varying lowp vec4 vColor;

    void main(void) {
      gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
      vColor = aVertexColor;
    }
  `

  // Fragment shader program
  const fsSource = `
    varying lowp vec4 vColor;

    void main(void) {
      gl_FragColor = vColor;
    }
  `

  // Initialize a shader program; this is where all the lighting
  // for the vertices and so forth is established.
  const shaderProgram = initShaderProgram(gl, vsSource, fsSource)

  // Collect all the info needed to use the shader program.
  // Look up which attributes our shader program is using
  // for aVertexPosition, aVevrtexColor and also
  // look up uniform locations.
  const programInfo = {
    program: shaderProgram,
    attribLocations: {
      vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
      vertexColor: gl.getAttribLocation(shaderProgram, 'aVertexColor')
    },
    uniformLocations: {
      projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
      modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix')
    }
  }

  // Here's where we call the routine that builds all the
  // objects we'll be drawing.
  const buffers = initBuffers(gl)

  return {
    programInfo,
    buffers
  }
}




/***/ }),

/***/ 0:
/*!****************************!*\
  !*** multi ./src/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! /home/erik/git/greenfield/demo-web-clients/simple-web-gl/src/index.js */"./src/index.js");


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy9ob21lL2VyaWsvZ2l0L3dlc3RmaWVsZC9jbGllbnQvcnVudGltZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvZXJpay9naXQvd2VzdGZpZWxkL2NsaWVudC9ydW50aW1lL3NyYy9EaXNwbGF5LmpzIiwid2VicGFjazovLy8vaG9tZS9lcmlrL2dpdC93ZXN0ZmllbGQvY2xpZW50L3J1bnRpbWUvc3JjL1dlYkZTLmpzIiwid2VicGFjazovLy8vaG9tZS9lcmlrL2dpdC93ZXN0ZmllbGQvY2xpZW50L3J1bnRpbWUvc3JjL3Byb3RvY29sL0dyV2ViR2xCdWZmZXJQcm94eS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvZXJpay9naXQvd2VzdGZpZWxkL2NsaWVudC9ydW50aW1lL3NyYy9wcm90b2NvbC9HcldlYkdsUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2VyaWsvZ2l0L3dlc3RmaWVsZC9jbGllbnQvcnVudGltZS9zcmMvcHJvdG9jb2wvR3JXZWJTaG1CdWZmZXJFdmVudHMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2VyaWsvZ2l0L3dlc3RmaWVsZC9jbGllbnQvcnVudGltZS9zcmMvcHJvdG9jb2wvR3JXZWJTaG1CdWZmZXJQcm94eS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvZXJpay9naXQvd2VzdGZpZWxkL2NsaWVudC9ydW50aW1lL3NyYy9wcm90b2NvbC9HcldlYlNobVByb3h5LmpzIiwid2VicGFjazovLy8vaG9tZS9lcmlrL2dpdC93ZXN0ZmllbGQvY2xpZW50L3J1bnRpbWUvc3JjL3Byb3RvY29sL1Byb3h5LmpzIiwid2VicGFjazovLy8vaG9tZS9lcmlrL2dpdC93ZXN0ZmllbGQvY2xpZW50L3J1bnRpbWUvc3JjL3Byb3RvY29sL1dsQnVmZmVyRXZlbnRzLmpzIiwid2VicGFjazovLy8vaG9tZS9lcmlrL2dpdC93ZXN0ZmllbGQvY2xpZW50L3J1bnRpbWUvc3JjL3Byb3RvY29sL1dsQnVmZmVyUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2VyaWsvZ2l0L3dlc3RmaWVsZC9jbGllbnQvcnVudGltZS9zcmMvcHJvdG9jb2wvV2xDYWxsYmFja0V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvZXJpay9naXQvd2VzdGZpZWxkL2NsaWVudC9ydW50aW1lL3NyYy9wcm90b2NvbC9XbENhbGxiYWNrUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2VyaWsvZ2l0L3dlc3RmaWVsZC9jbGllbnQvcnVudGltZS9zcmMvcHJvdG9jb2wvV2xDb21wb3NpdG9yUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2VyaWsvZ2l0L3dlc3RmaWVsZC9jbGllbnQvcnVudGltZS9zcmMvcHJvdG9jb2wvV2xEYXRhRGV2aWNlRXZlbnRzLmpzIiwid2VicGFjazovLy8vaG9tZS9lcmlrL2dpdC93ZXN0ZmllbGQvY2xpZW50L3J1bnRpbWUvc3JjL3Byb3RvY29sL1dsRGF0YURldmljZU1hbmFnZXJQcm94eS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvZXJpay9naXQvd2VzdGZpZWxkL2NsaWVudC9ydW50aW1lL3NyYy9wcm90b2NvbC9XbERhdGFEZXZpY2VQcm94eS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvZXJpay9naXQvd2VzdGZpZWxkL2NsaWVudC9ydW50aW1lL3NyYy9wcm90b2NvbC9XbERhdGFPZmZlckV2ZW50cy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvZXJpay9naXQvd2VzdGZpZWxkL2NsaWVudC9ydW50aW1lL3NyYy9wcm90b2NvbC9XbERhdGFPZmZlclByb3h5LmpzIiwid2VicGFjazovLy8vaG9tZS9lcmlrL2dpdC93ZXN0ZmllbGQvY2xpZW50L3J1bnRpbWUvc3JjL3Byb3RvY29sL1dsRGF0YVNvdXJjZUV2ZW50cy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvZXJpay9naXQvd2VzdGZpZWxkL2NsaWVudC9ydW50aW1lL3NyYy9wcm90b2NvbC9XbERhdGFTb3VyY2VQcm94eS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvZXJpay9naXQvd2VzdGZpZWxkL2NsaWVudC9ydW50aW1lL3NyYy9wcm90b2NvbC9XbERpc3BsYXlFdmVudHMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2VyaWsvZ2l0L3dlc3RmaWVsZC9jbGllbnQvcnVudGltZS9zcmMvcHJvdG9jb2wvV2xEaXNwbGF5UHJveHkuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2VyaWsvZ2l0L3dlc3RmaWVsZC9jbGllbnQvcnVudGltZS9zcmMvcHJvdG9jb2wvV2xLZXlib2FyZEV2ZW50cy5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvZXJpay9naXQvd2VzdGZpZWxkL2NsaWVudC9ydW50aW1lL3NyYy9wcm90b2NvbC9XbEtleWJvYXJkUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2VyaWsvZ2l0L3dlc3RmaWVsZC9jbGllbnQvcnVudGltZS9zcmMvcHJvdG9jb2wvV2xPdXRwdXRFdmVudHMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2VyaWsvZ2l0L3dlc3RmaWVsZC9jbGllbnQvcnVudGltZS9zcmMvcHJvdG9jb2wvV2xPdXRwdXRQcm94eS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvZXJpay9naXQvd2VzdGZpZWxkL2NsaWVudC9ydW50aW1lL3NyYy9wcm90b2NvbC9XbFBvaW50ZXJFdmVudHMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2VyaWsvZ2l0L3dlc3RmaWVsZC9jbGllbnQvcnVudGltZS9zcmMvcHJvdG9jb2wvV2xQb2ludGVyUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2VyaWsvZ2l0L3dlc3RmaWVsZC9jbGllbnQvcnVudGltZS9zcmMvcHJvdG9jb2wvV2xSZWdpb25Qcm94eS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvZXJpay9naXQvd2VzdGZpZWxkL2NsaWVudC9ydW50aW1lL3NyYy9wcm90b2NvbC9XbFJlZ2lzdHJ5RXZlbnRzLmpzIiwid2VicGFjazovLy8vaG9tZS9lcmlrL2dpdC93ZXN0ZmllbGQvY2xpZW50L3J1bnRpbWUvc3JjL3Byb3RvY29sL1dsUmVnaXN0cnlQcm94eS5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvZXJpay9naXQvd2VzdGZpZWxkL2NsaWVudC9ydW50aW1lL3NyYy9wcm90b2NvbC9XbFNlYXRFdmVudHMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2VyaWsvZ2l0L3dlc3RmaWVsZC9jbGllbnQvcnVudGltZS9zcmMvcHJvdG9jb2wvV2xTZWF0UHJveHkuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2VyaWsvZ2l0L3dlc3RmaWVsZC9jbGllbnQvcnVudGltZS9zcmMvcHJvdG9jb2wvV2xTaGVsbFByb3h5LmpzIiwid2VicGFjazovLy8vaG9tZS9lcmlrL2dpdC93ZXN0ZmllbGQvY2xpZW50L3J1bnRpbWUvc3JjL3Byb3RvY29sL1dsU2hlbGxTdXJmYWNlRXZlbnRzLmpzIiwid2VicGFjazovLy8vaG9tZS9lcmlrL2dpdC93ZXN0ZmllbGQvY2xpZW50L3J1bnRpbWUvc3JjL3Byb3RvY29sL1dsU2hlbGxTdXJmYWNlUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2VyaWsvZ2l0L3dlc3RmaWVsZC9jbGllbnQvcnVudGltZS9zcmMvcHJvdG9jb2wvV2xTdWJjb21wb3NpdG9yUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2VyaWsvZ2l0L3dlc3RmaWVsZC9jbGllbnQvcnVudGltZS9zcmMvcHJvdG9jb2wvV2xTdWJzdXJmYWNlUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2VyaWsvZ2l0L3dlc3RmaWVsZC9jbGllbnQvcnVudGltZS9zcmMvcHJvdG9jb2wvV2xTdXJmYWNlRXZlbnRzLmpzIiwid2VicGFjazovLy8vaG9tZS9lcmlrL2dpdC93ZXN0ZmllbGQvY2xpZW50L3J1bnRpbWUvc3JjL3Byb3RvY29sL1dsU3VyZmFjZVByb3h5LmpzIiwid2VicGFjazovLy8vaG9tZS9lcmlrL2dpdC93ZXN0ZmllbGQvY2xpZW50L3J1bnRpbWUvc3JjL3Byb3RvY29sL1dsVG91Y2hFdmVudHMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2VyaWsvZ2l0L3dlc3RmaWVsZC9jbGllbnQvcnVudGltZS9zcmMvcHJvdG9jb2wvV2xUb3VjaFByb3h5LmpzIiwid2VicGFjazovLy8vaG9tZS9lcmlrL2dpdC93ZXN0ZmllbGQvY2xpZW50L3J1bnRpbWUvc3JjL3Byb3RvY29sL1hkZ1BvcHVwRXZlbnRzLmpzIiwid2VicGFjazovLy8vaG9tZS9lcmlrL2dpdC93ZXN0ZmllbGQvY2xpZW50L3J1bnRpbWUvc3JjL3Byb3RvY29sL1hkZ1BvcHVwUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2VyaWsvZ2l0L3dlc3RmaWVsZC9jbGllbnQvcnVudGltZS9zcmMvcHJvdG9jb2wvWGRnUG9zaXRpb25lclByb3h5LmpzIiwid2VicGFjazovLy8vaG9tZS9lcmlrL2dpdC93ZXN0ZmllbGQvY2xpZW50L3J1bnRpbWUvc3JjL3Byb3RvY29sL1hkZ1N1cmZhY2VFdmVudHMuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2VyaWsvZ2l0L3dlc3RmaWVsZC9jbGllbnQvcnVudGltZS9zcmMvcHJvdG9jb2wvWGRnU3VyZmFjZVByb3h5LmpzIiwid2VicGFjazovLy8vaG9tZS9lcmlrL2dpdC93ZXN0ZmllbGQvY2xpZW50L3J1bnRpbWUvc3JjL3Byb3RvY29sL1hkZ1RvcGxldmVsRXZlbnRzLmpzIiwid2VicGFjazovLy8vaG9tZS9lcmlrL2dpdC93ZXN0ZmllbGQvY2xpZW50L3J1bnRpbWUvc3JjL3Byb3RvY29sL1hkZ1RvcGxldmVsUHJveHkuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2VyaWsvZ2l0L3dlc3RmaWVsZC9jbGllbnQvcnVudGltZS9zcmMvcHJvdG9jb2wvWGRnV21CYXNlRXZlbnRzLmpzIiwid2VicGFjazovLy8vaG9tZS9lcmlrL2dpdC93ZXN0ZmllbGQvY2xpZW50L3J1bnRpbWUvc3JjL3Byb3RvY29sL1hkZ1dtQmFzZVByb3h5LmpzIiwid2VicGFjazovLy8vaG9tZS9lcmlrL2dpdC93ZXN0ZmllbGQvY29tbW9uL2luZGV4LmpzIiwid2VicGFjazovLy8vaG9tZS9lcmlrL2dpdC93ZXN0ZmllbGQvY29tbW9uL3NyYy9Db25uZWN0aW9uLmpzIiwid2VicGFjazovLy8vaG9tZS9lcmlrL2dpdC93ZXN0ZmllbGQvY29tbW9uL3NyYy9GaXhlZC5qcyIsIndlYnBhY2s6Ly8vL2hvbWUvZXJpay9naXQvd2VzdGZpZWxkL2NvbW1vbi9zcmMvV2ViRkQuanMiLCJ3ZWJwYWNrOi8vLy9ob21lL2VyaWsvZ2l0L3dlc3RmaWVsZC9jb21tb24vc3JjL1dsT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9tYXQyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL21hdDJkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL21hdDMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vbWF0NC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS9xdWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL3F1YXQyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZXNtL3ZlYzIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9lc20vdmVjMy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2wtbWF0cml4L2VzbS92ZWM0LmpzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvd2ViZ2wtZGVtby5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVlLGdGQUFpQjs7Ozs7Ozs7Ozs7OztBQzFLaEM7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNlOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMxR0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFEO0FBQ3JELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsR0FBRyxtRUFBVTtBQUNWOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw4Q0FBSzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSwrRUFBZ0I7Ozs7Ozs7Ozs7Ozs7QUN4Ty9CO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUsOEVBQWU7Ozs7Ozs7Ozs7Ozs7QUNySDlCO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDN0hBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxRDtBQUNyRCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEdBQUcsbUVBQVU7QUFDVjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOENBQUs7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsV0FBVztBQUN0QixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUsNEVBQWE7Ozs7Ozs7Ozs7Ozs7QUN4SzVCO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLEVBQUU7QUFDZCxZQUFZLE1BQU07QUFDbEIsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksRUFBRTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxNQUFNO0FBQ2xCLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUMvUkE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZSxrRkFBbUI7Ozs7Ozs7Ozs7Ozs7QUN6WWxDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXFEO0FBQ3JELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsR0FBRyxtRUFBVTtBQUNWO0FBQ3dCOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDhDQUFLOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEVBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxFQUFFO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQy9EQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxRDtBQUNyRCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEdBQUcsbUVBQVU7QUFDVjtBQUNvQjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOENBQUs7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksR0FBRztBQUNmLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyx3REFBZTtBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksR0FBRztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEdBQUc7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNu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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEVBQUU7QUFDZCxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxFQUFFO0FBQ2QsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxFQUFFO0FBQ2QsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksR0FBRztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFdBQVc7QUFDdEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWUsK0VBQWdCOzs7Ozs7Ozs7Ozs7O0FDOWpCL0I7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsTUFBTTtBQUNqQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFLO0FBQ2YsVUFBVSxLQUFLO0FBQ2Y7QUFDQSxZQUFZLEtBQUs7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGtEQUFnQjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLGtEQUFnQjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBLHdCQUF3Qjs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsTUFBTTtBQUNqQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUCx3QkFBd0IscURBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakIsWUFBWSxLQUFLO0FBQ2pCLFlBQVksS0FBSztBQUNqQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixZQUFZLEtBQUs7QUFDakI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsTUFBTTtBQUNqQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQjtBQUNBLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrREFBZ0IsK0JBQStCLGtEQUFnQiwrQkFBK0Isa0RBQWdCO0FBQy9JO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsYUFBYSxPQUFPO0FBQ3BCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhLE9BQU87QUFDcEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLE9BQU87QUFDbEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxP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QUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsS0FBSztBQUNoQixhQUFhLEtBQUs7QUFDbEI7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsV0FBVyxLQUFLO0FBQ2hCLGFBQWEsS0FBSztBQUNsQjs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixXQUFXLEtBQUs7QUFDaEIsYUFBYSxLQUFLO0FBQ2xCOztB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcsc0JBQXNCO0FBQ2pDLGFBQWEsY0FBYyxtQkFBbUIsNEhBQTRILG9CQUFvQiwwQ0FBMEMsYUFBYSxZQUFZO0FBQ2pRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtDIiwiZmlsZSI6InNpbXBsZS53ZWIuZ2wuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9cIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDApO1xuIiwiLypcbk1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgMjAxNyBFcmlrIERlIFJpamNrZVxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5jb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG5TT0ZUV0FSRS5cbiovXG5cbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgV2ViRlMgZnJvbSAnLi9zcmMvV2ViRlMnXG5pbXBvcnQgRGlzcGxheSBmcm9tICcuL3NyYy9EaXNwbGF5J1xuaW1wb3J0IHsgQ29ubmVjdGlvbiB9IGZyb20gJ3dlc3RmaWVsZC1ydW50aW1lLWNvbW1vbidcblxuLy8gY29yZSB3YXlsYW5kIHByb3RvY29sXG5pbXBvcnQgV2xEaXNwbGF5UHJveHkgZnJvbSAnLi9zcmMvcHJvdG9jb2wvV2xEaXNwbGF5UHJveHknXG5pbXBvcnQgV2xSZWdpc3RyeVByb3h5IGZyb20gJy4vc3JjL3Byb3RvY29sL1dsUmVnaXN0cnlQcm94eSdcbmltcG9ydCBXbENhbGxiYWNrUHJveHkgZnJvbSAnLi9zcmMvcHJvdG9jb2wvV2xDYWxsYmFja1Byb3h5J1xuaW1wb3J0IFdsQ29tcG9zaXRvclByb3h5IGZyb20gJy4vc3JjL3Byb3RvY29sL1dsQ29tcG9zaXRvclByb3h5J1xuLy8gaW1wb3J0IFdsU2htUG9vbFByb3h5IGZyb20gJy4vc3JjL3Byb3RvY29sL1dsU2htUG9vbFByb3h5J1xuLy8gaW1wb3J0IFdsU2htUHJveHkgZnJvbSAnLi9zcmMvcHJvdG9jb2wvV2xTaG1Qcm94eSdcbmltcG9ydCBXbEJ1ZmZlclByb3h5IGZyb20gJy4vc3JjL3Byb3RvY29sL1dsQnVmZmVyUHJveHknXG5pbXBvcnQgV2xEYXRhT2ZmZXJQcm94eSBmcm9tICcuL3NyYy9wcm90b2NvbC9XbERhdGFPZmZlclByb3h5J1xuaW1wb3J0IFdsRGF0YVNvdXJjZVByb3h5IGZyb20gJy4vc3JjL3Byb3RvY29sL1dsRGF0YVNvdXJjZVByb3h5J1xuaW1wb3J0IFdsRGF0YURldmljZVByb3h5IGZyb20gJy4vc3JjL3Byb3RvY29sL1dsRGF0YURldmljZVByb3h5J1xuaW1wb3J0IFdsRGF0YURldmljZU1hbmFnZXJQcm94eSBmcm9tICcuL3NyYy9wcm90b2NvbC9XbERhdGFEZXZpY2VNYW5hZ2VyUHJveHknXG5pbXBvcnQgV2xTaGVsbFByb3h5IGZyb20gJy4vc3JjL3Byb3RvY29sL1dsU2hlbGxQcm94eSdcbmltcG9ydCBXbFNoZWxsU3VyZmFjZVByb3h5IGZyb20gJy4vc3JjL3Byb3RvY29sL1dsU2hlbGxTdXJmYWNlUHJveHknXG5pbXBvcnQgV2xTdXJmYWNlUHJveHkgZnJvbSAnLi9zcmMvcHJvdG9jb2wvV2xTdXJmYWNlUHJveHknXG5pbXBvcnQgV2xTZWF0UHJveHkgZnJvbSAnLi9zcmMvcHJvdG9jb2wvV2xTZWF0UHJveHknXG5pbXBvcnQgV2xQb2ludGVyUHJveHkgZnJvbSAnLi9zcmMvcHJvdG9jb2wvV2xQb2ludGVyUHJveHknXG5pbXBvcnQgV2xLZXlib2FyZFByb3h5IGZyb20gJy4vc3JjL3Byb3RvY29sL1dsS2V5Ym9hcmRQcm94eSdcbmltcG9ydCBXbFRvdWNoUHJveHkgZnJvbSAnLi9zcmMvcHJvdG9jb2wvV2xUb3VjaFByb3h5J1xuaW1wb3J0IFdsT3V0cHV0UHJveHkgZnJvbSAnLi9zcmMvcHJvdG9jb2wvV2xPdXRwdXRQcm94eSdcbmltcG9ydCBXbFJlZ2lvblByb3h5IGZyb20gJy4vc3JjL3Byb3RvY29sL1dsUmVnaW9uUHJveHknXG5pbXBvcnQgV2xTdWJjb21wb3NpdG9yUHJveHkgZnJvbSAnLi9zcmMvcHJvdG9jb2wvV2xTdWJjb21wb3NpdG9yUHJveHknXG5pbXBvcnQgV2xTdWJzdXJmYWNlUHJveHkgZnJvbSAnLi9zcmMvcHJvdG9jb2wvV2xTdWJzdXJmYWNlUHJveHknXG5pbXBvcnQgV2xEaXNwbGF5RXZlbnRzIGZyb20gJy4vc3JjL3Byb3RvY29sL1dsRGlzcGxheUV2ZW50cydcbmltcG9ydCBXbFJlZ2lzdHJ5RXZlbnRzIGZyb20gJy4vc3JjL3Byb3RvY29sL1dsUmVnaXN0cnlFdmVudHMnXG5pbXBvcnQgV2xDYWxsYmFja0V2ZW50cyBmcm9tICcuL3NyYy9wcm90b2NvbC9XbENhbGxiYWNrRXZlbnRzJ1xuLy8gaW1wb3J0IFdsU2htRXZlbnRzIGZyb20gJy4vc3JjL3Byb3RvY29sL1dsU2htRXZlbnRzJ1xuaW1wb3J0IFdsQnVmZmVyRXZlbnRzIGZyb20gJy4vc3JjL3Byb3RvY29sL1dsQnVmZmVyRXZlbnRzJ1xuaW1wb3J0IFdsRGF0YU9mZmVyRXZlbnRzIGZyb20gJy4vc3JjL3Byb3RvY29sL1dsRGF0YU9mZmVyRXZlbnRzJ1xuaW1wb3J0IFdsRGF0YVNvdXJjZUV2ZW50cyBmcm9tICcuL3NyYy9wcm90b2NvbC9XbERhdGFTb3VyY2VFdmVudHMnXG5pbXBvcnQgV2xEYXRhRGV2aWNlRXZlbnRzIGZyb20gJy4vc3JjL3Byb3RvY29sL1dsRGF0YURldmljZUV2ZW50cydcbmltcG9ydCBXbFNoZWxsU3VyZmFjZUV2ZW50cyBmcm9tICcuL3NyYy9wcm90b2NvbC9XbFNoZWxsU3VyZmFjZUV2ZW50cydcbmltcG9ydCBXbFN1cmZhY2VFdmVudHMgZnJvbSAnLi9zcmMvcHJvdG9jb2wvV2xTdXJmYWNlRXZlbnRzJ1xuaW1wb3J0IFdsU2VhdEV2ZW50cyBmcm9tICcuL3NyYy9wcm90b2NvbC9XbFNlYXRFdmVudHMnXG5pbXBvcnQgV2xQb2ludGVyRXZlbnRzIGZyb20gJy4vc3JjL3Byb3RvY29sL1dsUG9pbnRlckV2ZW50cydcbmltcG9ydCBXbEtleWJvYXJkRXZlbnRzIGZyb20gJy4vc3JjL3Byb3RvY29sL1dsS2V5Ym9hcmRFdmVudHMnXG5pbXBvcnQgV2xUb3VjaEV2ZW50cyBmcm9tICcuL3NyYy9wcm90b2NvbC9XbFRvdWNoRXZlbnRzJ1xuaW1wb3J0IFdsT3V0cHV0RXZlbnRzIGZyb20gJy4vc3JjL3Byb3RvY29sL1dsT3V0cHV0RXZlbnRzJ1xuXG4vLyB4ZGdfc2hlbGxcbmltcG9ydCBYZGdXbUJhc2VQcm94eSBmcm9tICcuL3NyYy9wcm90b2NvbC9YZGdXbUJhc2VQcm94eSdcbmltcG9ydCBYZGdQb3NpdGlvbmVyUHJveHkgZnJvbSAnLi9zcmMvcHJvdG9jb2wvWGRnUG9zaXRpb25lclByb3h5J1xuaW1wb3J0IFhkZ1N1cmZhY2VQcm94eSBmcm9tICcuL3NyYy9wcm90b2NvbC9YZGdTdXJmYWNlUHJveHknXG5pbXBvcnQgWGRnVG9wbGV2ZWxQcm94eSBmcm9tICcuL3NyYy9wcm90b2NvbC9YZGdUb3BsZXZlbFByb3h5J1xuaW1wb3J0IFhkZ1BvcHVwUHJveHkgZnJvbSAnLi9zcmMvcHJvdG9jb2wvWGRnUG9wdXBQcm94eSdcbmltcG9ydCBYZGdXbUJhc2VFdmVudHMgZnJvbSAnLi9zcmMvcHJvdG9jb2wvWGRnV21CYXNlRXZlbnRzJ1xuaW1wb3J0IFhkZ1N1cmZhY2VFdmVudHMgZnJvbSAnLi9zcmMvcHJvdG9jb2wvWGRnU3VyZmFjZUV2ZW50cydcbmltcG9ydCBYZGdUb3BsZXZlbEV2ZW50cyBmcm9tICcuL3NyYy9wcm90b2NvbC9YZGdUb3BsZXZlbEV2ZW50cydcbmltcG9ydCBYZGdQb3B1cEV2ZW50cyBmcm9tICcuL3NyYy9wcm90b2NvbC9YZGdQb3B1cEV2ZW50cydcblxuLy8gd2ViIHNobVxuaW1wb3J0IEdyV2ViU2htQnVmZmVyUHJveHkgZnJvbSAnLi9zcmMvcHJvdG9jb2wvR3JXZWJTaG1CdWZmZXJQcm94eSdcbmltcG9ydCBHcldlYlNobVByb3h5IGZyb20gJy4vc3JjL3Byb3RvY29sL0dyV2ViU2htUHJveHknXG5pbXBvcnQgR3JXZWJTaG1CdWZmZXJFdmVudHMgZnJvbSAnLi9zcmMvcHJvdG9jb2wvR3JXZWJTaG1CdWZmZXJFdmVudHMnXG5cbi8vIHdlYiBnbFxuaW1wb3J0IEdyV2ViR2xCdWZmZXJQcm94eSBmcm9tICcuL3NyYy9wcm90b2NvbC9HcldlYkdsQnVmZmVyUHJveHknXG5pbXBvcnQgR3JXZWJHbFByb3h5IGZyb20gJy4vc3JjL3Byb3RvY29sL0dyV2ViR2xQcm94eSdcblxuLyoqXG4gKiBAdHlwZSB7V2ViRlN9XG4gKi9cbmNvbnN0IHdlYkZTID0gV2ViRlMuY3JlYXRlKF91dWlkdjQoKSlcbi8qKlxuICogQHR5cGUge0Nvbm5lY3Rpb259XG4gKi9cbmNvbnN0IGNvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdGlvbigpXG4vKipcbiAqIEB0eXBlIHtEaXNwbGF5fVxuICovXG5jb25zdCBkaXNwbGF5ID0gbmV3IERpc3BsYXkoY29ubmVjdGlvbilcblxuLyoqXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3V1aWR2NCAoKSB7XG4gIHJldHVybiAoWzFlN10gKyAtMWUzICsgLTRlMyArIC04ZTMgKyAtMWUxMSkucmVwbGFjZSgvWzAxOF0vZywgYyA9PlxuICAgIChjIF4gc2VsZi5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDEpKVswXSAmIDE1ID4+IGMgLyA0KS50b1N0cmluZygxNilcbiAgKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RGlzcGxheX1kaXNwbGF5XG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb259Y29ubmVjdGlvblxuICogQHBhcmFtIHtXZWJGU313ZWJGU1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3NldHVwTWVzc2FnZUhhbmRsaW5nIChkaXNwbGF5LCBjb25uZWN0aW9uLCB3ZWJGUykge1xuICAvKipcbiAgICogQHR5cGUge0FycmF5PEFycmF5PHtidWZmZXI6IEFycmF5QnVmZmVyLCBmZHM6IEFycmF5PFdlYkZEPn0+Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0IF9mbHVzaFF1ZXVlID0gW11cbiAgLyoqXG4gICAqIEBwYXJhbSB7TWVzc2FnZUV2ZW50fWV2ZW50XG4gICAqL1xuICBvbm1lc3NhZ2UgPSAoZXZlbnQpID0+IHtcbiAgICBpZiAoY29ubmVjdGlvbi5jbG9zZWQpIHsgcmV0dXJuIH1cblxuICAgIGNvbnN0IHdlYldvcmtlck1lc3NhZ2UgPSAvKiogQHR5cGUge3twcm90b2NvbE1lc3NhZ2U6QXJyYXlCdWZmZXIsIG1ldGE6QXJyYXk8VHJhbnNmZXJhYmxlPn19ICovZXZlbnQuZGF0YVxuICAgIGlmICh3ZWJXb3JrZXJNZXNzYWdlLnByb3RvY29sTWVzc2FnZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDMyQXJyYXkoLyoqIEB0eXBlIHtBcnJheUJ1ZmZlcn0gKi93ZWJXb3JrZXJNZXNzYWdlLnByb3RvY29sTWVzc2FnZSlcbiAgICAgIGNvbnN0IGZkcyA9IHdlYldvcmtlck1lc3NhZ2UubWV0YS5tYXAodHJhbnNmZXJhYmxlID0+IHtcbiAgICAgICAgaWYgKHRyYW5zZmVyYWJsZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIHdlYkZTLmZyb21BcnJheUJ1ZmZlcih0cmFuc2ZlcmFibGUpXG4gICAgICAgIH0gZWxzZSBpZiAodHJhbnNmZXJhYmxlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXApIHtcbiAgICAgICAgICByZXR1cm4gd2ViRlMuZnJvbUltYWdlQml0bWFwKHRyYW5zZmVyYWJsZSlcbiAgICAgICAgfS8vIGVsc2UgaWYgKHRyYW5zZmVyYWJsZSBpbnN0YW5jZW9mIE1lc3NhZ2VQb3J0KSB7XG4gICAgICAgIC8vIH1cbiAgICAgICAgY29uc29sZS53YXJuKGBDT01QT1NJVE9SIEJVRz8gVW5zdXBwb3J0ZWQgdHJhbnNmZXJhYmxlIHJlY2VpdmVkIGZyb20gY29tcG9zaXRvcjogJHt0cmFuc2ZlcmFibGV9LiBXZWJGRCB3aWxsIGJlIG51bGwuYClcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH0pXG4gICAgICB0cnkge1xuICAgICAgICBjb25uZWN0aW9uLm1lc3NhZ2UoeyBidWZmZXIsIGZkcyB9KVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZGlzcGxheS5lcnJvckhhbmRsZXIgJiYgdHlwZW9mIGRpc3BsYXkuZXJyb3JIYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGlzcGxheS5lcnJvckhhbmRsZXIoZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdcXHRuYW1lOiAnICsgZS5uYW1lICsgJyBtZXNzYWdlOiAnICsgZS5tZXNzYWdlICsgJyB0ZXh0OiAnICsgZS50ZXh0KVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2Vycm9yIG9iamVjdCBzdGFjazogJylcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGUuc3RhY2spXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihgW3dlYi13b3JrZXItY2xpZW50XSBzZXJ2ZXIgc2VuZCBhbiBpbGxlZ2FsIG1lc3NhZ2UuYClcbiAgICAgIGNvbm5lY3Rpb24uY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PHtidWZmZXI6IEFycmF5QnVmZmVyLCBmZHM6IEFycmF5PFdlYkZEPn0+fXdpcmVNZXNzYWdlc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgY29ubmVjdGlvbi5vbkZsdXNoID0gYXN5bmMgKHdpcmVNZXNzYWdlcykgPT4ge1xuICAgIF9mbHVzaFF1ZXVlLnB1c2god2lyZU1lc3NhZ2VzKVxuXG4gICAgaWYgKF9mbHVzaFF1ZXVlLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHdoaWxlIChfZmx1c2hRdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHNlbmRXaXJlTWVzc2FnZXMgPSBfZmx1c2hRdWV1ZVswXVxuXG4gICAgICAvLyBjb252ZXJ0IHRvIHNpbmdsZSBhcnJheUJ1ZmZlciBzbyBpdCBjYW4gYmUgc2VuZCBvdmVyIGEgZGF0YSBjaGFubmVsIHVzaW5nIHplcm8gY29weSBzZW1hbnRpY3MuXG4gICAgICBjb25zdCBtZXNzYWdlc1NpemUgPSBzZW5kV2lyZU1lc3NhZ2VzLnJlZHVjZSgocHJldmlvdXNWYWx1ZSwgY3VycmVudFZhbHVlKSA9PiBwcmV2aW91c1ZhbHVlICsgY3VycmVudFZhbHVlLmJ1ZmZlci5ieXRlTGVuZ3RoLCAwKVxuXG4gICAgICBjb25zdCBzZW5kQnVmZmVyID0gbmV3IFVpbnQzMkFycmF5KG5ldyBBcnJheUJ1ZmZlcihtZXNzYWdlc1NpemUpKVxuICAgICAgbGV0IG9mZnNldCA9IDBcbiAgICAgIGNvbnN0IG1ldGEgPSBbXVxuICAgICAgZm9yIChjb25zdCB3aXJlTWVzc2FnZSBvZiBzZW5kV2lyZU1lc3NhZ2VzKSB7XG4gICAgICAgIGZvciAoY29uc3Qgd2ViRmQgb2Ygd2lyZU1lc3NhZ2UuZmRzKSB7XG4gICAgICAgICAgY29uc3QgdHJhbnNmZXJhYmxlID0gYXdhaXQgd2ViRmQuZ2V0VHJhbnNmZXJhYmxlKClcbiAgICAgICAgICBtZXRhLnB1c2godHJhbnNmZXJhYmxlKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgVWludDMyQXJyYXkod2lyZU1lc3NhZ2UuYnVmZmVyKVxuICAgICAgICBzZW5kQnVmZmVyLnNldChtZXNzYWdlLCBvZmZzZXQpXG4gICAgICAgIG9mZnNldCArPSBtZXNzYWdlLmxlbmd0aFxuICAgICAgfVxuXG4gICAgICBwb3N0TWVzc2FnZSh7IHByb3RvY29sTWVzc2FnZTogc2VuZEJ1ZmZlci5idWZmZXIsIG1ldGEgfSwgW3NlbmRCdWZmZXIuYnVmZmVyXS5jb25jYXQobWV0YSkpXG4gICAgICBfZmx1c2hRdWV1ZS5zaGlmdCgpXG4gICAgfVxuICB9XG59XG5cbl9zZXR1cE1lc3NhZ2VIYW5kbGluZyhkaXNwbGF5LCBjb25uZWN0aW9uLCB3ZWJGUylcblxuLyoqXG4gKiBAcGFyYW0ge1dsU3VyZmFjZVByb3h5fXdsU3VyZmFjZVByb3h5XG4gKiBAcmV0dXJuIHtmdW5jdGlvbigpOiBQcm9taXNlPG51bWJlcj59XG4gKi9cbmZ1bmN0aW9uIGZyYW1lICh3bFN1cmZhY2VQcm94eSkge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IHdsQ2FsbGJhY2tQcm94eSA9IHdsU3VyZmFjZVByb3h5LmZyYW1lKClcbiAgICAgIHdsQ2FsbGJhY2tQcm94eS5saXN0ZW5lciA9IHtcbiAgICAgICAgZG9uZTogKGRhdGEpID0+IHtcbiAgICAgICAgICByZXNvbHZlKGRhdGEpXG4gICAgICAgICAgd2xDYWxsYmFja1Byb3h5LmRlc3Ryb3koKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQge1xuICB3ZWJGUyxcbiAgZGlzcGxheSxcbiAgZnJhbWUsXG5cbiAgV2xEaXNwbGF5UHJveHksXG4gIFdsUmVnaXN0cnlQcm94eSxcbiAgV2xDYWxsYmFja1Byb3h5LFxuICBXbENvbXBvc2l0b3JQcm94eSxcbiAgV2xCdWZmZXJQcm94eSxcbiAgV2xEYXRhT2ZmZXJQcm94eSxcbiAgV2xEYXRhU291cmNlUHJveHksXG4gIFdsRGF0YURldmljZVByb3h5LFxuICBXbERhdGFEZXZpY2VNYW5hZ2VyUHJveHksXG4gIFdsU2hlbGxQcm94eSxcbiAgV2xTaGVsbFN1cmZhY2VQcm94eSxcbiAgV2xTdXJmYWNlUHJveHksXG4gIFdsU2VhdFByb3h5LFxuICBXbFBvaW50ZXJQcm94eSxcbiAgV2xLZXlib2FyZFByb3h5LFxuICBXbFRvdWNoUHJveHksXG4gIFdsT3V0cHV0UHJveHksXG4gIFdsUmVnaW9uUHJveHksXG4gIFdsU3ViY29tcG9zaXRvclByb3h5LFxuICBXbFN1YnN1cmZhY2VQcm94eSxcbiAgV2xEaXNwbGF5RXZlbnRzLFxuICBXbFJlZ2lzdHJ5RXZlbnRzLFxuICBXbENhbGxiYWNrRXZlbnRzLFxuICBXbEJ1ZmZlckV2ZW50cyxcbiAgV2xEYXRhT2ZmZXJFdmVudHMsXG4gIFdsRGF0YVNvdXJjZUV2ZW50cyxcbiAgV2xEYXRhRGV2aWNlRXZlbnRzLFxuICBXbFNoZWxsU3VyZmFjZUV2ZW50cyxcbiAgV2xTdXJmYWNlRXZlbnRzLFxuICBXbFNlYXRFdmVudHMsXG4gIFdsUG9pbnRlckV2ZW50cyxcbiAgV2xLZXlib2FyZEV2ZW50cyxcbiAgV2xUb3VjaEV2ZW50cyxcbiAgV2xPdXRwdXRFdmVudHMsXG5cbiAgWGRnV21CYXNlUHJveHksXG4gIFhkZ1Bvc2l0aW9uZXJQcm94eSxcbiAgWGRnU3VyZmFjZVByb3h5LFxuICBYZGdUb3BsZXZlbFByb3h5LFxuICBYZGdQb3B1cFByb3h5LFxuICBYZGdXbUJhc2VFdmVudHMsXG4gIFhkZ1N1cmZhY2VFdmVudHMsXG4gIFhkZ1RvcGxldmVsRXZlbnRzLFxuICBYZGdQb3B1cEV2ZW50cyxcblxuICBHcldlYlNobUJ1ZmZlclByb3h5LFxuICBHcldlYlNobVByb3h5LFxuICBHcldlYlNobUJ1ZmZlckV2ZW50cyxcblxuICBHcldlYkdsQnVmZmVyUHJveHksXG4gIEdyV2ViR2xQcm94eVxufSIsIi8qXG5NSVQgTGljZW5zZVxuXG5Db3B5cmlnaHQgKGMpIDIwMTcgRXJpayBEZSBSaWpja2VcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuU09GVFdBUkUuXG4qL1xuJ3VzZSBzdHJpY3QnXG5cbmltcG9ydCB7IENvbm5lY3Rpb24gfSBmcm9tICd3ZXN0ZmllbGQtcnVudGltZS1jb21tb24nXG5pbXBvcnQgV2xEaXNwbGF5UHJveHkgZnJvbSAnLi9wcm90b2NvbC9XbERpc3BsYXlQcm94eSdcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGlzcGxheSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb259Y29ubmVjdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IgKGNvbm5lY3Rpb24pIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8bnVtYmVyPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3JlY3ljbGVkSWRzID0gW11cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Q29ubmVjdGlvbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBjb25uZWN0aW9uXG4gICAgLyoqXG4gICAgICogQHR5cGUge1dsRGlzcGxheVByb3h5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZGlzcGxheVByb3h5ID0gbmV3IFdsRGlzcGxheVByb3h5KHRoaXMsIHRoaXMuX2Nvbm5lY3Rpb24sIDEpXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2xhc3RJZCA9IDFcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oKTp2b2lkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZGVzdHJveVJlc29sdmUgPSBudWxsXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKGVycm9yOkVycm9yKTp2b2lkfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZGVzdHJveVJlamVjdCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2Rlc3Ryb3lQcm9taXNlID0gbmV3IFByb21pc2UoKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX2Rlc3Ryb3lSZXNvbHZlID0gcmVzb2x2ZVxuICAgICAgdGhpcy5fZGVzdHJveVJlamVjdCA9IHJlamVjdFxuICAgIH0pKVxuXG4gICAgdGhpcy5fZGlzcGxheVByb3h5Lmxpc3RlbmVyID0ge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0gaWRcbiAgICAgICAqL1xuICAgICAgZGVsZXRlSWQ6IChpZCkgPT4geyB0aGlzLl9yZWN5Y2xlZElkcy5wdXNoKGlkKSB9LFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0gcHJveHlcbiAgICAgICAqIEBwYXJhbSBjb2RlXG4gICAgICAgKiBAcGFyYW0gbWVzc2FnZVxuICAgICAgICovXG4gICAgICBlcnJvcjogKHByb3h5LCBjb2RlLCBtZXNzYWdlKSA9PiB7IHRoaXMuX3Byb3RvY29sRXJyb3IocHJveHksIGNvZGUsIG1lc3NhZ2UpIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoaXMgdG8gaGF2ZSBhIGRlZmF1bHQgJ2NhdGNoLWFsbCcgYXBwbGljYXRpb24gZXJyb3IgaGFuZGxlci4gQ2FuIGJlIG51bGwgZm9yIGRlZmF1bHQgYmVoYXZpb3IuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbihlcnJvcik6dm9pZHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gbnVsbFxuICB9XG5cbiAgY2xvc2UgKCkge1xuICAgIGlmICh0aGlzLl9jb25uZWN0aW9uLmNsb3NlZCkgeyByZXR1cm4gfVxuICAgIHRoaXMuX2Nvbm5lY3Rpb24uY2xvc2UoKVxuICAgIHRoaXMuX2Rlc3Ryb3lSZXNvbHZlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1Byb3h5fXByb3h5XG4gICAqIEBwYXJhbSB7bnVtYmVyfWNvZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9bWVzc2FnZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb3RvY29sRXJyb3IgKHByb3h5LCBjb2RlLCBtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb24uY2xvc2VkKSB7IHJldHVybiB9XG4gICAgdGhpcy5fY29ubmVjdGlvbi5jbG9zZSgpXG4gICAgdGhpcy5fZGVzdHJveVJlamVjdChuZXcgRXJyb3IoYFByb3RvY29sIGVycm9yLiB0eXBlOiAke3Byb3h5LmNvbnN0cnVjdG9yLm5hbWV9LCBpZDogJHtwcm94eS5pZH0sIGNvZGU6ICR7Y29kZX0sIG1lc3NhZ2U6ICR7bWVzc2FnZX1gKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyBvbmNlIHRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZCBub3JtYWxseSBpZS4gd2l0aCBhIGNhbGwgdG8gY2xvc2UoKS4gVGhlIHByb21pc2Ugd2lsbCBiZSByZWplY3RlZCB3aXRoIGFuXG4gICAqIGVycm9yIGlmIHRoZSBjb25uZWN0aW9uIGlzIGNsb3NlZCBhYm5vcm1hbGx5IGllIHdoZW4gYSBwcm90b2NvbCBlcnJvciBpcyByZWNlaXZlZC5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIG9uQ2xvc2UgKCkge1xuICAgIHJldHVybiB0aGlzLl9kZXN0cm95UHJvbWlzZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1dsUmVnaXN0cnlQcm94eX1cbiAgICovXG4gIGdldFJlZ2lzdHJ5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlzcGxheVByb3h5LmdldFJlZ2lzdHJ5KClcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgaW50ZXJuYWwgdXNlLiBHZW5lcmF0ZXMgdGhlIGlkIG9mIHRoZSBuZXh0IHByb3h5IG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2VuZXJhdGVOZXh0SWQgKCkge1xuICAgIGlmICh0aGlzLl9yZWN5Y2xlZElkcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZWN5Y2xlZElkcy5zaGlmdCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiArK3RoaXMuX2xhc3RJZFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXYWl0IGZvciB0aGUgY29tcG9zaXRvciB0byBoYXZlIHNlbmQgdXMgYWxsIHJlbWFpbmluZyBldmVudHMuXG4gICAqXG4gICAqIFRoZSBkYXRhIGluIHRoZSByZXNvbHZlZCBwcm9taXNlIGlzIHRoZSBldmVudCBzZXJpYWwuXG4gICAqXG4gICAqIERvbid0ICdhd2FpdCcgdGhpcyBzeW5jIGNhbGwgYXMgaXQgd2lsbCByZXN1bHQgaW4gYSBkZWFkbG9jayB3aGVyZSB0aGUgd29ya2VyIHdpbGwgYmxvY2sgYWxsIGluY29taW5nIGV2ZW50cyxcbiAgICogaW5jbHVkaW5nIHRoZSBldmVudCB0aGUgcmVzb2x2ZXMgdGhlIGF3YWl0IHN0YXRlLiBJbnN0ZWFkIHVzZSB0aGUgY2xhc3NpYyAndGhlbiguLiknIGNvbnN0cnVjdC5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZTxudW1iZXI+fVxuICAgKi9cbiAgc3luYyAoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgY29uc3Qgd2xDYWxsYmFja1Byb3h5ID0gdGhpcy5fZGlzcGxheVByb3h5LnN5bmMoKVxuICAgICAgd2xDYWxsYmFja1Byb3h5Lmxpc3RlbmVyID0ge1xuICAgICAgICBkb25lOiAoZGF0YSkgPT4ge1xuICAgICAgICAgIHJlc29sdmUoZGF0YSlcbiAgICAgICAgICB3bENhbGxiYWNrUHJveHkuZGVzdHJveSgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgcXVldWVkIG1lc3NhZ2VzIHRvIHRoZSBjb21wb3NpdG9yLlxuICAgKi9cbiAgZmx1c2ggKCkge1xuICAgIHRoaXMuX2Nvbm5lY3Rpb24uZmx1c2goKVxuICB9XG59XG4iLCJpbXBvcnQgeyBXZWJGRCB9IGZyb20gJ3dlc3RmaWVsZC1ydW50aW1lLWNvbW1vbidcblxuLy8gVE9ETyBUaGlzIGlzIGN1cnJlbnRseSBhIGxpdGVyYWwgY29weSBvZiB0aGUgc2VydmVyIGltcGxlbWVudGF0aW9uLiBEbyBhbGwgdXNlIGNhc2VzIG1hdGNoIDFvMSBhbmQgY2FuIHdlIHVzZSBhIHNpbmdsZSBjb21tb24gY29kZSBiYXNlIGJldHdlZW4gY2xpZW50ICYgc2VydmVyIGZvciBXZWJGUz9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdlYkZTIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfWZkRG9tYWluVVVJRFxuICAgKiBAcmV0dXJuIHtXZWJGU31cbiAgICovXG4gIHN0YXRpYyBjcmVhdGUgKGZkRG9tYWluVVVJRCkge1xuICAgIHJldHVybiBuZXcgV2ViRlMoZmREb21haW5VVUlEKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfWZkRG9tYWluVVVJRFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGZkRG9tYWluVVVJRCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9mZERvbWFpblVVSUQgPSBmZERvbWFpblVVSURcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxudW1iZXIsV2ViRkQ+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fd2ViRkRzID0ge31cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbmV4dEZEID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyXG4gICAqIEByZXR1cm4ge1dlYkZEfVxuICAgKi9cbiAgZnJvbUFycmF5QnVmZmVyIChhcnJheUJ1ZmZlcikge1xuICAgIGlmICghKGFycmF5QnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBmaXJzdCBhcmd1bWVudCB0byBiZSBvZiB0eXBlIEFycmF5QnVmZmVyLmApXG4gICAgfVxuICAgIGNvbnN0IGZkID0gdGhpcy5fbmV4dEZEKytcbiAgICBjb25zdCB3ZWJGRCA9IG5ldyBXZWJGRChmZCwgJ0FycmF5QnVmZmVyJywgdGhpcy5fZmREb21haW5VVUlELCAoKSA9PiBQcm9taXNlLnJlc29sdmUoYXJyYXlCdWZmZXIpLCAoKSA9PiB7IGRlbGV0ZSB0aGlzLl93ZWJGRHNbZmRdIH0pXG4gICAgdGhpcy5fd2ViRkRzW2ZkXSA9IHdlYkZEXG4gICAgcmV0dXJuIHdlYkZEXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtJbWFnZUJpdG1hcH1pbWFnZUJpdG1hcFxuICAgKiBAcmV0dXJuIHtXZWJGRH1cbiAgICovXG4gIGZyb21JbWFnZUJpdG1hcCAoaW1hZ2VCaXRtYXApIHtcbiAgICBpZiAoIShpbWFnZUJpdG1hcCBpbnN0YW5jZW9mIEltYWdlQml0bWFwKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgb2YgdHlwZSBJbWFnZUJpdG1hcC5gKVxuICAgIH1cbiAgICBjb25zdCBmZCA9IHRoaXMuX25leHRGRCsrXG4gICAgY29uc3Qgd2ViRkQgPSBuZXcgV2ViRkQoZmQsICdJbWFnZUJpdG1hcCcsIHRoaXMuX2ZkRG9tYWluVVVJRCwgKCkgPT4gUHJvbWlzZS5yZXNvbHZlKGltYWdlQml0bWFwKSwgKCkgPT4geyBkZWxldGUgdGhpcy5fd2ViRkRzW2ZkXSB9KVxuICAgIHRoaXMuX3dlYkZEc1tmZF0gPSB3ZWJGRFxuICAgIHJldHVybiB3ZWJGRFxuICB9XG5cbiAgLy8gVE9ETyBmcm9tTWVzc2FnZVBvcnRcblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9ZmRcbiAgICogQHJldHVybiB7V2ViRkR9XG4gICAqL1xuICBnZXRXZWJGRCAoZmQpIHtcbiAgICByZXR1cm4gdGhpcy5fd2ViRkRzW2ZkXVxuICB9XG59XG4iLCIvKlxuICpcbiAqICAgICAgICBDb3B5cmlnaHQgwqkgMjAxOSBFcmlrIERlIFJpamNrZVxuICpcbiAqICAgICAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogICAgICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gKiAgICAgICAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICogICAgICAgIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gKiAgICAgICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqICAgICAgICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogICAgICAgIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqICAgICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSAoaW5jbHVkaW5nIHRoZVxuICogICAgICAgIG5leHQgcGFyYWdyYXBoKSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsXG4gKiAgICAgICAgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqICAgICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogICAgICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogICAgICAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiAgICAgICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICogICAgICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICogICAgICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gKiAgICAgICAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogICAgICAgIFNPRlRXQVJFLlxuICogICAgXG4gKi9cblxuaW1wb3J0IHsgQ29ubmVjdGlvbiB9IGZyb20gJ3dlc3RmaWVsZC1ydW50aW1lLWNvbW1vbidcbmNvbnN0IHsgdWludCwgdWludE9wdGlvbmFsLCBpbnQsIGludE9wdGlvbmFsLCBmaXhlZCwgXG5cdGZpeGVkT3B0aW9uYWwsIG9iamVjdCwgb2JqZWN0T3B0aW9uYWwsIG5ld09iamVjdCwgc3RyaW5nLCBcblx0c3RyaW5nT3B0aW9uYWwsIGFycmF5LCBhcnJheU9wdGlvbmFsLCBcblx0ZmlsZURlc2NyaXB0b3JPcHRpb25hbCwgZmlsZURlc2NyaXB0b3IsIFxuaCwgdSwgaSwgZiwgbywgbiwgcywgYSB9ID0gQ29ubmVjdGlvblxuaW1wb3J0IFByb3h5IGZyb20gJy4vUHJveHknXG5jbGFzcyBHcldlYkdsQnVmZmVyUHJveHkgZXh0ZW5kcyBQcm94eSB7XG5cblx0LyoqXG5cdCAqXG5cdCAqICAgICAgICAgICAgICAgIFRyYW5zZmVyIHRoZSBhc3NvY2lhdGVkIEhUTUw1IHdlYiBnbCBidWZmZXIgY29udGVudHMgdG8gdGhlIGNvbXBvc2l0b3IuXG5cdCAqICAgICAgICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7V2ViRkR9IGNvbnRlbnRzIEhUTUw1IHdlYiBnbCBpbWFnZSBiaXRtYXAgdG8gdHJhbnNmZXIgdG8gdGhlIGNvbXBvc2l0b3IuIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0dHJhbnNmZXIgKGNvbnRlbnRzKSB7XG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgMCwgW2ZpbGVEZXNjcmlwdG9yKGNvbnRlbnRzKV0pXG5cdH1cblxuXHQvKipcblx0ICogRG8gbm90IGNvbnN0cnVjdCBwcm94aWVzIGRpcmVjdGx5LiBJbnN0ZWFkIHVzZSBvbmUgb2YgdGhlIGZhY3RvcnkgbWV0aG9kcyBmcm9tIG90aGVyIHByb3hpZXMuXG5cdCAqQHBhcmFtIHtEaXNwbGF5fWRpc3BsYXlcblx0ICpAcGFyYW0ge0Nvbm5lY3Rpb259Y29ubmVjdGlvblxuXHQgKkBwYXJhbSB7bnVtYmVyfWlkXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciAoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpIHtcblx0XHRzdXBlcihkaXNwbGF5LCBjb25uZWN0aW9uLCBpZClcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7R3JXZWJHbEJ1ZmZlckV2ZW50c3xudWxsfVxuXHRcdCAqL1xuXHRcdHRoaXMubGlzdGVuZXIgPSBudWxsXG5cdH1cblxufVxuR3JXZWJHbEJ1ZmZlclByb3h5LnByb3RvY29sTmFtZSA9ICdncl93ZWJfZ2xfYnVmZmVyJ1xuXG5leHBvcnQgZGVmYXVsdCBHcldlYkdsQnVmZmVyUHJveHlcbiIsIi8qXG4gKlxuICogICAgICAgIENvcHlyaWdodCDCqSAyMDE5IEVyaWsgRGUgUmlqY2tlXG4gKlxuICogICAgICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiAgICAgICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAqICAgICAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiAgICAgICAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAqICAgICAgICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICogICAgICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiAgICAgICAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogICAgICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIChpbmNsdWRpbmcgdGhlXG4gKiAgICAgICAgbmV4dCBwYXJhZ3JhcGgpIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWxcbiAqICAgICAgICBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogICAgICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiAgICAgICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiAgICAgICAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqICAgICAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gKiAgICAgICAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gKiAgICAgICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAqICAgICAgICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiAgICAgICAgU09GVFdBUkUuXG4gKiAgICBcbiAqL1xuXG5pbXBvcnQgeyBDb25uZWN0aW9uIH0gZnJvbSAnd2VzdGZpZWxkLXJ1bnRpbWUtY29tbW9uJ1xuY29uc3QgeyB1aW50LCB1aW50T3B0aW9uYWwsIGludCwgaW50T3B0aW9uYWwsIGZpeGVkLCBcblx0Zml4ZWRPcHRpb25hbCwgb2JqZWN0LCBvYmplY3RPcHRpb25hbCwgbmV3T2JqZWN0LCBzdHJpbmcsIFxuXHRzdHJpbmdPcHRpb25hbCwgYXJyYXksIGFycmF5T3B0aW9uYWwsIFxuXHRmaWxlRGVzY3JpcHRvck9wdGlvbmFsLCBmaWxlRGVzY3JpcHRvciwgXG5oLCB1LCBpLCBmLCBvLCBuLCBzLCBhIH0gPSBDb25uZWN0aW9uXG5pbXBvcnQgUHJveHkgZnJvbSAnLi9Qcm94eSdcbmltcG9ydCBHcldlYkdsQnVmZmVyUHJveHkgZnJvbSAnLi9HcldlYkdsQnVmZmVyUHJveHknXG5pbXBvcnQgV2xCdWZmZXJQcm94eSBmcm9tICcuL1dsQnVmZmVyUHJveHknXG5cbi8qKlxuICpcbiAqICAgICAgICAgICAgQSBzaW5nbGV0b24gZ2xvYmFsIG9iamVjdCB0aGF0IHByb3ZpZGVzIHN1cHBvcnQgZm9yIHdlYiBnbC5cbiAqXG4gKiAgICAgICAgICAgIENsaWVudHMgY2FuIGNyZWF0ZSB3bF9idWZmZXIgb2JqZWN0cyB1c2luZyB0aGUgY3JlYXRlX2J1ZmZlciByZXF1ZXN0LlxuICogICAgICAgIFxuICovXG5jbGFzcyBHcldlYkdsUHJveHkgZXh0ZW5kcyBQcm94eSB7XG5cblx0LyoqXG5cdCAqXG5cdCAqICAgICAgICAgICAgICAgIENyZWF0ZSBhIHdlYl9nbF9idWZmZXIgb2JqZWN0LlxuXHQgKiAgICAgICAgICAgIFxuXHQgKlxuXHQgKiBAcmV0dXJuIHtHcldlYkdsQnVmZmVyUHJveHl9IFRoZSBncl93ZWJfZ2wgYnVmZmVyIHRvIGNyZWF0ZS4gXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRjcmVhdGVXZWJHbEJ1ZmZlciAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hcnNoYWxsQ29uc3RydWN0b3IodGhpcy5pZCwgMCwgR3JXZWJHbEJ1ZmZlclByb3h5LCBbbmV3T2JqZWN0KCldKVxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqICAgICAgICAgICAgICAgIENyZWF0ZSBhIHdsX2J1ZmZlciBvYmplY3QgZnJvbSBhIHdlYl9hcnJheV9idWZmZXIgc28gaXQgY2FuIGJlIHVzZWQgd2l0aCBhIHN1cmZhY2UuXG5cdCAqICAgICAgICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7Kn0gZ3JXZWJHbEJ1ZmZlciBUaGUgZ3Jfd2ViX2dsX2J1ZmZlciB0byB3cmFwLiBcblx0ICogQHJldHVybiB7V2xCdWZmZXJQcm94eX0gVGhlIGJ1ZmZlciB0byBjcmVhdGUuIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0Y3JlYXRlQnVmZmVyIChncldlYkdsQnVmZmVyKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hcnNoYWxsQ29uc3RydWN0b3IodGhpcy5pZCwgMSwgV2xCdWZmZXJQcm94eSwgW25ld09iamVjdCgpLCBvYmplY3QoZ3JXZWJHbEJ1ZmZlcildKVxuXHR9XG5cblx0LyoqXG5cdCAqIERvIG5vdCBjb25zdHJ1Y3QgcHJveGllcyBkaXJlY3RseS4gSW5zdGVhZCB1c2Ugb25lIG9mIHRoZSBmYWN0b3J5IG1ldGhvZHMgZnJvbSBvdGhlciBwcm94aWVzLlxuXHQgKkBwYXJhbSB7RGlzcGxheX1kaXNwbGF5XG5cdCAqQHBhcmFtIHtDb25uZWN0aW9ufWNvbm5lY3Rpb25cblx0ICpAcGFyYW0ge251bWJlcn1pZFxuXHQgKi9cblx0Y29uc3RydWN0b3IgKGRpc3BsYXksIGNvbm5lY3Rpb24sIGlkKSB7XG5cdFx0c3VwZXIoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge0dyV2ViR2xFdmVudHN8bnVsbH1cblx0XHQgKi9cblx0XHR0aGlzLmxpc3RlbmVyID0gbnVsbFxuXHR9XG5cbn1cbkdyV2ViR2xQcm94eS5wcm90b2NvbE5hbWUgPSAnZ3Jfd2ViX2dsJ1xuXG5leHBvcnQgZGVmYXVsdCBHcldlYkdsUHJveHlcbiIsIi8qXG4gKlxuICogICAgICAgIENvcHlyaWdodCDCqSAyMDE5IEVyaWsgRGUgUmlqY2tlXG4gKlxuICogICAgICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiAgICAgICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAqICAgICAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiAgICAgICAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAqICAgICAgICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICogICAgICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiAgICAgICAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogICAgICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIChpbmNsdWRpbmcgdGhlXG4gKiAgICAgICAgbmV4dCBwYXJhZ3JhcGgpIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWxcbiAqICAgICAgICBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogICAgICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiAgICAgICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiAgICAgICAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqICAgICAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gKiAgICAgICAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gKiAgICAgICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAqICAgICAgICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiAgICAgICAgU09GVFdBUkUuXG4gKiAgICBcbiAqL1xuXG4vKipcbiAqIEBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JXZWJTaG1CdWZmZXJFdmVudHMge1xuXG5cdC8qKlxuXHQgKlxuXHQgKiAgICAgICAgICAgICAgICBEZXRhY2hlcyBhIHByZXZpb3VzbHkgYXR0YWNoZWQgSFRNTDUgYXJyYXkgYnVmZmVyIGZyb20gdGhlIGNvbXBvc2l0b3IgYW5kIHJldHVybnMgaXQgdG8gdGhlIGNsaWVudCBzb1xuXHQgKiAgICAgICAgICAgICAgICBpdCBjYW4gYmUgcmV1c2VkIGFnYWluIGZvciB3cml0aW5nLiBBZnRlciBkZXRhY2hpbmcsIHRoZSBhcnJheSBidWZmZXIgb3duZXJzaGlwIGlzIHBhc3NlZCBmcm9tXG5cdCAqICAgICAgICAgICAgICAgIHRoZSBjb21wb3NpdG9yIG1haW4gdGhyZWFkIGJhY2sgdG8gdGhlIGNsaWVudC5cblx0ICogICAgICAgICAgICBcblx0ICpcblx0ICogQHBhcmFtIHtXZWJGRH0gY29udGVudHMgQW4gSFRNTDUgYXJyYXkgYnVmZmVyLCBkZXRhY2hlZCBmcm9tIHRoZSBjb21wb3NpdG9yIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0ZGV0YWNoKGNvbnRlbnRzKSB7fVxufVxuXG4iLCIvKlxuICpcbiAqICAgICAgICBDb3B5cmlnaHQgwqkgMjAxOSBFcmlrIERlIFJpamNrZVxuICpcbiAqICAgICAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogICAgICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gKiAgICAgICAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICogICAgICAgIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gKiAgICAgICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqICAgICAgICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogICAgICAgIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqICAgICAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSAoaW5jbHVkaW5nIHRoZVxuICogICAgICAgIG5leHQgcGFyYWdyYXBoKSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsXG4gKiAgICAgICAgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqICAgICAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogICAgICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogICAgICAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiAgICAgICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICogICAgICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICogICAgICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gKiAgICAgICAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogICAgICAgIFNPRlRXQVJFLlxuICogICAgXG4gKi9cblxuaW1wb3J0IHsgQ29ubmVjdGlvbiB9IGZyb20gJ3dlc3RmaWVsZC1ydW50aW1lLWNvbW1vbidcbmNvbnN0IHsgdWludCwgdWludE9wdGlvbmFsLCBpbnQsIGludE9wdGlvbmFsLCBmaXhlZCwgXG5cdGZpeGVkT3B0aW9uYWwsIG9iamVjdCwgb2JqZWN0T3B0aW9uYWwsIG5ld09iamVjdCwgc3RyaW5nLCBcblx0c3RyaW5nT3B0aW9uYWwsIGFycmF5LCBhcnJheU9wdGlvbmFsLCBcblx0ZmlsZURlc2NyaXB0b3JPcHRpb25hbCwgZmlsZURlc2NyaXB0b3IsIFxuaCwgdSwgaSwgZiwgbywgbiwgcywgYSB9ID0gQ29ubmVjdGlvblxuaW1wb3J0IFByb3h5IGZyb20gJy4vUHJveHknXG5jbGFzcyBHcldlYlNobUJ1ZmZlclByb3h5IGV4dGVuZHMgUHJveHkge1xuXG5cdC8qKlxuXHQgKlxuXHQgKiAgICAgICAgICAgICAgICBBdHRhY2hlcyBhbiBIVE1MNSBhcnJheSBidWZmZXIgdG8gdGhlIGNvbXBvc2l0b3IuIEFmdGVyIGF0dGFjaGluZywgdGhlIGFycmF5IGJ1ZmZlciBvd25lcnNoaXAgaXMgcGFzc2VkXG5cdCAqICAgICAgICAgICAgICAgIHRvIHRoZSBjb21wb3NpdG9yIG1haW4gdGhyZWFkLiBUaGUgYXJyYXkgYnVmZmVyIGNhbiBub3QgYmUgdXNlZCBmb3Igd3JpdGluZyBhbnltb3JlIGJ5IHRoZSBjbGllbnQgYXNcblx0ICogICAgICAgICAgICAgICAgcGVyIEhUTUw1IFRyYW5zZmVyYWJsZSBvYmplY3RzIHNwZWMuXG5cdCAqXG5cdCAqICAgICAgICAgICAgICAgIFRoZSBwaXhlbCBmb3JtYXQgb2YgdGhlIGF0dGFjaGVkIGFycmF5IGJ1ZmZlciBtdXN0IGFsd2F5cyBiZSBSR0JBODg4OCBhcyBwZXIgSFRNTDUgSW1hZ2VEYXRhIHNwZWMuXG5cdCAqICAgICAgICAgICAgICAgIFN0cmlkZSBtdXN0IGFsd2F5cyBlcXVhbCB3aWR0aC5cblx0ICogICAgICAgICAgICBcblx0ICpcblx0ICogQHBhcmFtIHtXZWJGRH0gY29udGVudHMgQW4gSFRNTDUgYXJyYXkgYnVmZmVyIHRvIGF0dGFjaCB0byB0aGUgY29tcG9zaXRvci4gXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRhdHRhY2ggKGNvbnRlbnRzKSB7XG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgMCwgW2ZpbGVEZXNjcmlwdG9yKGNvbnRlbnRzKV0pXG5cdH1cblxuXHQvKipcblx0ICogRG8gbm90IGNvbnN0cnVjdCBwcm94aWVzIGRpcmVjdGx5LiBJbnN0ZWFkIHVzZSBvbmUgb2YgdGhlIGZhY3RvcnkgbWV0aG9kcyBmcm9tIG90aGVyIHByb3hpZXMuXG5cdCAqQHBhcmFtIHtEaXNwbGF5fWRpc3BsYXlcblx0ICpAcGFyYW0ge0Nvbm5lY3Rpb259Y29ubmVjdGlvblxuXHQgKkBwYXJhbSB7bnVtYmVyfWlkXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciAoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpIHtcblx0XHRzdXBlcihkaXNwbGF5LCBjb25uZWN0aW9uLCBpZClcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7R3JXZWJTaG1CdWZmZXJFdmVudHN8bnVsbH1cblx0XHQgKi9cblx0XHR0aGlzLmxpc3RlbmVyID0gbnVsbFxuXHR9XG5cblx0YXN5bmMgWzBdIChtZXNzYWdlKSB7XG5cdFx0YXdhaXQgdGhpcy5saXN0ZW5lci5kZXRhY2goaChtZXNzYWdlKSlcblx0fVxuXG59XG5HcldlYlNobUJ1ZmZlclByb3h5LnByb3RvY29sTmFtZSA9ICdncl93ZWJfc2htX2J1ZmZlcidcblxuZXhwb3J0IGRlZmF1bHQgR3JXZWJTaG1CdWZmZXJQcm94eVxuIiwiLypcbiAqXG4gKiAgICAgICAgQ29weXJpZ2h0IMKpIDIwMTkgRXJpayBEZSBSaWpja2VcbiAqXG4gKiAgICAgICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqICAgICAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICogICAgICAgICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAqICAgICAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogICAgICAgIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gKiAgICAgICAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAqICAgICAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiAgICAgICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgKGluY2x1ZGluZyB0aGVcbiAqICAgICAgICBuZXh0IHBhcmFncmFwaCkgc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbFxuICogICAgICAgIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiAgICAgICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqICAgICAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAqICAgICAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogICAgICAgIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAqICAgICAgICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAqICAgICAgICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICogICAgICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqICAgICAgICBTT0ZUV0FSRS5cbiAqICAgIFxuICovXG5cbmltcG9ydCB7IENvbm5lY3Rpb24gfSBmcm9tICd3ZXN0ZmllbGQtcnVudGltZS1jb21tb24nXG5jb25zdCB7IHVpbnQsIHVpbnRPcHRpb25hbCwgaW50LCBpbnRPcHRpb25hbCwgZml4ZWQsIFxuXHRmaXhlZE9wdGlvbmFsLCBvYmplY3QsIG9iamVjdE9wdGlvbmFsLCBuZXdPYmplY3QsIHN0cmluZywgXG5cdHN0cmluZ09wdGlvbmFsLCBhcnJheSwgYXJyYXlPcHRpb25hbCwgXG5cdGZpbGVEZXNjcmlwdG9yT3B0aW9uYWwsIGZpbGVEZXNjcmlwdG9yLCBcbmgsIHUsIGksIGYsIG8sIG4sIHMsIGEgfSA9IENvbm5lY3Rpb25cbmltcG9ydCBQcm94eSBmcm9tICcuL1Byb3h5J1xuaW1wb3J0IEdyV2ViU2htQnVmZmVyUHJveHkgZnJvbSAnLi9HcldlYlNobUJ1ZmZlclByb3h5J1xuaW1wb3J0IFdsQnVmZmVyUHJveHkgZnJvbSAnLi9XbEJ1ZmZlclByb3h5J1xuXG4vKipcbiAqXG4gKiAgICAgICAgICAgIEEgc2luZ2xldG9uIGdsb2JhbCBvYmplY3QgdGhhdCBwcm92aWRlcyBzdXBwb3J0IGZvciBzaGFyZWQgbWVtb3J5IHRocm91Z2ggSFRNTDUgYXJyYXkgYnVmZmVycy5cbiAqXG4gKiAgICAgICAgICAgIENsaWVudHMgY2FuIGNyZWF0ZSB3bF9idWZmZXIgb2JqZWN0cyB1c2luZyB0aGUgY3JlYXRlX2J1ZmZlciByZXF1ZXN0LlxuICogICAgICAgIFxuICovXG5jbGFzcyBHcldlYlNobVByb3h5IGV4dGVuZHMgUHJveHkge1xuXG5cdC8qKlxuXHQgKlxuXHQgKiAgICAgICAgICAgICAgICBDcmVhdGUgYSBncl93ZWJfc2htX2J1ZmZlciBvYmplY3QuXG5cdCAqICAgICAgICAgICAgXG5cdCAqXG5cdCAqIEByZXR1cm4ge0dyV2ViU2htQnVmZmVyUHJveHl9IHdlYiBzaG0gYnVmZmVyIHRvIGNyZWF0ZSBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdGNyZWF0ZVdlYkFycmF5QnVmZmVyICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFyc2hhbGxDb25zdHJ1Y3Rvcih0aGlzLmlkLCAwLCBHcldlYlNobUJ1ZmZlclByb3h5LCBbbmV3T2JqZWN0KCldKVxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqICAgICAgICAgICAgICAgIENyZWF0ZSBhIHdsX2J1ZmZlciBvYmplY3QgZnJvbSBhIHdlYl9hcnJheV9idWZmZXIgc28gaXQgY2FuIGJlIHVzZWQgd2l0aCBhIHN1cmZhY2UuXG5cdCAqICAgICAgICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7Kn0gd2ViQXJyYXlCdWZmZXIgVGhlIGdyX3dlYl9hcnJheV9idWZmZXIgdG8gd3JhcCBcblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIEJ1ZmZlciB3aWR0aCwgaW4gcGl4ZWxzLiBcblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBCdWZmZXIgaGVpZ2h0LCBpbiBwaXhlbHMuIFxuXHQgKiBAcmV0dXJuIHtXbEJ1ZmZlclByb3h5fSBidWZmZXIgdG8gY3JlYXRlIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0Y3JlYXRlQnVmZmVyICh3ZWJBcnJheUJ1ZmZlciwgd2lkdGgsIGhlaWdodCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXJzaGFsbENvbnN0cnVjdG9yKHRoaXMuaWQsIDEsIFdsQnVmZmVyUHJveHksIFtuZXdPYmplY3QoKSwgb2JqZWN0KHdlYkFycmF5QnVmZmVyKSwgaW50KHdpZHRoKSwgaW50KGhlaWdodCldKVxuXHR9XG5cblx0LyoqXG5cdCAqIERvIG5vdCBjb25zdHJ1Y3QgcHJveGllcyBkaXJlY3RseS4gSW5zdGVhZCB1c2Ugb25lIG9mIHRoZSBmYWN0b3J5IG1ldGhvZHMgZnJvbSBvdGhlciBwcm94aWVzLlxuXHQgKkBwYXJhbSB7RGlzcGxheX1kaXNwbGF5XG5cdCAqQHBhcmFtIHtDb25uZWN0aW9ufWNvbm5lY3Rpb25cblx0ICpAcGFyYW0ge251bWJlcn1pZFxuXHQgKi9cblx0Y29uc3RydWN0b3IgKGRpc3BsYXksIGNvbm5lY3Rpb24sIGlkKSB7XG5cdFx0c3VwZXIoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge0dyV2ViU2htRXZlbnRzfG51bGx9XG5cdFx0ICovXG5cdFx0dGhpcy5saXN0ZW5lciA9IG51bGxcblx0fVxuXG59XG5HcldlYlNobVByb3h5LnByb3RvY29sTmFtZSA9ICdncl93ZWJfc2htJ1xuXG5leHBvcnQgZGVmYXVsdCBHcldlYlNobVByb3h5XG4iLCIvKlxuTUlUIExpY2Vuc2VcblxuQ29weXJpZ2h0IChjKSAyMDE3IEVyaWsgRGUgUmlqY2tlXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbmNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcblNPRlRXQVJFLlxuKi9cbid1c2Ugc3RyaWN0J1xuXG5pbXBvcnQgeyBXbE9iamVjdCB9IGZyb20gJ3dlc3RmaWVsZC1ydW50aW1lLWNvbW1vbidcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUHJveHkgZXh0ZW5kcyBXbE9iamVjdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Rpc3BsYXl9IGRpc3BsYXlcbiAgICogQHBhcmFtIHtDb25uZWN0aW9ufWNvbm5lY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9aWRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkaXNwbGF5LCBjb25uZWN0aW9uLCBpZCkge1xuICAgIHN1cGVyKGlkKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtEaXNwbGF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kaXNwbGF5ID0gZGlzcGxheVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtDb25uZWN0aW9ufVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICB0aGlzLl9jb25uZWN0aW9uID0gY29ubmVjdGlvblxuICAgIGNvbm5lY3Rpb24ucmVnaXN0ZXJXbE9iamVjdCh0aGlzKVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpXG4gICAgdGhpcy5fY29ubmVjdGlvbi51bnJlZ2lzdGVyV2xPYmplY3QodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpZFxuICAgKiBAcGFyYW0ge251bWJlcn0gb3Bjb2RlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByb3h5Q2xhc3NcbiAgICogQHBhcmFtIHtBcnJheTx7dmFsdWU6ICosIHR5cGU6IHN0cmluZywgc2l6ZTogbnVtYmVyLCBvcHRpb25hbDogYm9vbGVhbiwgX21hcnNoYWxsQXJnOiBmdW5jdGlvbih7YnVmZmVyOiBBcnJheUJ1ZmZlciwgZmRzOiBBcnJheTxXZWJGRD4sIGJ1ZmZlck9mZnNldDogbnVtYmVyfSk6dm9pZH0+fSBhcmdzQXJyYXlcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX21hcnNoYWxsQ29uc3RydWN0b3IgKGlkLCBvcGNvZGUsIHByb3h5Q2xhc3MsIGFyZ3NBcnJheSkge1xuICAgIC8vIGNvbnN0cnVjdCBuZXcgb2JqZWN0XG4gICAgY29uc3QgcHJveHkgPSBuZXcgcHJveHlDbGFzcyh0aGlzLmRpc3BsYXksIHRoaXMuX2Nvbm5lY3Rpb24sIHRoaXMuZGlzcGxheS5nZW5lcmF0ZU5leHRJZCgpKVxuXG4gICAgLy8gZGV0ZXJtaW5lIHJlcXVpcmVkIHdpcmUgbWVzc2FnZSBsZW5ndGhcbiAgICBsZXQgc2l6ZSA9IDQgKyAyICsgMiAvLyBpZCtzaXplK29wY29kZVxuICAgIGFyZ3NBcnJheS5mb3JFYWNoKGFyZyA9PiB7XG4gICAgICBpZiAoYXJnLnR5cGUgPT09ICduJykge1xuICAgICAgICBhcmcudmFsdWUgPSBwcm94eS5pZFxuICAgICAgfVxuICAgICAgc2l6ZSArPSBhcmcuc2l6ZVxuICAgIH0pXG5cbiAgICB0aGlzLl9jb25uZWN0aW9uLm1hcnNoYWxsTXNnKGlkLCBvcGNvZGUsIHNpemUsIGFyZ3NBcnJheSlcblxuICAgIHJldHVybiBwcm94eVxuICB9XG5cbiAgLyoqXG4gICAqIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGlkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcGNvZGVcbiAgICogQHBhcmFtIHtBcnJheTx7dmFsdWU6ICosIHR5cGU6IHN0cmluZywgc2l6ZTogbnVtYmVyLCBvcHRpb25hbDogYm9vbGVhbiwgX21hcnNoYWxsQXJnOiBmdW5jdGlvbih7YnVmZmVyOiBBcnJheUJ1ZmZlciwgZmRzOiBBcnJheTxXZWJGRD4sIGJ1ZmZlck9mZnNldDogbnVtYmVyfSk6dm9pZH0+fSBhcmdzQXJyYXlcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX21hcnNoYWxsIChpZCwgb3Bjb2RlLCBhcmdzQXJyYXkpIHtcbiAgICAvLyBkZXRlcm1pbmUgcmVxdWlyZWQgd2lyZSBtZXNzYWdlIGxlbmd0aFxuICAgIGxldCBzaXplID0gNCArIDIgKyAyICAvLyBpZCtzaXplK29wY29kZVxuICAgIGFyZ3NBcnJheS5mb3JFYWNoKGFyZyA9PiBzaXplICs9IGFyZy5zaXplKVxuICAgIHRoaXMuX2Nvbm5lY3Rpb24ubWFyc2hhbGxNc2coaWQsIG9wY29kZSwgc2l6ZSwgYXJnc0FycmF5KVxuICB9XG59XG5cblxuIiwiLypcbiAqXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAwOC0yMDExIEtyaXN0aWFuIEjDuGdzYmVyZ1xuICogICAgQ29weXJpZ2h0IMKpIDIwMTAtMjAxMSBJbnRlbCBDb3Jwb3JhdGlvblxuICogICAgQ29weXJpZ2h0IMKpIDIwMTItMjAxMyBDb2xsYWJvcmEsIEx0ZC5cbiAqXG4gKiAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAqICAgICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAqICAgIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gKiAgICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICogICAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAqICAgIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIChpbmNsdWRpbmcgdGhlXG4gKiAgICBuZXh0IHBhcmFncmFwaCkgc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbFxuICogICAgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAqICAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiAgICBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICogICAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gKiAgICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICogICAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogICAgU09GVFdBUkUuXG4gKiAgXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJmYWNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdsQnVmZmVyRXZlbnRzIHtcblxuXHQvKipcblx0ICpcblx0ICpcdFNlbnQgd2hlbiB0aGlzIHdsX2J1ZmZlciBpcyBubyBsb25nZXIgdXNlZCBieSB0aGUgY29tcG9zaXRvci5cblx0ICpcdFRoZSBjbGllbnQgaXMgbm93IGZyZWUgdG8gcmV1c2Ugb3IgZGVzdHJveSB0aGlzIGJ1ZmZlciBhbmQgaXRzXG5cdCAqXHRiYWNraW5nIHN0b3JhZ2UuXG5cdCAqXG5cdCAqXHRJZiBhIGNsaWVudCByZWNlaXZlcyBhIHJlbGVhc2UgZXZlbnQgYmVmb3JlIHRoZSBmcmFtZSBjYWxsYmFja1xuXHQgKlx0cmVxdWVzdGVkIGluIHRoZSBzYW1lIHdsX3N1cmZhY2UuY29tbWl0IHRoYXQgYXR0YWNoZXMgdGhpc1xuXHQgKlx0d2xfYnVmZmVyIHRvIGEgc3VyZmFjZSwgdGhlbiB0aGUgY2xpZW50IGlzIGltbWVkaWF0ZWx5IGZyZWUgdG9cblx0ICpcdHJldXNlIHRoZSBidWZmZXIgYW5kIGl0cyBiYWNraW5nIHN0b3JhZ2UsIGFuZCBkb2VzIG5vdCBuZWVkIGFcblx0ICpcdHNlY29uZCBidWZmZXIgZm9yIHRoZSBuZXh0IHN1cmZhY2UgY29udGVudCB1cGRhdGUuIFR5cGljYWxseVxuXHQgKlx0dGhpcyBpcyBwb3NzaWJsZSwgd2hlbiB0aGUgY29tcG9zaXRvciBtYWludGFpbnMgYSBjb3B5IG9mIHRoZVxuXHQgKlx0d2xfc3VyZmFjZSBjb250ZW50cywgZS5nLiBhcyBhIEdMIHRleHR1cmUuIFRoaXMgaXMgYW4gaW1wb3J0YW50XG5cdCAqXHRvcHRpbWl6YXRpb24gZm9yIEdMKEVTKSBjb21wb3NpdG9ycyB3aXRoIHdsX3NobSBjbGllbnRzLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0cmVsZWFzZSgpIHt9XG59XG5cbiIsIi8qXG4gKlxuICogICAgQ29weXJpZ2h0IMKpIDIwMDgtMjAxMSBLcmlzdGlhbiBIw7hnc2JlcmdcbiAqICAgIENvcHlyaWdodCDCqSAyMDEwLTIwMTEgSW50ZWwgQ29ycG9yYXRpb25cbiAqICAgIENvcHlyaWdodCDCqSAyMDEyLTIwMTMgQ29sbGFib3JhLCBMdGQuXG4gKlxuICogICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gKiAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSAoaW5jbHVkaW5nIHRoZVxuICogICAgbmV4dCBwYXJhZ3JhcGgpIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWxcbiAqICAgIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogICAgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAqICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICogICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAqICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqICAgIFNPRlRXQVJFLlxuICogIFxuICovXG5cbmltcG9ydCB7IENvbm5lY3Rpb24gfSBmcm9tICd3ZXN0ZmllbGQtcnVudGltZS1jb21tb24nXG5jb25zdCB7IHVpbnQsIHVpbnRPcHRpb25hbCwgaW50LCBpbnRPcHRpb25hbCwgZml4ZWQsIFxuXHRmaXhlZE9wdGlvbmFsLCBvYmplY3QsIG9iamVjdE9wdGlvbmFsLCBuZXdPYmplY3QsIHN0cmluZywgXG5cdHN0cmluZ09wdGlvbmFsLCBhcnJheSwgYXJyYXlPcHRpb25hbCwgXG5cdGZpbGVEZXNjcmlwdG9yT3B0aW9uYWwsIGZpbGVEZXNjcmlwdG9yLCBcbmgsIHUsIGksIGYsIG8sIG4sIHMsIGEgfSA9IENvbm5lY3Rpb25cbmltcG9ydCBQcm94eSBmcm9tICcuL1Byb3h5J1xuXG4vKipcbiAqXG4gKiAgICAgIEEgYnVmZmVyIHByb3ZpZGVzIHRoZSBjb250ZW50IGZvciBhIHdsX3N1cmZhY2UuIEJ1ZmZlcnMgYXJlXG4gKiAgICAgIGNyZWF0ZWQgdGhyb3VnaCBmYWN0b3J5IGludGVyZmFjZXMgc3VjaCBhcyB3bF9kcm0sIHdsX3NobSBvclxuICogICAgICBzaW1pbGFyLiBJdCBoYXMgYSB3aWR0aCBhbmQgYSBoZWlnaHQgYW5kIGNhbiBiZSBhdHRhY2hlZCB0byBhXG4gKiAgICAgIHdsX3N1cmZhY2UsIGJ1dCB0aGUgbWVjaGFuaXNtIGJ5IHdoaWNoIGEgY2xpZW50IHByb3ZpZGVzIGFuZFxuICogICAgICB1cGRhdGVzIHRoZSBjb250ZW50cyBpcyBkZWZpbmVkIGJ5IHRoZSBidWZmZXIgZmFjdG9yeSBpbnRlcmZhY2UuXG4gKiAgICBcbiAqL1xuY2xhc3MgV2xCdWZmZXJQcm94eSBleHRlbmRzIFByb3h5IHtcblxuXHQvKipcblx0ICpcblx0ICpcdERlc3Ryb3kgYSBidWZmZXIuIElmIGFuZCBob3cgeW91IG5lZWQgdG8gcmVsZWFzZSB0aGUgYmFja2luZ1xuXHQgKlx0c3RvcmFnZSBpcyBkZWZpbmVkIGJ5IHRoZSBidWZmZXIgZmFjdG9yeSBpbnRlcmZhY2UuXG5cdCAqXG5cdCAqXHRGb3IgcG9zc2libGUgc2lkZS1lZmZlY3RzIHRvIGEgc3VyZmFjZSwgc2VlIHdsX3N1cmZhY2UuYXR0YWNoLlxuXHQgKiAgICAgIFxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0ZGVzdHJveSAoKSB7XG5cdFx0c3VwZXIuZGVzdHJveSgpXG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgMCwgW10pXG5cdH1cblxuXHQvKipcblx0ICogRG8gbm90IGNvbnN0cnVjdCBwcm94aWVzIGRpcmVjdGx5LiBJbnN0ZWFkIHVzZSBvbmUgb2YgdGhlIGZhY3RvcnkgbWV0aG9kcyBmcm9tIG90aGVyIHByb3hpZXMuXG5cdCAqQHBhcmFtIHtEaXNwbGF5fWRpc3BsYXlcblx0ICpAcGFyYW0ge0Nvbm5lY3Rpb259Y29ubmVjdGlvblxuXHQgKkBwYXJhbSB7bnVtYmVyfWlkXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciAoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpIHtcblx0XHRzdXBlcihkaXNwbGF5LCBjb25uZWN0aW9uLCBpZClcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7V2xCdWZmZXJFdmVudHN8bnVsbH1cblx0XHQgKi9cblx0XHR0aGlzLmxpc3RlbmVyID0gbnVsbFxuXHR9XG5cblx0YXN5bmMgWzBdIChtZXNzYWdlKSB7XG5cdFx0YXdhaXQgdGhpcy5saXN0ZW5lci5yZWxlYXNlKClcblx0fVxuXG59XG5XbEJ1ZmZlclByb3h5LnByb3RvY29sTmFtZSA9ICd3bF9idWZmZXInXG5cbmV4cG9ydCBkZWZhdWx0IFdsQnVmZmVyUHJveHlcbiIsIi8qXG4gKlxuICogICAgQ29weXJpZ2h0IMKpIDIwMDgtMjAxMSBLcmlzdGlhbiBIw7hnc2JlcmdcbiAqICAgIENvcHlyaWdodCDCqSAyMDEwLTIwMTEgSW50ZWwgQ29ycG9yYXRpb25cbiAqICAgIENvcHlyaWdodCDCqSAyMDEyLTIwMTMgQ29sbGFib3JhLCBMdGQuXG4gKlxuICogICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gKiAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSAoaW5jbHVkaW5nIHRoZVxuICogICAgbmV4dCBwYXJhZ3JhcGgpIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWxcbiAqICAgIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogICAgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAqICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICogICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAqICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqICAgIFNPRlRXQVJFLlxuICogIFxuICovXG5cbi8qKlxuICogQGludGVyZmFjZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXbENhbGxiYWNrRXZlbnRzIHtcblxuXHQvKipcblx0ICpcblx0ICpcdE5vdGlmeSB0aGUgY2xpZW50IHdoZW4gdGhlIHJlbGF0ZWQgcmVxdWVzdCBpcyBkb25lLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gY2FsbGJhY2tEYXRhIHJlcXVlc3Qtc3BlY2lmaWMgZGF0YSBmb3IgdGhlIGNhbGxiYWNrIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0ZG9uZShjYWxsYmFja0RhdGEpIHt9XG59XG5cbiIsIi8qXG4gKlxuICogICAgQ29weXJpZ2h0IMKpIDIwMDgtMjAxMSBLcmlzdGlhbiBIw7hnc2JlcmdcbiAqICAgIENvcHlyaWdodCDCqSAyMDEwLTIwMTEgSW50ZWwgQ29ycG9yYXRpb25cbiAqICAgIENvcHlyaWdodCDCqSAyMDEyLTIwMTMgQ29sbGFib3JhLCBMdGQuXG4gKlxuICogICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gKiAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSAoaW5jbHVkaW5nIHRoZVxuICogICAgbmV4dCBwYXJhZ3JhcGgpIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWxcbiAqICAgIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogICAgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAqICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICogICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAqICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqICAgIFNPRlRXQVJFLlxuICogIFxuICovXG5cbmltcG9ydCB7IENvbm5lY3Rpb24gfSBmcm9tICd3ZXN0ZmllbGQtcnVudGltZS1jb21tb24nXG5jb25zdCB7IHVpbnQsIHVpbnRPcHRpb25hbCwgaW50LCBpbnRPcHRpb25hbCwgZml4ZWQsIFxuXHRmaXhlZE9wdGlvbmFsLCBvYmplY3QsIG9iamVjdE9wdGlvbmFsLCBuZXdPYmplY3QsIHN0cmluZywgXG5cdHN0cmluZ09wdGlvbmFsLCBhcnJheSwgYXJyYXlPcHRpb25hbCwgXG5cdGZpbGVEZXNjcmlwdG9yT3B0aW9uYWwsIGZpbGVEZXNjcmlwdG9yLCBcbmgsIHUsIGksIGYsIG8sIG4sIHMsIGEgfSA9IENvbm5lY3Rpb25cbmltcG9ydCBQcm94eSBmcm9tICcuL1Byb3h5J1xuXG4vKipcbiAqXG4gKiAgICAgIENsaWVudHMgY2FuIGhhbmRsZSB0aGUgJ2RvbmUnIGV2ZW50IHRvIGdldCBub3RpZmllZCB3aGVuXG4gKiAgICAgIHRoZSByZWxhdGVkIHJlcXVlc3QgaXMgZG9uZS5cbiAqICAgIFxuICovXG5jbGFzcyBXbENhbGxiYWNrUHJveHkgZXh0ZW5kcyBQcm94eSB7XG5cblx0LyoqXG5cdCAqIERvIG5vdCBjb25zdHJ1Y3QgcHJveGllcyBkaXJlY3RseS4gSW5zdGVhZCB1c2Ugb25lIG9mIHRoZSBmYWN0b3J5IG1ldGhvZHMgZnJvbSBvdGhlciBwcm94aWVzLlxuXHQgKkBwYXJhbSB7RGlzcGxheX1kaXNwbGF5XG5cdCAqQHBhcmFtIHtDb25uZWN0aW9ufWNvbm5lY3Rpb25cblx0ICpAcGFyYW0ge251bWJlcn1pZFxuXHQgKi9cblx0Y29uc3RydWN0b3IgKGRpc3BsYXksIGNvbm5lY3Rpb24sIGlkKSB7XG5cdFx0c3VwZXIoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge1dsQ2FsbGJhY2tFdmVudHN8bnVsbH1cblx0XHQgKi9cblx0XHR0aGlzLmxpc3RlbmVyID0gbnVsbFxuXHR9XG5cblx0YXN5bmMgWzBdIChtZXNzYWdlKSB7XG5cdFx0YXdhaXQgdGhpcy5saXN0ZW5lci5kb25lKHUobWVzc2FnZSkpXG5cdH1cblxufVxuV2xDYWxsYmFja1Byb3h5LnByb3RvY29sTmFtZSA9ICd3bF9jYWxsYmFjaydcblxuZXhwb3J0IGRlZmF1bHQgV2xDYWxsYmFja1Byb3h5XG4iLCIvKlxuICpcbiAqICAgIENvcHlyaWdodCDCqSAyMDA4LTIwMTEgS3Jpc3RpYW4gSMO4Z3NiZXJnXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMC0yMDExIEludGVsIENvcnBvcmF0aW9uXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMi0yMDEzIENvbGxhYm9yYSwgTHRkLlxuICpcbiAqICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICogICAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICogICAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAqICAgIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gKiAgICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogICAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgKGluY2x1ZGluZyB0aGVcbiAqICAgIG5leHQgcGFyYWdyYXBoKSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsXG4gKiAgICBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogICAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqICAgIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gKiAgICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAqICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gKiAgICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiAgICBTT0ZUV0FSRS5cbiAqICBcbiAqL1xuXG5pbXBvcnQgeyBDb25uZWN0aW9uIH0gZnJvbSAnd2VzdGZpZWxkLXJ1bnRpbWUtY29tbW9uJ1xuY29uc3QgeyB1aW50LCB1aW50T3B0aW9uYWwsIGludCwgaW50T3B0aW9uYWwsIGZpeGVkLCBcblx0Zml4ZWRPcHRpb25hbCwgb2JqZWN0LCBvYmplY3RPcHRpb25hbCwgbmV3T2JqZWN0LCBzdHJpbmcsIFxuXHRzdHJpbmdPcHRpb25hbCwgYXJyYXksIGFycmF5T3B0aW9uYWwsIFxuXHRmaWxlRGVzY3JpcHRvck9wdGlvbmFsLCBmaWxlRGVzY3JpcHRvciwgXG5oLCB1LCBpLCBmLCBvLCBuLCBzLCBhIH0gPSBDb25uZWN0aW9uXG5pbXBvcnQgUHJveHkgZnJvbSAnLi9Qcm94eSdcbmltcG9ydCBXbFN1cmZhY2VQcm94eSBmcm9tICcuL1dsU3VyZmFjZVByb3h5J1xuaW1wb3J0IFdsUmVnaW9uUHJveHkgZnJvbSAnLi9XbFJlZ2lvblByb3h5J1xuXG4vKipcbiAqXG4gKiAgICAgIEEgY29tcG9zaXRvci4gIFRoaXMgb2JqZWN0IGlzIGEgc2luZ2xldG9uIGdsb2JhbC4gIFRoZVxuICogICAgICBjb21wb3NpdG9yIGlzIGluIGNoYXJnZSBvZiBjb21iaW5pbmcgdGhlIGNvbnRlbnRzIG9mIG11bHRpcGxlXG4gKiAgICAgIHN1cmZhY2VzIGludG8gb25lIGRpc3BsYXlhYmxlIG91dHB1dC5cbiAqICAgIFxuICovXG5jbGFzcyBXbENvbXBvc2l0b3JQcm94eSBleHRlbmRzIFByb3h5IHtcblxuXHQvKipcblx0ICpcblx0ICpcdEFzayB0aGUgY29tcG9zaXRvciB0byBjcmVhdGUgYSBuZXcgc3VyZmFjZS5cblx0ICogICAgICBcblx0ICpcblx0ICogQHJldHVybiB7V2xTdXJmYWNlUHJveHl9IHRoZSBuZXcgc3VyZmFjZSBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdGNyZWF0ZVN1cmZhY2UgKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXJzaGFsbENvbnN0cnVjdG9yKHRoaXMuaWQsIDAsIFdsU3VyZmFjZVByb3h5LCBbbmV3T2JqZWN0KCldKVxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRBc2sgdGhlIGNvbXBvc2l0b3IgdG8gY3JlYXRlIGEgbmV3IHJlZ2lvbi5cblx0ICogICAgICBcblx0ICpcblx0ICogQHJldHVybiB7V2xSZWdpb25Qcm94eX0gdGhlIG5ldyByZWdpb24gXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRjcmVhdGVSZWdpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXJzaGFsbENvbnN0cnVjdG9yKHRoaXMuaWQsIDEsIFdsUmVnaW9uUHJveHksIFtuZXdPYmplY3QoKV0pXG5cdH1cblxuXHQvKipcblx0ICogRG8gbm90IGNvbnN0cnVjdCBwcm94aWVzIGRpcmVjdGx5LiBJbnN0ZWFkIHVzZSBvbmUgb2YgdGhlIGZhY3RvcnkgbWV0aG9kcyBmcm9tIG90aGVyIHByb3hpZXMuXG5cdCAqQHBhcmFtIHtEaXNwbGF5fWRpc3BsYXlcblx0ICpAcGFyYW0ge0Nvbm5lY3Rpb259Y29ubmVjdGlvblxuXHQgKkBwYXJhbSB7bnVtYmVyfWlkXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciAoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpIHtcblx0XHRzdXBlcihkaXNwbGF5LCBjb25uZWN0aW9uLCBpZClcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7V2xDb21wb3NpdG9yRXZlbnRzfG51bGx9XG5cdFx0ICovXG5cdFx0dGhpcy5saXN0ZW5lciA9IG51bGxcblx0fVxuXG59XG5XbENvbXBvc2l0b3JQcm94eS5wcm90b2NvbE5hbWUgPSAnd2xfY29tcG9zaXRvcidcblxuZXhwb3J0IGRlZmF1bHQgV2xDb21wb3NpdG9yUHJveHlcbiIsIi8qXG4gKlxuICogICAgQ29weXJpZ2h0IMKpIDIwMDgtMjAxMSBLcmlzdGlhbiBIw7hnc2JlcmdcbiAqICAgIENvcHlyaWdodCDCqSAyMDEwLTIwMTEgSW50ZWwgQ29ycG9yYXRpb25cbiAqICAgIENvcHlyaWdodCDCqSAyMDEyLTIwMTMgQ29sbGFib3JhLCBMdGQuXG4gKlxuICogICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gKiAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSAoaW5jbHVkaW5nIHRoZVxuICogICAgbmV4dCBwYXJhZ3JhcGgpIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWxcbiAqICAgIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogICAgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAqICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICogICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAqICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqICAgIFNPRlRXQVJFLlxuICogIFxuICovXG5cbi8qKlxuICogQGludGVyZmFjZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXbERhdGFEZXZpY2VFdmVudHMge1xuXG5cdC8qKlxuXHQgKlxuXHQgKlx0VGhlIGRhdGFfb2ZmZXIgZXZlbnQgaW50cm9kdWNlcyBhIG5ldyB3bF9kYXRhX29mZmVyIG9iamVjdCxcblx0ICpcdHdoaWNoIHdpbGwgc3Vic2VxdWVudGx5IGJlIHVzZWQgaW4gZWl0aGVyIHRoZVxuXHQgKlx0ZGF0YV9kZXZpY2UuZW50ZXIgZXZlbnQgKGZvciBkcmFnLWFuZC1kcm9wKSBvciB0aGVcblx0ICpcdGRhdGFfZGV2aWNlLnNlbGVjdGlvbiBldmVudCAoZm9yIHNlbGVjdGlvbnMpLiAgSW1tZWRpYXRlbHlcblx0ICpcdGZvbGxvd2luZyB0aGUgZGF0YV9kZXZpY2VfZGF0YV9vZmZlciBldmVudCwgdGhlIG5ldyBkYXRhX29mZmVyXG5cdCAqXHRvYmplY3Qgd2lsbCBzZW5kIG91dCBkYXRhX29mZmVyLm9mZmVyIGV2ZW50cyB0byBkZXNjcmliZSB0aGVcblx0ICpcdG1pbWUgdHlwZXMgaXQgb2ZmZXJzLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaWQgdGhlIG5ldyBkYXRhX29mZmVyIG9iamVjdCBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdGRhdGFPZmZlcihpZCkge31cblxuXHQvKipcblx0ICpcblx0ICpcdFRoaXMgZXZlbnQgaXMgc2VudCB3aGVuIGFuIGFjdGl2ZSBkcmFnLWFuZC1kcm9wIHBvaW50ZXIgZW50ZXJzXG5cdCAqXHRhIHN1cmZhY2Ugb3duZWQgYnkgdGhlIGNsaWVudC4gIFRoZSBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBhdFxuXHQgKlx0ZW50ZXIgdGltZSBpcyBwcm92aWRlZCBieSB0aGUgeCBhbmQgeSBhcmd1bWVudHMsIGluIHN1cmZhY2UtbG9jYWxcblx0ICpcdGNvb3JkaW5hdGVzLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2VyaWFsIHNlcmlhbCBudW1iZXIgb2YgdGhlIGVudGVyIGV2ZW50IFxuXHQgKiBAcGFyYW0geyp9IHN1cmZhY2UgY2xpZW50IHN1cmZhY2UgZW50ZXJlZCBcblx0ICogQHBhcmFtIHtGaXhlZH0geCBzdXJmYWNlLWxvY2FsIHggY29vcmRpbmF0ZSBcblx0ICogQHBhcmFtIHtGaXhlZH0geSBzdXJmYWNlLWxvY2FsIHkgY29vcmRpbmF0ZSBcblx0ICogQHBhcmFtIHs/Kn0gaWQgc291cmNlIGRhdGFfb2ZmZXIgb2JqZWN0IFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0ZW50ZXIoc2VyaWFsLCBzdXJmYWNlLCB4LCB5LCBpZCkge31cblxuXHQvKipcblx0ICpcblx0ICpcdFRoaXMgZXZlbnQgaXMgc2VudCB3aGVuIHRoZSBkcmFnLWFuZC1kcm9wIHBvaW50ZXIgbGVhdmVzIHRoZVxuXHQgKlx0c3VyZmFjZSBhbmQgdGhlIHNlc3Npb24gZW5kcy4gIFRoZSBjbGllbnQgbXVzdCBkZXN0cm95IHRoZVxuXHQgKlx0d2xfZGF0YV9vZmZlciBpbnRyb2R1Y2VkIGF0IGVudGVyIHRpbWUgYXQgdGhpcyBwb2ludC5cblx0ICogICAgICBcblx0ICpcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdGxlYXZlKCkge31cblxuXHQvKipcblx0ICpcblx0ICpcdFRoaXMgZXZlbnQgaXMgc2VudCB3aGVuIHRoZSBkcmFnLWFuZC1kcm9wIHBvaW50ZXIgbW92ZXMgd2l0aGluXG5cdCAqXHR0aGUgY3VycmVudGx5IGZvY3VzZWQgc3VyZmFjZS4gVGhlIG5ldyBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlclxuXHQgKlx0aXMgcHJvdmlkZWQgYnkgdGhlIHggYW5kIHkgYXJndW1lbnRzLCBpbiBzdXJmYWNlLWxvY2FsXG5cdCAqXHRjb29yZGluYXRlcy5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgdGltZXN0YW1wIHdpdGggbWlsbGlzZWNvbmQgZ3JhbnVsYXJpdHkgXG5cdCAqIEBwYXJhbSB7Rml4ZWR9IHggc3VyZmFjZS1sb2NhbCB4IGNvb3JkaW5hdGUgXG5cdCAqIEBwYXJhbSB7Rml4ZWR9IHkgc3VyZmFjZS1sb2NhbCB5IGNvb3JkaW5hdGUgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRtb3Rpb24odGltZSwgeCwgeSkge31cblxuXHQvKipcblx0ICpcblx0ICpcdFRoZSBldmVudCBpcyBzZW50IHdoZW4gYSBkcmFnLWFuZC1kcm9wIG9wZXJhdGlvbiBpcyBlbmRlZFxuXHQgKlx0YmVjYXVzZSB0aGUgaW1wbGljaXQgZ3JhYiBpcyByZW1vdmVkLlxuXHQgKlxuXHQgKlx0VGhlIGRyYWctYW5kLWRyb3AgZGVzdGluYXRpb24gaXMgZXhwZWN0ZWQgdG8gaG9ub3IgdGhlIGxhc3QgYWN0aW9uXG5cdCAqXHRyZWNlaXZlZCB0aHJvdWdoIHdsX2RhdGFfb2ZmZXIuYWN0aW9uLCBpZiB0aGUgcmVzdWx0aW5nIGFjdGlvbiBpc1xuXHQgKlx0XCJjb3B5XCIgb3IgXCJtb3ZlXCIsIHRoZSBkZXN0aW5hdGlvbiBjYW4gc3RpbGwgcGVyZm9ybVxuXHQgKlx0d2xfZGF0YV9vZmZlci5yZWNlaXZlIHJlcXVlc3RzLCBhbmQgaXMgZXhwZWN0ZWQgdG8gZW5kIGFsbFxuXHQgKlx0dHJhbnNmZXJzIHdpdGggYSB3bF9kYXRhX29mZmVyLmZpbmlzaCByZXF1ZXN0LlxuXHQgKlxuXHQgKlx0SWYgdGhlIHJlc3VsdGluZyBhY3Rpb24gaXMgXCJhc2tcIiwgdGhlIGFjdGlvbiB3aWxsIG5vdCBiZSBjb25zaWRlcmVkXG5cdCAqXHRmaW5hbC4gVGhlIGRyYWctYW5kLWRyb3AgZGVzdGluYXRpb24gaXMgZXhwZWN0ZWQgdG8gcGVyZm9ybSBvbmUgbGFzdFxuXHQgKlx0d2xfZGF0YV9vZmZlci5zZXRfYWN0aW9ucyByZXF1ZXN0LCBvciB3bF9kYXRhX29mZmVyLmRlc3Ryb3kgaW4gb3JkZXJcblx0ICpcdHRvIGNhbmNlbCB0aGUgb3BlcmF0aW9uLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0ZHJvcCgpIHt9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRUaGUgc2VsZWN0aW9uIGV2ZW50IGlzIHNlbnQgb3V0IHRvIG5vdGlmeSB0aGUgY2xpZW50IG9mIGEgbmV3XG5cdCAqXHR3bF9kYXRhX29mZmVyIGZvciB0aGUgc2VsZWN0aW9uIGZvciB0aGlzIGRldmljZS4gIFRoZVxuXHQgKlx0ZGF0YV9kZXZpY2UuZGF0YV9vZmZlciBhbmQgdGhlIGRhdGFfb2ZmZXIub2ZmZXIgZXZlbnRzIGFyZVxuXHQgKlx0c2VudCBvdXQgaW1tZWRpYXRlbHkgYmVmb3JlIHRoaXMgZXZlbnQgdG8gaW50cm9kdWNlIHRoZSBkYXRhXG5cdCAqXHRvZmZlciBvYmplY3QuICBUaGUgc2VsZWN0aW9uIGV2ZW50IGlzIHNlbnQgdG8gYSBjbGllbnRcblx0ICpcdGltbWVkaWF0ZWx5IGJlZm9yZSByZWNlaXZpbmcga2V5Ym9hcmQgZm9jdXMgYW5kIHdoZW4gYSBuZXdcblx0ICpcdHNlbGVjdGlvbiBpcyBzZXQgd2hpbGUgdGhlIGNsaWVudCBoYXMga2V5Ym9hcmQgZm9jdXMuICBUaGVcblx0ICpcdGRhdGFfb2ZmZXIgaXMgdmFsaWQgdW50aWwgYSBuZXcgZGF0YV9vZmZlciBvciBOVUxMIGlzIHJlY2VpdmVkXG5cdCAqXHRvciB1bnRpbCB0aGUgY2xpZW50IGxvc2VzIGtleWJvYXJkIGZvY3VzLiAgVGhlIGNsaWVudCBtdXN0XG5cdCAqXHRkZXN0cm95IHRoZSBwcmV2aW91cyBzZWxlY3Rpb24gZGF0YV9vZmZlciwgaWYgYW55LCB1cG9uIHJlY2VpdmluZ1xuXHQgKlx0dGhpcyBldmVudC5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHs/Kn0gaWQgc2VsZWN0aW9uIGRhdGFfb2ZmZXIgb2JqZWN0IFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0c2VsZWN0aW9uKGlkKSB7fVxufVxuXG4iLCIvKlxuICpcbiAqICAgIENvcHlyaWdodCDCqSAyMDA4LTIwMTEgS3Jpc3RpYW4gSMO4Z3NiZXJnXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMC0yMDExIEludGVsIENvcnBvcmF0aW9uXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMi0yMDEzIENvbGxhYm9yYSwgTHRkLlxuICpcbiAqICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICogICAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICogICAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAqICAgIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gKiAgICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogICAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgKGluY2x1ZGluZyB0aGVcbiAqICAgIG5leHQgcGFyYWdyYXBoKSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsXG4gKiAgICBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogICAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqICAgIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gKiAgICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAqICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gKiAgICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiAgICBTT0ZUV0FSRS5cbiAqICBcbiAqL1xuXG5pbXBvcnQgeyBDb25uZWN0aW9uIH0gZnJvbSAnd2VzdGZpZWxkLXJ1bnRpbWUtY29tbW9uJ1xuY29uc3QgeyB1aW50LCB1aW50T3B0aW9uYWwsIGludCwgaW50T3B0aW9uYWwsIGZpeGVkLCBcblx0Zml4ZWRPcHRpb25hbCwgb2JqZWN0LCBvYmplY3RPcHRpb25hbCwgbmV3T2JqZWN0LCBzdHJpbmcsIFxuXHRzdHJpbmdPcHRpb25hbCwgYXJyYXksIGFycmF5T3B0aW9uYWwsIFxuXHRmaWxlRGVzY3JpcHRvck9wdGlvbmFsLCBmaWxlRGVzY3JpcHRvciwgXG5oLCB1LCBpLCBmLCBvLCBuLCBzLCBhIH0gPSBDb25uZWN0aW9uXG5pbXBvcnQgUHJveHkgZnJvbSAnLi9Qcm94eSdcbmltcG9ydCBXbERhdGFTb3VyY2VQcm94eSBmcm9tICcuL1dsRGF0YVNvdXJjZVByb3h5J1xuaW1wb3J0IFdsRGF0YURldmljZVByb3h5IGZyb20gJy4vV2xEYXRhRGV2aWNlUHJveHknXG5cbi8qKlxuICpcbiAqICAgICAgVGhlIHdsX2RhdGFfZGV2aWNlX21hbmFnZXIgaXMgYSBzaW5nbGV0b24gZ2xvYmFsIG9iamVjdCB0aGF0XG4gKiAgICAgIHByb3ZpZGVzIGFjY2VzcyB0byBpbnRlci1jbGllbnQgZGF0YSB0cmFuc2ZlciBtZWNoYW5pc21zIHN1Y2ggYXNcbiAqICAgICAgY29weS1hbmQtcGFzdGUgYW5kIGRyYWctYW5kLWRyb3AuICBUaGVzZSBtZWNoYW5pc21zIGFyZSB0aWVkIHRvXG4gKiAgICAgIGEgd2xfc2VhdCBhbmQgdGhpcyBpbnRlcmZhY2UgbGV0cyBhIGNsaWVudCBnZXQgYSB3bF9kYXRhX2RldmljZVxuICogICAgICBjb3JyZXNwb25kaW5nIHRvIGEgd2xfc2VhdC5cbiAqXG4gKiAgICAgIERlcGVuZGluZyBvbiB0aGUgdmVyc2lvbiBib3VuZCwgdGhlIG9iamVjdHMgY3JlYXRlZCBmcm9tIHRoZSBib3VuZFxuICogICAgICB3bF9kYXRhX2RldmljZV9tYW5hZ2VyIG9iamVjdCB3aWxsIGhhdmUgZGlmZmVyZW50IHJlcXVpcmVtZW50cyBmb3JcbiAqICAgICAgZnVuY3Rpb25pbmcgcHJvcGVybHkuIFNlZSB3bF9kYXRhX3NvdXJjZS5zZXRfYWN0aW9ucyxcbiAqICAgICAgd2xfZGF0YV9vZmZlci5hY2NlcHQgYW5kIHdsX2RhdGFfb2ZmZXIuZmluaXNoIGZvciBkZXRhaWxzLlxuICogICAgXG4gKi9cbmNsYXNzIFdsRGF0YURldmljZU1hbmFnZXJQcm94eSBleHRlbmRzIFByb3h5IHtcblxuXHQvKipcblx0ICpcblx0ICpcdENyZWF0ZSBhIG5ldyBkYXRhIHNvdXJjZS5cblx0ICogICAgICBcblx0ICpcblx0ICogQHJldHVybiB7V2xEYXRhU291cmNlUHJveHl9IGRhdGEgc291cmNlIHRvIGNyZWF0ZSBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdGNyZWF0ZURhdGFTb3VyY2UgKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXJzaGFsbENvbnN0cnVjdG9yKHRoaXMuaWQsIDAsIFdsRGF0YVNvdXJjZVByb3h5LCBbbmV3T2JqZWN0KCldKVxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRDcmVhdGUgYSBuZXcgZGF0YSBkZXZpY2UgZm9yIGEgZ2l2ZW4gc2VhdC5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHsqfSBzZWF0IHNlYXQgYXNzb2NpYXRlZCB3aXRoIHRoZSBkYXRhIGRldmljZSBcblx0ICogQHJldHVybiB7V2xEYXRhRGV2aWNlUHJveHl9IGRhdGEgZGV2aWNlIHRvIGNyZWF0ZSBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdGdldERhdGFEZXZpY2UgKHNlYXQpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFyc2hhbGxDb25zdHJ1Y3Rvcih0aGlzLmlkLCAxLCBXbERhdGFEZXZpY2VQcm94eSwgW25ld09iamVjdCgpLCBvYmplY3Qoc2VhdCldKVxuXHR9XG5cblx0LyoqXG5cdCAqIERvIG5vdCBjb25zdHJ1Y3QgcHJveGllcyBkaXJlY3RseS4gSW5zdGVhZCB1c2Ugb25lIG9mIHRoZSBmYWN0b3J5IG1ldGhvZHMgZnJvbSBvdGhlciBwcm94aWVzLlxuXHQgKkBwYXJhbSB7RGlzcGxheX1kaXNwbGF5XG5cdCAqQHBhcmFtIHtDb25uZWN0aW9ufWNvbm5lY3Rpb25cblx0ICpAcGFyYW0ge251bWJlcn1pZFxuXHQgKi9cblx0Y29uc3RydWN0b3IgKGRpc3BsYXksIGNvbm5lY3Rpb24sIGlkKSB7XG5cdFx0c3VwZXIoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge1dsRGF0YURldmljZU1hbmFnZXJFdmVudHN8bnVsbH1cblx0XHQgKi9cblx0XHR0aGlzLmxpc3RlbmVyID0gbnVsbFxuXHR9XG5cbn1cbldsRGF0YURldmljZU1hbmFnZXJQcm94eS5wcm90b2NvbE5hbWUgPSAnd2xfZGF0YV9kZXZpY2VfbWFuYWdlcidcblxuV2xEYXRhRGV2aWNlTWFuYWdlclByb3h5LkRuZEFjdGlvbiA9IHtcbiAgLyoqXG4gICAqIG5vIGFjdGlvblxuICAgKi9cbiAgbm9uZTogMCxcbiAgLyoqXG4gICAqIGNvcHkgYWN0aW9uXG4gICAqL1xuICBjb3B5OiAxLFxuICAvKipcbiAgICogbW92ZSBhY3Rpb25cbiAgICovXG4gIG1vdmU6IDIsXG4gIC8qKlxuICAgKiBhc2sgYWN0aW9uXG4gICAqL1xuICBhc2s6IDRcbn1cblxuZXhwb3J0IGRlZmF1bHQgV2xEYXRhRGV2aWNlTWFuYWdlclByb3h5XG4iLCIvKlxuICpcbiAqICAgIENvcHlyaWdodCDCqSAyMDA4LTIwMTEgS3Jpc3RpYW4gSMO4Z3NiZXJnXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMC0yMDExIEludGVsIENvcnBvcmF0aW9uXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMi0yMDEzIENvbGxhYm9yYSwgTHRkLlxuICpcbiAqICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICogICAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICogICAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAqICAgIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gKiAgICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogICAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgKGluY2x1ZGluZyB0aGVcbiAqICAgIG5leHQgcGFyYWdyYXBoKSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsXG4gKiAgICBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogICAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqICAgIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gKiAgICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAqICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gKiAgICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiAgICBTT0ZUV0FSRS5cbiAqICBcbiAqL1xuXG5pbXBvcnQgeyBDb25uZWN0aW9uIH0gZnJvbSAnd2VzdGZpZWxkLXJ1bnRpbWUtY29tbW9uJ1xuY29uc3QgeyB1aW50LCB1aW50T3B0aW9uYWwsIGludCwgaW50T3B0aW9uYWwsIGZpeGVkLCBcblx0Zml4ZWRPcHRpb25hbCwgb2JqZWN0LCBvYmplY3RPcHRpb25hbCwgbmV3T2JqZWN0LCBzdHJpbmcsIFxuXHRzdHJpbmdPcHRpb25hbCwgYXJyYXksIGFycmF5T3B0aW9uYWwsIFxuXHRmaWxlRGVzY3JpcHRvck9wdGlvbmFsLCBmaWxlRGVzY3JpcHRvciwgXG5oLCB1LCBpLCBmLCBvLCBuLCBzLCBhIH0gPSBDb25uZWN0aW9uXG5pbXBvcnQgUHJveHkgZnJvbSAnLi9Qcm94eSdcbmltcG9ydCBXbERhdGFPZmZlclByb3h5IGZyb20gJy4vV2xEYXRhT2ZmZXJQcm94eSdcblxuLyoqXG4gKlxuICogICAgICBUaGVyZSBpcyBvbmUgd2xfZGF0YV9kZXZpY2UgcGVyIHNlYXQgd2hpY2ggY2FuIGJlIG9idGFpbmVkXG4gKiAgICAgIGZyb20gdGhlIGdsb2JhbCB3bF9kYXRhX2RldmljZV9tYW5hZ2VyIHNpbmdsZXRvbi5cbiAqXG4gKiAgICAgIEEgd2xfZGF0YV9kZXZpY2UgcHJvdmlkZXMgYWNjZXNzIHRvIGludGVyLWNsaWVudCBkYXRhIHRyYW5zZmVyXG4gKiAgICAgIG1lY2hhbmlzbXMgc3VjaCBhcyBjb3B5LWFuZC1wYXN0ZSBhbmQgZHJhZy1hbmQtZHJvcC5cbiAqICAgIFxuICovXG5jbGFzcyBXbERhdGFEZXZpY2VQcm94eSBleHRlbmRzIFByb3h5IHtcblxuXHQvKipcblx0ICpcblx0ICpcdFRoaXMgcmVxdWVzdCBhc2tzIHRoZSBjb21wb3NpdG9yIHRvIHN0YXJ0IGEgZHJhZy1hbmQtZHJvcFxuXHQgKlx0b3BlcmF0aW9uIG9uIGJlaGFsZiBvZiB0aGUgY2xpZW50LlxuXHQgKlxuXHQgKlx0VGhlIHNvdXJjZSBhcmd1bWVudCBpcyB0aGUgZGF0YSBzb3VyY2UgdGhhdCBwcm92aWRlcyB0aGUgZGF0YVxuXHQgKlx0Zm9yIHRoZSBldmVudHVhbCBkYXRhIHRyYW5zZmVyLiBJZiBzb3VyY2UgaXMgTlVMTCwgZW50ZXIsIGxlYXZlXG5cdCAqXHRhbmQgbW90aW9uIGV2ZW50cyBhcmUgc2VudCBvbmx5IHRvIHRoZSBjbGllbnQgdGhhdCBpbml0aWF0ZWQgdGhlXG5cdCAqXHRkcmFnIGFuZCB0aGUgY2xpZW50IGlzIGV4cGVjdGVkIHRvIGhhbmRsZSB0aGUgZGF0YSBwYXNzaW5nXG5cdCAqXHRpbnRlcm5hbGx5LlxuXHQgKlxuXHQgKlx0VGhlIG9yaWdpbiBzdXJmYWNlIGlzIHRoZSBzdXJmYWNlIHdoZXJlIHRoZSBkcmFnIG9yaWdpbmF0ZXMgYW5kXG5cdCAqXHR0aGUgY2xpZW50IG11c3QgaGF2ZSBhbiBhY3RpdmUgaW1wbGljaXQgZ3JhYiB0aGF0IG1hdGNoZXMgdGhlXG5cdCAqXHRzZXJpYWwuXG5cdCAqXG5cdCAqXHRUaGUgaWNvbiBzdXJmYWNlIGlzIGFuIG9wdGlvbmFsIChjYW4gYmUgTlVMTCkgc3VyZmFjZSB0aGF0XG5cdCAqXHRwcm92aWRlcyBhbiBpY29uIHRvIGJlIG1vdmVkIGFyb3VuZCB3aXRoIHRoZSBjdXJzb3IuICBJbml0aWFsbHksXG5cdCAqXHR0aGUgdG9wLWxlZnQgY29ybmVyIG9mIHRoZSBpY29uIHN1cmZhY2UgaXMgcGxhY2VkIGF0IHRoZSBjdXJzb3Jcblx0ICpcdGhvdHNwb3QsIGJ1dCBzdWJzZXF1ZW50IHdsX3N1cmZhY2UuYXR0YWNoIHJlcXVlc3QgY2FuIG1vdmUgdGhlXG5cdCAqXHRyZWxhdGl2ZSBwb3NpdGlvbi4gQXR0YWNoIHJlcXVlc3RzIG11c3QgYmUgY29uZmlybWVkIHdpdGhcblx0ICpcdHdsX3N1cmZhY2UuY29tbWl0IGFzIHVzdWFsLiBUaGUgaWNvbiBzdXJmYWNlIGlzIGdpdmVuIHRoZSByb2xlIG9mXG5cdCAqXHRhIGRyYWctYW5kLWRyb3AgaWNvbi4gSWYgdGhlIGljb24gc3VyZmFjZSBhbHJlYWR5IGhhcyBhbm90aGVyIHJvbGUsXG5cdCAqXHRpdCByYWlzZXMgYSBwcm90b2NvbCBlcnJvci5cblx0ICpcblx0ICpcdFRoZSBjdXJyZW50IGFuZCBwZW5kaW5nIGlucHV0IHJlZ2lvbnMgb2YgdGhlIGljb24gd2xfc3VyZmFjZSBhcmVcblx0ICpcdGNsZWFyZWQsIGFuZCB3bF9zdXJmYWNlLnNldF9pbnB1dF9yZWdpb24gaXMgaWdub3JlZCB1bnRpbCB0aGVcblx0ICpcdHdsX3N1cmZhY2UgaXMgbm8gbG9uZ2VyIHVzZWQgYXMgdGhlIGljb24gc3VyZmFjZS4gV2hlbiB0aGUgdXNlXG5cdCAqXHRhcyBhbiBpY29uIGVuZHMsIHRoZSBjdXJyZW50IGFuZCBwZW5kaW5nIGlucHV0IHJlZ2lvbnMgYmVjb21lXG5cdCAqXHR1bmRlZmluZWQsIGFuZCB0aGUgd2xfc3VyZmFjZSBpcyB1bm1hcHBlZC5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHs/Kn0gc291cmNlIGRhdGEgc291cmNlIGZvciB0aGUgZXZlbnR1YWwgdHJhbnNmZXIgXG5cdCAqIEBwYXJhbSB7Kn0gb3JpZ2luIHN1cmZhY2Ugd2hlcmUgdGhlIGRyYWcgb3JpZ2luYXRlcyBcblx0ICogQHBhcmFtIHs/Kn0gaWNvbiBkcmFnLWFuZC1kcm9wIGljb24gc3VyZmFjZSBcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNlcmlhbCBzZXJpYWwgbnVtYmVyIG9mIHRoZSBpbXBsaWNpdCBncmFiIG9uIHRoZSBvcmlnaW4gXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRzdGFydERyYWcgKHNvdXJjZSwgb3JpZ2luLCBpY29uLCBzZXJpYWwpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCAwLCBbb2JqZWN0T3B0aW9uYWwoc291cmNlKSwgb2JqZWN0KG9yaWdpbiksIG9iamVjdE9wdGlvbmFsKGljb24pLCB1aW50KHNlcmlhbCldKVxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRUaGlzIHJlcXVlc3QgYXNrcyB0aGUgY29tcG9zaXRvciB0byBzZXQgdGhlIHNlbGVjdGlvblxuXHQgKlx0dG8gdGhlIGRhdGEgZnJvbSB0aGUgc291cmNlIG9uIGJlaGFsZiBvZiB0aGUgY2xpZW50LlxuXHQgKlxuXHQgKlx0VG8gdW5zZXQgdGhlIHNlbGVjdGlvbiwgc2V0IHRoZSBzb3VyY2UgdG8gTlVMTC5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHs/Kn0gc291cmNlIGRhdGEgc291cmNlIGZvciB0aGUgc2VsZWN0aW9uIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2VyaWFsIHNlcmlhbCBudW1iZXIgb2YgdGhlIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgcmVxdWVzdCBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdHNldFNlbGVjdGlvbiAoc291cmNlLCBzZXJpYWwpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCAxLCBbb2JqZWN0T3B0aW9uYWwoc291cmNlKSwgdWludChzZXJpYWwpXSlcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0VGhpcyByZXF1ZXN0IGRlc3Ryb3lzIHRoZSBkYXRhIGRldmljZS5cblx0ICogICAgICBcblx0ICogQHNpbmNlIDJcblx0ICpcblx0ICovXG5cdHJlbGVhc2UgKCkge1xuXHRcdHN1cGVyLmRlc3Ryb3koKVxuXHRcdHRoaXMuX21hcnNoYWxsKHRoaXMuaWQsIDIsIFtdKVxuXHR9XG5cblx0LyoqXG5cdCAqIERvIG5vdCBjb25zdHJ1Y3QgcHJveGllcyBkaXJlY3RseS4gSW5zdGVhZCB1c2Ugb25lIG9mIHRoZSBmYWN0b3J5IG1ldGhvZHMgZnJvbSBvdGhlciBwcm94aWVzLlxuXHQgKkBwYXJhbSB7RGlzcGxheX1kaXNwbGF5XG5cdCAqQHBhcmFtIHtDb25uZWN0aW9ufWNvbm5lY3Rpb25cblx0ICpAcGFyYW0ge251bWJlcn1pZFxuXHQgKi9cblx0Y29uc3RydWN0b3IgKGRpc3BsYXksIGNvbm5lY3Rpb24sIGlkKSB7XG5cdFx0c3VwZXIoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge1dsRGF0YURldmljZUV2ZW50c3xudWxsfVxuXHRcdCAqL1xuXHRcdHRoaXMubGlzdGVuZXIgPSBudWxsXG5cdH1cblxuXHRhc3luYyBbMF0gKG1lc3NhZ2UpIHtcblx0XHRhd2FpdCB0aGlzLmxpc3RlbmVyLmRhdGFPZmZlcihuZXcgV2xEYXRhT2ZmZXJQcm94eSh0aGlzLl9jb25uZWN0aW9uLCBuKG1lc3NhZ2UpKSlcblx0fVxuXG5cdGFzeW5jIFsxXSAobWVzc2FnZSkge1xuXHRcdGF3YWl0IHRoaXMubGlzdGVuZXIuZW50ZXIodShtZXNzYWdlKSwgbyhtZXNzYWdlLCBmYWxzZSwgdGhpcy5fY29ubmVjdGlvbiksIGYobWVzc2FnZSksIGYobWVzc2FnZSksIG8obWVzc2FnZSwgdHJ1ZSwgdGhpcy5fY29ubmVjdGlvbikpXG5cdH1cblxuXHRhc3luYyBbMl0gKG1lc3NhZ2UpIHtcblx0XHRhd2FpdCB0aGlzLmxpc3RlbmVyLmxlYXZlKClcblx0fVxuXG5cdGFzeW5jIFszXSAobWVzc2FnZSkge1xuXHRcdGF3YWl0IHRoaXMubGlzdGVuZXIubW90aW9uKHUobWVzc2FnZSksIGYobWVzc2FnZSksIGYobWVzc2FnZSkpXG5cdH1cblxuXHRhc3luYyBbNF0gKG1lc3NhZ2UpIHtcblx0XHRhd2FpdCB0aGlzLmxpc3RlbmVyLmRyb3AoKVxuXHR9XG5cblx0YXN5bmMgWzVdIChtZXNzYWdlKSB7XG5cdFx0YXdhaXQgdGhpcy5saXN0ZW5lci5zZWxlY3Rpb24obyhtZXNzYWdlLCB0cnVlLCB0aGlzLl9jb25uZWN0aW9uKSlcblx0fVxuXG59XG5XbERhdGFEZXZpY2VQcm94eS5wcm90b2NvbE5hbWUgPSAnd2xfZGF0YV9kZXZpY2UnXG5cbldsRGF0YURldmljZVByb3h5LkVycm9yID0ge1xuICAvKipcbiAgICogZ2l2ZW4gd2xfc3VyZmFjZSBoYXMgYW5vdGhlciByb2xlXG4gICAqL1xuICByb2xlOiAwXG59XG5cbmV4cG9ydCBkZWZhdWx0IFdsRGF0YURldmljZVByb3h5XG4iLCIvKlxuICpcbiAqICAgIENvcHlyaWdodCDCqSAyMDA4LTIwMTEgS3Jpc3RpYW4gSMO4Z3NiZXJnXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMC0yMDExIEludGVsIENvcnBvcmF0aW9uXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMi0yMDEzIENvbGxhYm9yYSwgTHRkLlxuICpcbiAqICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICogICAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICogICAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAqICAgIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gKiAgICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogICAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgKGluY2x1ZGluZyB0aGVcbiAqICAgIG5leHQgcGFyYWdyYXBoKSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsXG4gKiAgICBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogICAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqICAgIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gKiAgICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAqICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gKiAgICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiAgICBTT0ZUV0FSRS5cbiAqICBcbiAqL1xuXG4vKipcbiAqIEBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2xEYXRhT2ZmZXJFdmVudHMge1xuXG5cdC8qKlxuXHQgKlxuXHQgKlx0U2VudCBpbW1lZGlhdGVseSBhZnRlciBjcmVhdGluZyB0aGUgd2xfZGF0YV9vZmZlciBvYmplY3QuICBPbmVcblx0ICpcdGV2ZW50IHBlciBvZmZlcmVkIG1pbWUgdHlwZS5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1pbWVUeXBlIG9mZmVyZWQgbWltZSB0eXBlIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0b2ZmZXIobWltZVR5cGUpIHt9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRUaGlzIGV2ZW50IGluZGljYXRlcyB0aGUgYWN0aW9ucyBvZmZlcmVkIGJ5IHRoZSBkYXRhIHNvdXJjZS4gSXRcblx0ICpcdHdpbGwgYmUgc2VudCByaWdodCBhZnRlciB3bF9kYXRhX2RldmljZS5lbnRlciwgb3IgYW55dGltZSB0aGUgc291cmNlXG5cdCAqXHRzaWRlIGNoYW5nZXMgaXRzIG9mZmVyZWQgYWN0aW9ucyB0aHJvdWdoIHdsX2RhdGFfc291cmNlLnNldF9hY3Rpb25zLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc291cmNlQWN0aW9ucyBhY3Rpb25zIG9mZmVyZWQgYnkgdGhlIGRhdGEgc291cmNlIFxuXHQgKlxuXHQgKiBAc2luY2UgM1xuXHQgKlxuXHQgKi9cblx0c291cmNlQWN0aW9ucyhzb3VyY2VBY3Rpb25zKSB7fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0VGhpcyBldmVudCBpbmRpY2F0ZXMgdGhlIGFjdGlvbiBzZWxlY3RlZCBieSB0aGUgY29tcG9zaXRvciBhZnRlclxuXHQgKlx0bWF0Y2hpbmcgdGhlIHNvdXJjZS9kZXN0aW5hdGlvbiBzaWRlIGFjdGlvbnMuIE9ubHkgb25lIGFjdGlvbiAob3Jcblx0ICpcdG5vbmUpIHdpbGwgYmUgb2ZmZXJlZCBoZXJlLlxuXHQgKlxuXHQgKlx0VGhpcyBldmVudCBjYW4gYmUgZW1pdHRlZCBtdWx0aXBsZSB0aW1lcyBkdXJpbmcgdGhlIGRyYWctYW5kLWRyb3Bcblx0ICpcdG9wZXJhdGlvbiBpbiByZXNwb25zZSB0byBkZXN0aW5hdGlvbiBzaWRlIGFjdGlvbiBjaGFuZ2VzIHRocm91Z2hcblx0ICpcdHdsX2RhdGFfb2ZmZXIuc2V0X2FjdGlvbnMuXG5cdCAqXG5cdCAqXHRUaGlzIGV2ZW50IHdpbGwgbm8gbG9uZ2VyIGJlIGVtaXR0ZWQgYWZ0ZXIgd2xfZGF0YV9kZXZpY2UuZHJvcFxuXHQgKlx0aGFwcGVuZWQgb24gdGhlIGRyYWctYW5kLWRyb3AgZGVzdGluYXRpb24sIHRoZSBjbGllbnQgbXVzdFxuXHQgKlx0aG9ub3IgdGhlIGxhc3QgYWN0aW9uIHJlY2VpdmVkLCBvciB0aGUgbGFzdCBwcmVmZXJyZWQgb25lIHNldFxuXHQgKlx0dGhyb3VnaCB3bF9kYXRhX29mZmVyLnNldF9hY3Rpb25zIHdoZW4gaGFuZGxpbmcgYW4gXCJhc2tcIiBhY3Rpb24uXG5cdCAqXG5cdCAqXHRDb21wb3NpdG9ycyBtYXkgYWxzbyBjaGFuZ2UgdGhlIHNlbGVjdGVkIGFjdGlvbiBvbiB0aGUgZmx5LCBtYWlubHlcblx0ICpcdGluIHJlc3BvbnNlIHRvIGtleWJvYXJkIG1vZGlmaWVyIGNoYW5nZXMgZHVyaW5nIHRoZSBkcmFnLWFuZC1kcm9wXG5cdCAqXHRvcGVyYXRpb24uXG5cdCAqXG5cdCAqXHRUaGUgbW9zdCByZWNlbnQgYWN0aW9uIHJlY2VpdmVkIGlzIGFsd2F5cyB0aGUgdmFsaWQgb25lLiBQcmlvciB0b1xuXHQgKlx0cmVjZWl2aW5nIHdsX2RhdGFfZGV2aWNlLmRyb3AsIHRoZSBjaG9zZW4gYWN0aW9uIG1heSBjaGFuZ2UgKGUuZy5cblx0ICpcdGR1ZSB0byBrZXlib2FyZCBtb2RpZmllcnMgYmVpbmcgcHJlc3NlZCkuIEF0IHRoZSB0aW1lIG9mIHJlY2VpdmluZ1xuXHQgKlx0d2xfZGF0YV9kZXZpY2UuZHJvcCB0aGUgZHJhZy1hbmQtZHJvcCBkZXN0aW5hdGlvbiBtdXN0IGhvbm9yIHRoZVxuXHQgKlx0bGFzdCBhY3Rpb24gcmVjZWl2ZWQuXG5cdCAqXG5cdCAqXHRBY3Rpb24gY2hhbmdlcyBtYXkgc3RpbGwgaGFwcGVuIGFmdGVyIHdsX2RhdGFfZGV2aWNlLmRyb3AsXG5cdCAqXHRlc3BlY2lhbGx5IG9uIFwiYXNrXCIgYWN0aW9ucywgd2hlcmUgdGhlIGRyYWctYW5kLWRyb3AgZGVzdGluYXRpb25cblx0ICpcdG1heSBjaG9vc2UgYW5vdGhlciBhY3Rpb24gYWZ0ZXJ3YXJkcy4gQWN0aW9uIGNoYW5nZXMgaGFwcGVuaW5nXG5cdCAqXHRhdCB0aGlzIHN0YWdlIGFyZSBhbHdheXMgdGhlIHJlc3VsdCBvZiBpbnRlci1jbGllbnQgbmVnb3RpYXRpb24sIHRoZVxuXHQgKlx0Y29tcG9zaXRvciBzaGFsbCBubyBsb25nZXIgYmUgYWJsZSB0byBpbmR1Y2UgYSBkaWZmZXJlbnQgYWN0aW9uLlxuXHQgKlxuXHQgKlx0VXBvbiBcImFza1wiIGFjdGlvbnMsIGl0IGlzIGV4cGVjdGVkIHRoYXQgdGhlIGRyYWctYW5kLWRyb3AgZGVzdGluYXRpb25cblx0ICpcdG1heSBwb3RlbnRpYWxseSBjaG9vc2UgYSBkaWZmZXJlbnQgYWN0aW9uIGFuZC9vciBtaW1lIHR5cGUsXG5cdCAqXHRiYXNlZCBvbiB3bF9kYXRhX29mZmVyLnNvdXJjZV9hY3Rpb25zIGFuZCBmaW5hbGx5IGNob3NlbiBieSB0aGVcblx0ICpcdHVzZXIgKGUuZy4gcG9wcGluZyB1cCBhIG1lbnUgd2l0aCB0aGUgYXZhaWxhYmxlIG9wdGlvbnMpLiBUaGVcblx0ICpcdGZpbmFsIHdsX2RhdGFfb2ZmZXIuc2V0X2FjdGlvbnMgYW5kIHdsX2RhdGFfb2ZmZXIuYWNjZXB0IHJlcXVlc3RzXG5cdCAqXHRtdXN0IGhhcHBlbiBiZWZvcmUgdGhlIGNhbGwgdG8gd2xfZGF0YV9vZmZlci5maW5pc2guXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkbmRBY3Rpb24gYWN0aW9uIHNlbGVjdGVkIGJ5IHRoZSBjb21wb3NpdG9yIFxuXHQgKlxuXHQgKiBAc2luY2UgM1xuXHQgKlxuXHQgKi9cblx0YWN0aW9uKGRuZEFjdGlvbikge31cbn1cblxuIiwiLypcbiAqXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAwOC0yMDExIEtyaXN0aWFuIEjDuGdzYmVyZ1xuICogICAgQ29weXJpZ2h0IMKpIDIwMTAtMjAxMSBJbnRlbCBDb3Jwb3JhdGlvblxuICogICAgQ29weXJpZ2h0IMKpIDIwMTItMjAxMyBDb2xsYWJvcmEsIEx0ZC5cbiAqXG4gKiAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAqICAgICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAqICAgIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gKiAgICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICogICAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAqICAgIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIChpbmNsdWRpbmcgdGhlXG4gKiAgICBuZXh0IHBhcmFncmFwaCkgc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbFxuICogICAgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAqICAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiAgICBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICogICAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gKiAgICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICogICAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogICAgU09GVFdBUkUuXG4gKiAgXG4gKi9cblxuaW1wb3J0IHsgQ29ubmVjdGlvbiB9IGZyb20gJ3dlc3RmaWVsZC1ydW50aW1lLWNvbW1vbidcbmNvbnN0IHsgdWludCwgdWludE9wdGlvbmFsLCBpbnQsIGludE9wdGlvbmFsLCBmaXhlZCwgXG5cdGZpeGVkT3B0aW9uYWwsIG9iamVjdCwgb2JqZWN0T3B0aW9uYWwsIG5ld09iamVjdCwgc3RyaW5nLCBcblx0c3RyaW5nT3B0aW9uYWwsIGFycmF5LCBhcnJheU9wdGlvbmFsLCBcblx0ZmlsZURlc2NyaXB0b3JPcHRpb25hbCwgZmlsZURlc2NyaXB0b3IsIFxuaCwgdSwgaSwgZiwgbywgbiwgcywgYSB9ID0gQ29ubmVjdGlvblxuaW1wb3J0IFByb3h5IGZyb20gJy4vUHJveHknXG5cbi8qKlxuICpcbiAqICAgICAgQSB3bF9kYXRhX29mZmVyIHJlcHJlc2VudHMgYSBwaWVjZSBvZiBkYXRhIG9mZmVyZWQgZm9yIHRyYW5zZmVyXG4gKiAgICAgIGJ5IGFub3RoZXIgY2xpZW50ICh0aGUgc291cmNlIGNsaWVudCkuICBJdCBpcyB1c2VkIGJ5IHRoZVxuICogICAgICBjb3B5LWFuZC1wYXN0ZSBhbmQgZHJhZy1hbmQtZHJvcCBtZWNoYW5pc21zLiAgVGhlIG9mZmVyXG4gKiAgICAgIGRlc2NyaWJlcyB0aGUgZGlmZmVyZW50IG1pbWUgdHlwZXMgdGhhdCB0aGUgZGF0YSBjYW4gYmVcbiAqICAgICAgY29udmVydGVkIHRvIGFuZCBwcm92aWRlcyB0aGUgbWVjaGFuaXNtIGZvciB0cmFuc2ZlcnJpbmcgdGhlXG4gKiAgICAgIGRhdGEgZGlyZWN0bHkgZnJvbSB0aGUgc291cmNlIGNsaWVudC5cbiAqICAgIFxuICovXG5jbGFzcyBXbERhdGFPZmZlclByb3h5IGV4dGVuZHMgUHJveHkge1xuXG5cdC8qKlxuXHQgKlxuXHQgKlx0SW5kaWNhdGUgdGhhdCB0aGUgY2xpZW50IGNhbiBhY2NlcHQgdGhlIGdpdmVuIG1pbWUgdHlwZSwgb3Jcblx0ICpcdE5VTEwgZm9yIG5vdCBhY2NlcHRlZC5cblx0ICpcblx0ICpcdEZvciBvYmplY3RzIG9mIHZlcnNpb24gMiBvciBvbGRlciwgdGhpcyByZXF1ZXN0IGlzIHVzZWQgYnkgdGhlXG5cdCAqXHRjbGllbnQgdG8gZ2l2ZSBmZWVkYmFjayB3aGV0aGVyIHRoZSBjbGllbnQgY2FuIHJlY2VpdmUgdGhlIGdpdmVuXG5cdCAqXHRtaW1lIHR5cGUsIG9yIE5VTEwgaWYgbm9uZSBpcyBhY2NlcHRlZDsgdGhlIGZlZWRiYWNrIGRvZXMgbm90XG5cdCAqXHRkZXRlcm1pbmUgd2hldGhlciB0aGUgZHJhZy1hbmQtZHJvcCBvcGVyYXRpb24gc3VjY2VlZHMgb3Igbm90LlxuXHQgKlxuXHQgKlx0Rm9yIG9iamVjdHMgb2YgdmVyc2lvbiAzIG9yIG5ld2VyLCB0aGlzIHJlcXVlc3QgZGV0ZXJtaW5lcyB0aGVcblx0ICpcdGZpbmFsIHJlc3VsdCBvZiB0aGUgZHJhZy1hbmQtZHJvcCBvcGVyYXRpb24uIElmIHRoZSBlbmQgcmVzdWx0XG5cdCAqXHRpcyB0aGF0IG5vIG1pbWUgdHlwZXMgd2VyZSBhY2NlcHRlZCwgdGhlIGRyYWctYW5kLWRyb3Agb3BlcmF0aW9uXG5cdCAqXHR3aWxsIGJlIGNhbmNlbGxlZCBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgZHJhZyBzb3VyY2Ugd2lsbCByZWNlaXZlXG5cdCAqXHR3bF9kYXRhX3NvdXJjZS5jYW5jZWxsZWQuIENsaWVudHMgbWF5IHN0aWxsIHVzZSB0aGlzIGV2ZW50IGluXG5cdCAqXHRjb25qdW5jdGlvbiB3aXRoIHdsX2RhdGFfc291cmNlLmFjdGlvbiBmb3IgZmVlZGJhY2suXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzZXJpYWwgc2VyaWFsIG51bWJlciBvZiB0aGUgYWNjZXB0IHJlcXVlc3QgXG5cdCAqIEBwYXJhbSB7P3N0cmluZ30gbWltZVR5cGUgbWltZSB0eXBlIGFjY2VwdGVkIGJ5IHRoZSBjbGllbnQgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRhY2NlcHQgKHNlcmlhbCwgbWltZVR5cGUpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCAwLCBbdWludChzZXJpYWwpLCBzdHJpbmdPcHRpb25hbChtaW1lVHlwZSldKVxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRUbyB0cmFuc2ZlciB0aGUgb2ZmZXJlZCBkYXRhLCB0aGUgY2xpZW50IGlzc3VlcyB0aGlzIHJlcXVlc3Rcblx0ICpcdGFuZCBpbmRpY2F0ZXMgdGhlIG1pbWUgdHlwZSBpdCB3YW50cyB0byByZWNlaXZlLiAgVGhlIHRyYW5zZmVyXG5cdCAqXHRoYXBwZW5zIHRocm91Z2ggdGhlIHBhc3NlZCBmaWxlIGRlc2NyaXB0b3IgKHR5cGljYWxseSBjcmVhdGVkXG5cdCAqXHR3aXRoIHRoZSBwaXBlIHN5c3RlbSBjYWxsKS4gIFRoZSBzb3VyY2UgY2xpZW50IHdyaXRlcyB0aGUgZGF0YVxuXHQgKlx0aW4gdGhlIG1pbWUgdHlwZSByZXByZXNlbnRhdGlvbiByZXF1ZXN0ZWQgYW5kIHRoZW4gY2xvc2VzIHRoZVxuXHQgKlx0ZmlsZSBkZXNjcmlwdG9yLlxuXHQgKlxuXHQgKlx0VGhlIHJlY2VpdmluZyBjbGllbnQgcmVhZHMgZnJvbSB0aGUgcmVhZCBlbmQgb2YgdGhlIHBpcGUgdW50aWxcblx0ICpcdEVPRiBhbmQgdGhlbiBjbG9zZXMgaXRzIGVuZCwgYXQgd2hpY2ggcG9pbnQgdGhlIHRyYW5zZmVyIGlzXG5cdCAqXHRjb21wbGV0ZS5cblx0ICpcblx0ICpcdFRoaXMgcmVxdWVzdCBtYXkgaGFwcGVuIG11bHRpcGxlIHRpbWVzIGZvciBkaWZmZXJlbnQgbWltZSB0eXBlcyxcblx0ICpcdGJvdGggYmVmb3JlIGFuZCBhZnRlciB3bF9kYXRhX2RldmljZS5kcm9wLiBEcmFnLWFuZC1kcm9wIGRlc3RpbmF0aW9uXG5cdCAqXHRjbGllbnRzIG1heSBwcmVlbXB0aXZlbHkgZmV0Y2ggZGF0YSBvciBleGFtaW5lIGl0IG1vcmUgY2xvc2VseSB0b1xuXHQgKlx0ZGV0ZXJtaW5lIGFjY2VwdGFuY2UuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtaW1lVHlwZSBtaW1lIHR5cGUgZGVzaXJlZCBieSByZWNlaXZlciBcblx0ICogQHBhcmFtIHtXZWJGRH0gZmQgZmlsZSBkZXNjcmlwdG9yIGZvciBkYXRhIHRyYW5zZmVyIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0cmVjZWl2ZSAobWltZVR5cGUsIGZkKSB7XG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgMSwgW3N0cmluZyhtaW1lVHlwZSksIGZpbGVEZXNjcmlwdG9yKGZkKV0pXG5cdH1cblxuXHQvKipcblx0ICpcblx0ICpcdERlc3Ryb3kgdGhlIGRhdGEgb2ZmZXIuXG5cdCAqICAgICAgXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRkZXN0cm95ICgpIHtcblx0XHRzdXBlci5kZXN0cm95KClcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCAyLCBbXSlcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0Tm90aWZpZXMgdGhlIGNvbXBvc2l0b3IgdGhhdCB0aGUgZHJhZyBkZXN0aW5hdGlvbiBzdWNjZXNzZnVsbHlcblx0ICpcdGZpbmlzaGVkIHRoZSBkcmFnLWFuZC1kcm9wIG9wZXJhdGlvbi5cblx0ICpcblx0ICpcdFVwb24gcmVjZWl2aW5nIHRoaXMgcmVxdWVzdCwgdGhlIGNvbXBvc2l0b3Igd2lsbCBlbWl0XG5cdCAqXHR3bF9kYXRhX3NvdXJjZS5kbmRfZmluaXNoZWQgb24gdGhlIGRyYWcgc291cmNlIGNsaWVudC5cblx0ICpcblx0ICpcdEl0IGlzIGEgY2xpZW50IGVycm9yIHRvIHBlcmZvcm0gb3RoZXIgcmVxdWVzdHMgdGhhblxuXHQgKlx0d2xfZGF0YV9vZmZlci5kZXN0cm95IGFmdGVyIHRoaXMgb25lLiBJdCBpcyBhbHNvIGFuIGVycm9yIHRvIHBlcmZvcm1cblx0ICpcdHRoaXMgcmVxdWVzdCBhZnRlciBhIE5VTEwgbWltZSB0eXBlIGhhcyBiZWVuIHNldCBpblxuXHQgKlx0d2xfZGF0YV9vZmZlci5hY2NlcHQgb3Igbm8gYWN0aW9uIHdhcyByZWNlaXZlZCB0aHJvdWdoXG5cdCAqXHR3bF9kYXRhX29mZmVyLmFjdGlvbi5cblx0ICogICAgICBcblx0ICogQHNpbmNlIDNcblx0ICpcblx0ICovXG5cdGZpbmlzaCAoKSB7XG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgMywgW10pXG5cdH1cblxuXHQvKipcblx0ICpcblx0ICpcdFNldHMgdGhlIGFjdGlvbnMgdGhhdCB0aGUgZGVzdGluYXRpb24gc2lkZSBjbGllbnQgc3VwcG9ydHMgZm9yXG5cdCAqXHR0aGlzIG9wZXJhdGlvbi4gVGhpcyByZXF1ZXN0IG1heSB0cmlnZ2VyIHRoZSBlbWlzc2lvbiBvZlxuXHQgKlx0d2xfZGF0YV9zb3VyY2UuYWN0aW9uIGFuZCB3bF9kYXRhX29mZmVyLmFjdGlvbiBldmVudHMgaWYgdGhlIGNvbXBvc2l0b3Jcblx0ICpcdG5lZWRzIHRvIGNoYW5nZSB0aGUgc2VsZWN0ZWQgYWN0aW9uLlxuXHQgKlxuXHQgKlx0VGhpcyByZXF1ZXN0IGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgdGhyb3VnaG91dCB0aGVcblx0ICpcdGRyYWctYW5kLWRyb3Agb3BlcmF0aW9uLCB0eXBpY2FsbHkgaW4gcmVzcG9uc2UgdG8gd2xfZGF0YV9kZXZpY2UuZW50ZXJcblx0ICpcdG9yIHdsX2RhdGFfZGV2aWNlLm1vdGlvbiBldmVudHMuXG5cdCAqXG5cdCAqXHRUaGlzIHJlcXVlc3QgZGV0ZXJtaW5lcyB0aGUgZmluYWwgcmVzdWx0IG9mIHRoZSBkcmFnLWFuZC1kcm9wXG5cdCAqXHRvcGVyYXRpb24uIElmIHRoZSBlbmQgcmVzdWx0IGlzIHRoYXQgbm8gYWN0aW9uIGlzIGFjY2VwdGVkLFxuXHQgKlx0dGhlIGRyYWcgc291cmNlIHdpbGwgcmVjZWl2ZSB3bF9kcmFnX3NvdXJjZS5jYW5jZWxsZWQuXG5cdCAqXG5cdCAqXHRUaGUgZG5kX2FjdGlvbnMgYXJndW1lbnQgbXVzdCBjb250YWluIG9ubHkgdmFsdWVzIGV4cHJlc3NlZCBpbiB0aGVcblx0ICpcdHdsX2RhdGFfZGV2aWNlX21hbmFnZXIuZG5kX2FjdGlvbnMgZW51bSwgYW5kIHRoZSBwcmVmZXJyZWRfYWN0aW9uXG5cdCAqXHRhcmd1bWVudCBtdXN0IG9ubHkgY29udGFpbiBvbmUgb2YgdGhvc2UgdmFsdWVzIHNldCwgb3RoZXJ3aXNlIGl0XG5cdCAqXHR3aWxsIHJlc3VsdCBpbiBhIHByb3RvY29sIGVycm9yLlxuXHQgKlxuXHQgKlx0V2hpbGUgbWFuYWdpbmcgYW4gXCJhc2tcIiBhY3Rpb24sIHRoZSBkZXN0aW5hdGlvbiBkcmFnLWFuZC1kcm9wIGNsaWVudFxuXHQgKlx0bWF5IHBlcmZvcm0gZnVydGhlciB3bF9kYXRhX29mZmVyLnJlY2VpdmUgcmVxdWVzdHMsIGFuZCBpcyBleHBlY3RlZFxuXHQgKlx0dG8gcGVyZm9ybSBvbmUgbGFzdCB3bF9kYXRhX29mZmVyLnNldF9hY3Rpb25zIHJlcXVlc3Qgd2l0aCBhIHByZWZlcnJlZFxuXHQgKlx0YWN0aW9uIG90aGVyIHRoYW4gXCJhc2tcIiAoYW5kIG9wdGlvbmFsbHkgd2xfZGF0YV9vZmZlci5hY2NlcHQpIGJlZm9yZVxuXHQgKlx0cmVxdWVzdGluZyB3bF9kYXRhX29mZmVyLmZpbmlzaCwgaW4gb3JkZXIgdG8gY29udmV5IHRoZSBhY3Rpb24gc2VsZWN0ZWRcblx0ICpcdGJ5IHRoZSB1c2VyLiBJZiB0aGUgcHJlZmVycmVkIGFjdGlvbiBpcyBub3QgaW4gdGhlXG5cdCAqXHR3bF9kYXRhX29mZmVyLnNvdXJjZV9hY3Rpb25zIG1hc2ssIGFuIGVycm9yIHdpbGwgYmUgcmFpc2VkLlxuXHQgKlxuXHQgKlx0SWYgdGhlIFwiYXNrXCIgYWN0aW9uIGlzIGRpc21pc3NlZCAoZS5nLiB1c2VyIGNhbmNlbGxhdGlvbiksIHRoZSBjbGllbnRcblx0ICpcdGlzIGV4cGVjdGVkIHRvIHBlcmZvcm0gd2xfZGF0YV9vZmZlci5kZXN0cm95IHJpZ2h0IGF3YXkuXG5cdCAqXG5cdCAqXHRUaGlzIHJlcXVlc3QgY2FuIG9ubHkgYmUgbWFkZSBvbiBkcmFnLWFuZC1kcm9wIG9mZmVycywgYSBwcm90b2NvbCBlcnJvclxuXHQgKlx0d2lsbCBiZSByYWlzZWQgb3RoZXJ3aXNlLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZG5kQWN0aW9ucyBhY3Rpb25zIHN1cHBvcnRlZCBieSB0aGUgZGVzdGluYXRpb24gY2xpZW50IFxuXHQgKiBAcGFyYW0ge251bWJlcn0gcHJlZmVycmVkQWN0aW9uIGFjdGlvbiBwcmVmZXJyZWQgYnkgdGhlIGRlc3RpbmF0aW9uIGNsaWVudCBcblx0ICpcblx0ICogQHNpbmNlIDNcblx0ICpcblx0ICovXG5cdHNldEFjdGlvbnMgKGRuZEFjdGlvbnMsIHByZWZlcnJlZEFjdGlvbikge1xuXHRcdHRoaXMuX21hcnNoYWxsKHRoaXMuaWQsIDQsIFt1aW50KGRuZEFjdGlvbnMpLCB1aW50KHByZWZlcnJlZEFjdGlvbildKVxuXHR9XG5cblx0LyoqXG5cdCAqIERvIG5vdCBjb25zdHJ1Y3QgcHJveGllcyBkaXJlY3RseS4gSW5zdGVhZCB1c2Ugb25lIG9mIHRoZSBmYWN0b3J5IG1ldGhvZHMgZnJvbSBvdGhlciBwcm94aWVzLlxuXHQgKkBwYXJhbSB7RGlzcGxheX1kaXNwbGF5XG5cdCAqQHBhcmFtIHtDb25uZWN0aW9ufWNvbm5lY3Rpb25cblx0ICpAcGFyYW0ge251bWJlcn1pZFxuXHQgKi9cblx0Y29uc3RydWN0b3IgKGRpc3BsYXksIGNvbm5lY3Rpb24sIGlkKSB7XG5cdFx0c3VwZXIoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge1dsRGF0YU9mZmVyRXZlbnRzfG51bGx9XG5cdFx0ICovXG5cdFx0dGhpcy5saXN0ZW5lciA9IG51bGxcblx0fVxuXG5cdGFzeW5jIFswXSAobWVzc2FnZSkge1xuXHRcdGF3YWl0IHRoaXMubGlzdGVuZXIub2ZmZXIocyhtZXNzYWdlLCBmYWxzZSkpXG5cdH1cblxuXHRhc3luYyBbMV0gKG1lc3NhZ2UpIHtcblx0XHRhd2FpdCB0aGlzLmxpc3RlbmVyLnNvdXJjZUFjdGlvbnModShtZXNzYWdlKSlcblx0fVxuXG5cdGFzeW5jIFsyXSAobWVzc2FnZSkge1xuXHRcdGF3YWl0IHRoaXMubGlzdGVuZXIuYWN0aW9uKHUobWVzc2FnZSkpXG5cdH1cblxufVxuV2xEYXRhT2ZmZXJQcm94eS5wcm90b2NvbE5hbWUgPSAnd2xfZGF0YV9vZmZlcidcblxuV2xEYXRhT2ZmZXJQcm94eS5FcnJvciA9IHtcbiAgLyoqXG4gICAqIGZpbmlzaCByZXF1ZXN0IHdhcyBjYWxsZWQgdW50aW1lbHlcbiAgICovXG4gIGludmFsaWRGaW5pc2g6IDAsXG4gIC8qKlxuICAgKiBhY3Rpb24gbWFzayBjb250YWlucyBpbnZhbGlkIHZhbHVlc1xuICAgKi9cbiAgaW52YWxpZEFjdGlvbk1hc2s6IDEsXG4gIC8qKlxuICAgKiBhY3Rpb24gYXJndW1lbnQgaGFzIGFuIGludmFsaWQgdmFsdWVcbiAgICovXG4gIGludmFsaWRBY3Rpb246IDIsXG4gIC8qKlxuICAgKiBvZmZlciBkb2Vzbid0IGFjY2VwdCB0aGlzIHJlcXVlc3RcbiAgICovXG4gIGludmFsaWRPZmZlcjogM1xufVxuXG5leHBvcnQgZGVmYXVsdCBXbERhdGFPZmZlclByb3h5XG4iLCIvKlxuICpcbiAqICAgIENvcHlyaWdodCDCqSAyMDA4LTIwMTEgS3Jpc3RpYW4gSMO4Z3NiZXJnXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMC0yMDExIEludGVsIENvcnBvcmF0aW9uXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMi0yMDEzIENvbGxhYm9yYSwgTHRkLlxuICpcbiAqICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICogICAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICogICAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAqICAgIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gKiAgICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogICAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgKGluY2x1ZGluZyB0aGVcbiAqICAgIG5leHQgcGFyYWdyYXBoKSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsXG4gKiAgICBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogICAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqICAgIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gKiAgICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAqICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gKiAgICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiAgICBTT0ZUV0FSRS5cbiAqICBcbiAqL1xuXG4vKipcbiAqIEBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2xEYXRhU291cmNlRXZlbnRzIHtcblxuXHQvKipcblx0ICpcblx0ICpcdFNlbnQgd2hlbiBhIHRhcmdldCBhY2NlcHRzIHBvaW50ZXJfZm9jdXMgb3IgbW90aW9uIGV2ZW50cy4gIElmXG5cdCAqXHRhIHRhcmdldCBkb2VzIG5vdCBhY2NlcHQgYW55IG9mIHRoZSBvZmZlcmVkIHR5cGVzLCB0eXBlIGlzIE5VTEwuXG5cdCAqXG5cdCAqXHRVc2VkIGZvciBmZWVkYmFjayBkdXJpbmcgZHJhZy1hbmQtZHJvcC5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHs/c3RyaW5nfSBtaW1lVHlwZSBtaW1lIHR5cGUgYWNjZXB0ZWQgYnkgdGhlIHRhcmdldCBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdHRhcmdldChtaW1lVHlwZSkge31cblxuXHQvKipcblx0ICpcblx0ICpcdFJlcXVlc3QgZm9yIGRhdGEgZnJvbSB0aGUgY2xpZW50LiAgU2VuZCB0aGUgZGF0YSBhcyB0aGVcblx0ICpcdHNwZWNpZmllZCBtaW1lIHR5cGUgb3ZlciB0aGUgcGFzc2VkIGZpbGUgZGVzY3JpcHRvciwgdGhlblxuXHQgKlx0Y2xvc2UgaXQuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtaW1lVHlwZSBtaW1lIHR5cGUgZm9yIHRoZSBkYXRhIFxuXHQgKiBAcGFyYW0ge1dlYkZEfSBmZCBmaWxlIGRlc2NyaXB0b3IgZm9yIHRoZSBkYXRhIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0c2VuZChtaW1lVHlwZSwgZmQpIHt9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRUaGlzIGRhdGEgc291cmNlIGlzIG5vIGxvbmdlciB2YWxpZC4gVGhlcmUgYXJlIHNldmVyYWwgcmVhc29ucyB3aHlcblx0ICpcdHRoaXMgY291bGQgaGFwcGVuOlxuXHQgKlxuXHQgKlx0LSBUaGUgZGF0YSBzb3VyY2UgaGFzIGJlZW4gcmVwbGFjZWQgYnkgYW5vdGhlciBkYXRhIHNvdXJjZS5cblx0ICpcdC0gVGhlIGRyYWctYW5kLWRyb3Agb3BlcmF0aW9uIHdhcyBwZXJmb3JtZWQsIGJ1dCB0aGUgZHJvcCBkZXN0aW5hdGlvblxuXHQgKlx0ICBkaWQgbm90IGFjY2VwdCBhbnkgb2YgdGhlIG1pbWUgdHlwZXMgb2ZmZXJlZCB0aHJvdWdoXG5cdCAqXHQgIHdsX2RhdGFfc291cmNlLnRhcmdldC5cblx0ICpcdC0gVGhlIGRyYWctYW5kLWRyb3Agb3BlcmF0aW9uIHdhcyBwZXJmb3JtZWQsIGJ1dCB0aGUgZHJvcCBkZXN0aW5hdGlvblxuXHQgKlx0ICBkaWQgbm90IHNlbGVjdCBhbnkgb2YgdGhlIGFjdGlvbnMgcHJlc2VudCBpbiB0aGUgbWFzayBvZmZlcmVkIHRocm91Z2hcblx0ICpcdCAgd2xfZGF0YV9zb3VyY2UuYWN0aW9uLlxuXHQgKlx0LSBUaGUgZHJhZy1hbmQtZHJvcCBvcGVyYXRpb24gd2FzIHBlcmZvcm1lZCBidXQgZGlkbid0IGhhcHBlbiBvdmVyIGFcblx0ICpcdCAgc3VyZmFjZS5cblx0ICpcdC0gVGhlIGNvbXBvc2l0b3IgY2FuY2VsbGVkIHRoZSBkcmFnLWFuZC1kcm9wIG9wZXJhdGlvbiAoZS5nLiBjb21wb3NpdG9yXG5cdCAqXHQgIGRlcGVuZGVudCB0aW1lb3V0cyB0byBhdm9pZCBzdGFsZSBkcmFnLWFuZC1kcm9wIHRyYW5zZmVycykuXG5cdCAqXG5cdCAqXHRUaGUgY2xpZW50IHNob3VsZCBjbGVhbiB1cCBhbmQgZGVzdHJveSB0aGlzIGRhdGEgc291cmNlLlxuXHQgKlxuXHQgKlx0Rm9yIG9iamVjdHMgb2YgdmVyc2lvbiAyIG9yIG9sZGVyLCB3bF9kYXRhX3NvdXJjZS5jYW5jZWxsZWQgd2lsbFxuXHQgKlx0b25seSBiZSBlbWl0dGVkIGlmIHRoZSBkYXRhIHNvdXJjZSB3YXMgcmVwbGFjZWQgYnkgYW5vdGhlciBkYXRhXG5cdCAqXHRzb3VyY2UuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRjYW5jZWxsZWQoKSB7fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0VGhlIHVzZXIgcGVyZm9ybWVkIHRoZSBkcm9wIGFjdGlvbi4gVGhpcyBldmVudCBkb2VzIG5vdCBpbmRpY2F0ZVxuXHQgKlx0YWNjZXB0YW5jZSwgd2xfZGF0YV9zb3VyY2UuY2FuY2VsbGVkIG1heSBzdGlsbCBiZSBlbWl0dGVkIGFmdGVyd2FyZHNcblx0ICpcdGlmIHRoZSBkcm9wIGRlc3RpbmF0aW9uIGRvZXMgbm90IGFjY2VwdCBhbnkgbWltZSB0eXBlLlxuXHQgKlxuXHQgKlx0SG93ZXZlciwgdGhpcyBldmVudCBtaWdodCBob3dldmVyIG5vdCBiZSByZWNlaXZlZCBpZiB0aGUgY29tcG9zaXRvclxuXHQgKlx0Y2FuY2VsbGVkIHRoZSBkcmFnLWFuZC1kcm9wIG9wZXJhdGlvbiBiZWZvcmUgdGhpcyBldmVudCBjb3VsZCBoYXBwZW4uXG5cdCAqXG5cdCAqXHROb3RlIHRoYXQgdGhlIGRhdGFfc291cmNlIG1heSBzdGlsbCBiZSB1c2VkIGluIHRoZSBmdXR1cmUgYW5kIHNob3VsZFxuXHQgKlx0bm90IGJlIGRlc3Ryb3llZCBoZXJlLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKlxuXHQgKiBAc2luY2UgM1xuXHQgKlxuXHQgKi9cblx0ZG5kRHJvcFBlcmZvcm1lZCgpIHt9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRUaGUgZHJvcCBkZXN0aW5hdGlvbiBmaW5pc2hlZCBpbnRlcm9wZXJhdGluZyB3aXRoIHRoaXMgZGF0YVxuXHQgKlx0c291cmNlLCBzbyB0aGUgY2xpZW50IGlzIG5vdyBmcmVlIHRvIGRlc3Ryb3kgdGhpcyBkYXRhIHNvdXJjZSBhbmRcblx0ICpcdGZyZWUgYWxsIGFzc29jaWF0ZWQgZGF0YS5cblx0ICpcblx0ICpcdElmIHRoZSBhY3Rpb24gdXNlZCB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb24gd2FzIFwibW92ZVwiLCB0aGVcblx0ICpcdHNvdXJjZSBjYW4gbm93IGRlbGV0ZSB0aGUgdHJhbnNmZXJyZWQgZGF0YS5cblx0ICogICAgICBcblx0ICpcblx0ICpcblx0ICogQHNpbmNlIDNcblx0ICpcblx0ICovXG5cdGRuZEZpbmlzaGVkKCkge31cblxuXHQvKipcblx0ICpcblx0ICpcdFRoaXMgZXZlbnQgaW5kaWNhdGVzIHRoZSBhY3Rpb24gc2VsZWN0ZWQgYnkgdGhlIGNvbXBvc2l0b3IgYWZ0ZXJcblx0ICpcdG1hdGNoaW5nIHRoZSBzb3VyY2UvZGVzdGluYXRpb24gc2lkZSBhY3Rpb25zLiBPbmx5IG9uZSBhY3Rpb24gKG9yXG5cdCAqXHRub25lKSB3aWxsIGJlIG9mZmVyZWQgaGVyZS5cblx0ICpcblx0ICpcdFRoaXMgZXZlbnQgY2FuIGJlIGVtaXR0ZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIHRoZSBkcmFnLWFuZC1kcm9wXG5cdCAqXHRvcGVyYXRpb24sIG1haW5seSBpbiByZXNwb25zZSB0byBkZXN0aW5hdGlvbiBzaWRlIGNoYW5nZXMgdGhyb3VnaFxuXHQgKlx0d2xfZGF0YV9vZmZlci5zZXRfYWN0aW9ucywgYW5kIGFzIHRoZSBkYXRhIGRldmljZSBlbnRlcnMvbGVhdmVzXG5cdCAqXHRzdXJmYWNlcy5cblx0ICpcblx0ICpcdEl0IGlzIG9ubHkgcG9zc2libGUgdG8gcmVjZWl2ZSB0aGlzIGV2ZW50IGFmdGVyXG5cdCAqXHR3bF9kYXRhX3NvdXJjZS5kbmRfZHJvcF9wZXJmb3JtZWQgaWYgdGhlIGRyYWctYW5kLWRyb3Agb3BlcmF0aW9uXG5cdCAqXHRlbmRlZCBpbiBhbiBcImFza1wiIGFjdGlvbiwgaW4gd2hpY2ggY2FzZSB0aGUgZmluYWwgd2xfZGF0YV9zb3VyY2UuYWN0aW9uXG5cdCAqXHRldmVudCB3aWxsIGhhcHBlbiBpbW1lZGlhdGVseSBiZWZvcmUgd2xfZGF0YV9zb3VyY2UuZG5kX2ZpbmlzaGVkLlxuXHQgKlxuXHQgKlx0Q29tcG9zaXRvcnMgbWF5IGFsc28gY2hhbmdlIHRoZSBzZWxlY3RlZCBhY3Rpb24gb24gdGhlIGZseSwgbWFpbmx5XG5cdCAqXHRpbiByZXNwb25zZSB0byBrZXlib2FyZCBtb2RpZmllciBjaGFuZ2VzIGR1cmluZyB0aGUgZHJhZy1hbmQtZHJvcFxuXHQgKlx0b3BlcmF0aW9uLlxuXHQgKlxuXHQgKlx0VGhlIG1vc3QgcmVjZW50IGFjdGlvbiByZWNlaXZlZCBpcyBhbHdheXMgdGhlIHZhbGlkIG9uZS4gVGhlIGNob3NlblxuXHQgKlx0YWN0aW9uIG1heSBjaGFuZ2UgYWxvbmdzaWRlIG5lZ290aWF0aW9uIChlLmcuIGFuIFwiYXNrXCIgYWN0aW9uIGNhbiB0dXJuXG5cdCAqXHRpbnRvIGEgXCJtb3ZlXCIgb3BlcmF0aW9uKSwgc28gdGhlIGVmZmVjdHMgb2YgdGhlIGZpbmFsIGFjdGlvbiBtdXN0XG5cdCAqXHRhbHdheXMgYmUgYXBwbGllZCBpbiB3bF9kYXRhX29mZmVyLmRuZF9maW5pc2hlZC5cblx0ICpcblx0ICpcdENsaWVudHMgY2FuIHRyaWdnZXIgY3Vyc29yIHN1cmZhY2UgY2hhbmdlcyBmcm9tIHRoaXMgcG9pbnQsIHNvXG5cdCAqXHR0aGV5IHJlZmxlY3QgdGhlIGN1cnJlbnQgYWN0aW9uLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZG5kQWN0aW9uIGFjdGlvbiBzZWxlY3RlZCBieSB0aGUgY29tcG9zaXRvciBcblx0ICpcblx0ICogQHNpbmNlIDNcblx0ICpcblx0ICovXG5cdGFjdGlvbihkbmRBY3Rpb24pIHt9XG59XG5cbiIsIi8qXG4gKlxuICogICAgQ29weXJpZ2h0IMKpIDIwMDgtMjAxMSBLcmlzdGlhbiBIw7hnc2JlcmdcbiAqICAgIENvcHlyaWdodCDCqSAyMDEwLTIwMTEgSW50ZWwgQ29ycG9yYXRpb25cbiAqICAgIENvcHlyaWdodCDCqSAyMDEyLTIwMTMgQ29sbGFib3JhLCBMdGQuXG4gKlxuICogICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gKiAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSAoaW5jbHVkaW5nIHRoZVxuICogICAgbmV4dCBwYXJhZ3JhcGgpIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWxcbiAqICAgIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogICAgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAqICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICogICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAqICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqICAgIFNPRlRXQVJFLlxuICogIFxuICovXG5cbmltcG9ydCB7IENvbm5lY3Rpb24gfSBmcm9tICd3ZXN0ZmllbGQtcnVudGltZS1jb21tb24nXG5jb25zdCB7IHVpbnQsIHVpbnRPcHRpb25hbCwgaW50LCBpbnRPcHRpb25hbCwgZml4ZWQsIFxuXHRmaXhlZE9wdGlvbmFsLCBvYmplY3QsIG9iamVjdE9wdGlvbmFsLCBuZXdPYmplY3QsIHN0cmluZywgXG5cdHN0cmluZ09wdGlvbmFsLCBhcnJheSwgYXJyYXlPcHRpb25hbCwgXG5cdGZpbGVEZXNjcmlwdG9yT3B0aW9uYWwsIGZpbGVEZXNjcmlwdG9yLCBcbmgsIHUsIGksIGYsIG8sIG4sIHMsIGEgfSA9IENvbm5lY3Rpb25cbmltcG9ydCBQcm94eSBmcm9tICcuL1Byb3h5J1xuXG4vKipcbiAqXG4gKiAgICAgIFRoZSB3bF9kYXRhX3NvdXJjZSBvYmplY3QgaXMgdGhlIHNvdXJjZSBzaWRlIG9mIGEgd2xfZGF0YV9vZmZlci5cbiAqICAgICAgSXQgaXMgY3JlYXRlZCBieSB0aGUgc291cmNlIGNsaWVudCBpbiBhIGRhdGEgdHJhbnNmZXIgYW5kXG4gKiAgICAgIHByb3ZpZGVzIGEgd2F5IHRvIGRlc2NyaWJlIHRoZSBvZmZlcmVkIGRhdGEgYW5kIGEgd2F5IHRvIHJlc3BvbmRcbiAqICAgICAgdG8gcmVxdWVzdHMgdG8gdHJhbnNmZXIgdGhlIGRhdGEuXG4gKiAgICBcbiAqL1xuY2xhc3MgV2xEYXRhU291cmNlUHJveHkgZXh0ZW5kcyBQcm94eSB7XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRUaGlzIHJlcXVlc3QgYWRkcyBhIG1pbWUgdHlwZSB0byB0aGUgc2V0IG9mIG1pbWUgdHlwZXNcblx0ICpcdGFkdmVydGlzZWQgdG8gdGFyZ2V0cy4gIENhbiBiZSBjYWxsZWQgc2V2ZXJhbCB0aW1lcyB0byBvZmZlclxuXHQgKlx0bXVsdGlwbGUgdHlwZXMuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtaW1lVHlwZSBtaW1lIHR5cGUgb2ZmZXJlZCBieSB0aGUgZGF0YSBzb3VyY2UgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRvZmZlciAobWltZVR5cGUpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCAwLCBbc3RyaW5nKG1pbWVUeXBlKV0pXG5cdH1cblxuXHQvKipcblx0ICpcblx0ICpcdERlc3Ryb3kgdGhlIGRhdGEgc291cmNlLlxuXHQgKiAgICAgIFxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0ZGVzdHJveSAoKSB7XG5cdFx0c3VwZXIuZGVzdHJveSgpXG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgMSwgW10pXG5cdH1cblxuXHQvKipcblx0ICpcblx0ICpcdFNldHMgdGhlIGFjdGlvbnMgdGhhdCB0aGUgc291cmNlIHNpZGUgY2xpZW50IHN1cHBvcnRzIGZvciB0aGlzXG5cdCAqXHRvcGVyYXRpb24uIFRoaXMgcmVxdWVzdCBtYXkgdHJpZ2dlciB3bF9kYXRhX3NvdXJjZS5hY3Rpb24gYW5kXG5cdCAqXHR3bF9kYXRhX29mZmVyLmFjdGlvbiBldmVudHMgaWYgdGhlIGNvbXBvc2l0b3IgbmVlZHMgdG8gY2hhbmdlIHRoZVxuXHQgKlx0c2VsZWN0ZWQgYWN0aW9uLlxuXHQgKlxuXHQgKlx0VGhlIGRuZF9hY3Rpb25zIGFyZ3VtZW50IG11c3QgY29udGFpbiBvbmx5IHZhbHVlcyBleHByZXNzZWQgaW4gdGhlXG5cdCAqXHR3bF9kYXRhX2RldmljZV9tYW5hZ2VyLmRuZF9hY3Rpb25zIGVudW0sIG90aGVyd2lzZSBpdCB3aWxsIHJlc3VsdFxuXHQgKlx0aW4gYSBwcm90b2NvbCBlcnJvci5cblx0ICpcblx0ICpcdFRoaXMgcmVxdWVzdCBtdXN0IGJlIG1hZGUgb25jZSBvbmx5LCBhbmQgY2FuIG9ubHkgYmUgbWFkZSBvbiBzb3VyY2VzXG5cdCAqXHR1c2VkIGluIGRyYWctYW5kLWRyb3AsIHNvIGl0IG11c3QgYmUgcGVyZm9ybWVkIGJlZm9yZVxuXHQgKlx0d2xfZGF0YV9kZXZpY2Uuc3RhcnRfZHJhZy4gQXR0ZW1wdGluZyB0byB1c2UgdGhlIHNvdXJjZSBvdGhlciB0aGFuXG5cdCAqXHRmb3IgZHJhZy1hbmQtZHJvcCB3aWxsIHJhaXNlIGEgcHJvdG9jb2wgZXJyb3IuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkbmRBY3Rpb25zIGFjdGlvbnMgc3VwcG9ydGVkIGJ5IHRoZSBkYXRhIHNvdXJjZSBcblx0ICpcblx0ICogQHNpbmNlIDNcblx0ICpcblx0ICovXG5cdHNldEFjdGlvbnMgKGRuZEFjdGlvbnMpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCAyLCBbdWludChkbmRBY3Rpb25zKV0pXG5cdH1cblxuXHQvKipcblx0ICogRG8gbm90IGNvbnN0cnVjdCBwcm94aWVzIGRpcmVjdGx5LiBJbnN0ZWFkIHVzZSBvbmUgb2YgdGhlIGZhY3RvcnkgbWV0aG9kcyBmcm9tIG90aGVyIHByb3hpZXMuXG5cdCAqQHBhcmFtIHtEaXNwbGF5fWRpc3BsYXlcblx0ICpAcGFyYW0ge0Nvbm5lY3Rpb259Y29ubmVjdGlvblxuXHQgKkBwYXJhbSB7bnVtYmVyfWlkXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciAoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpIHtcblx0XHRzdXBlcihkaXNwbGF5LCBjb25uZWN0aW9uLCBpZClcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7V2xEYXRhU291cmNlRXZlbnRzfG51bGx9XG5cdFx0ICovXG5cdFx0dGhpcy5saXN0ZW5lciA9IG51bGxcblx0fVxuXG5cdGFzeW5jIFswXSAobWVzc2FnZSkge1xuXHRcdGF3YWl0IHRoaXMubGlzdGVuZXIudGFyZ2V0KHMobWVzc2FnZSwgdHJ1ZSkpXG5cdH1cblxuXHRhc3luYyBbMV0gKG1lc3NhZ2UpIHtcblx0XHRhd2FpdCB0aGlzLmxpc3RlbmVyLnNlbmQocyhtZXNzYWdlLCBmYWxzZSksIGgobWVzc2FnZSkpXG5cdH1cblxuXHRhc3luYyBbMl0gKG1lc3NhZ2UpIHtcblx0XHRhd2FpdCB0aGlzLmxpc3RlbmVyLmNhbmNlbGxlZCgpXG5cdH1cblxuXHRhc3luYyBbM10gKG1lc3NhZ2UpIHtcblx0XHRhd2FpdCB0aGlzLmxpc3RlbmVyLmRuZERyb3BQZXJmb3JtZWQoKVxuXHR9XG5cblx0YXN5bmMgWzRdIChtZXNzYWdlKSB7XG5cdFx0YXdhaXQgdGhpcy5saXN0ZW5lci5kbmRGaW5pc2hlZCgpXG5cdH1cblxuXHRhc3luYyBbNV0gKG1lc3NhZ2UpIHtcblx0XHRhd2FpdCB0aGlzLmxpc3RlbmVyLmFjdGlvbih1KG1lc3NhZ2UpKVxuXHR9XG5cbn1cbldsRGF0YVNvdXJjZVByb3h5LnByb3RvY29sTmFtZSA9ICd3bF9kYXRhX3NvdXJjZSdcblxuV2xEYXRhU291cmNlUHJveHkuRXJyb3IgPSB7XG4gIC8qKlxuICAgKiBhY3Rpb24gbWFzayBjb250YWlucyBpbnZhbGlkIHZhbHVlc1xuICAgKi9cbiAgaW52YWxpZEFjdGlvbk1hc2s6IDAsXG4gIC8qKlxuICAgKiBzb3VyY2UgZG9lc24ndCBhY2NlcHQgdGhpcyByZXF1ZXN0XG4gICAqL1xuICBpbnZhbGlkU291cmNlOiAxXG59XG5cbmV4cG9ydCBkZWZhdWx0IFdsRGF0YVNvdXJjZVByb3h5XG4iLCIvKlxuICpcbiAqICAgIENvcHlyaWdodCDCqSAyMDA4LTIwMTEgS3Jpc3RpYW4gSMO4Z3NiZXJnXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMC0yMDExIEludGVsIENvcnBvcmF0aW9uXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMi0yMDEzIENvbGxhYm9yYSwgTHRkLlxuICpcbiAqICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICogICAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICogICAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAqICAgIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gKiAgICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogICAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgKGluY2x1ZGluZyB0aGVcbiAqICAgIG5leHQgcGFyYWdyYXBoKSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsXG4gKiAgICBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogICAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqICAgIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gKiAgICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAqICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gKiAgICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiAgICBTT0ZUV0FSRS5cbiAqICBcbiAqL1xuXG4vKipcbiAqIEBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2xEaXNwbGF5RXZlbnRzIHtcblxuXHQvKipcblx0ICpcblx0ICpcdFRoZSBlcnJvciBldmVudCBpcyBzZW50IG91dCB3aGVuIGEgZmF0YWwgKG5vbi1yZWNvdmVyYWJsZSlcblx0ICpcdGVycm9yIGhhcyBvY2N1cnJlZC4gIFRoZSBvYmplY3RfaWQgYXJndW1lbnQgaXMgdGhlIG9iamVjdFxuXHQgKlx0d2hlcmUgdGhlIGVycm9yIG9jY3VycmVkLCBtb3N0IG9mdGVuIGluIHJlc3BvbnNlIHRvIGEgcmVxdWVzdFxuXHQgKlx0dG8gdGhhdCBvYmplY3QuICBUaGUgY29kZSBpZGVudGlmaWVzIHRoZSBlcnJvciBhbmQgaXMgZGVmaW5lZFxuXHQgKlx0YnkgdGhlIG9iamVjdCBpbnRlcmZhY2UuICBBcyBzdWNoLCBlYWNoIGludGVyZmFjZSBkZWZpbmVzIGl0c1xuXHQgKlx0b3duIHNldCBvZiBlcnJvciBjb2Rlcy4gIFRoZSBtZXNzYWdlIGlzIGEgYnJpZWYgZGVzY3JpcHRpb25cblx0ICpcdG9mIHRoZSBlcnJvciwgZm9yIChkZWJ1Z2dpbmcpIGNvbnZlbmllbmNlLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0geyp9IG9iamVjdElkIG9iamVjdCB3aGVyZSB0aGUgZXJyb3Igb2NjdXJyZWQgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlIGVycm9yIGNvZGUgXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIGVycm9yIGRlc2NyaXB0aW9uIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0ZXJyb3Iob2JqZWN0SWQsIGNvZGUsIG1lc3NhZ2UpIHt9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRUaGlzIGV2ZW50IGlzIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgb2JqZWN0IElEIG1hbmFnZW1lbnRcblx0ICpcdGxvZ2ljLiAgV2hlbiBhIGNsaWVudCBkZWxldGVzIGFuIG9iamVjdCwgdGhlIHNlcnZlciB3aWxsIHNlbmRcblx0ICpcdHRoaXMgZXZlbnQgdG8gYWNrbm93bGVkZ2UgdGhhdCBpdCBoYXMgc2VlbiB0aGUgZGVsZXRlIHJlcXVlc3QuXG5cdCAqXHRXaGVuIHRoZSBjbGllbnQgcmVjZWl2ZXMgdGhpcyBldmVudCwgaXQgd2lsbCBrbm93IHRoYXQgaXQgY2FuXG5cdCAqXHRzYWZlbHkgcmV1c2UgdGhlIG9iamVjdCBJRC5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGlkIGRlbGV0ZWQgb2JqZWN0IElEIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0ZGVsZXRlSWQoaWQpIHt9XG59XG5cbiIsIi8qXG4gKlxuICogICAgQ29weXJpZ2h0IMKpIDIwMDgtMjAxMSBLcmlzdGlhbiBIw7hnc2JlcmdcbiAqICAgIENvcHlyaWdodCDCqSAyMDEwLTIwMTEgSW50ZWwgQ29ycG9yYXRpb25cbiAqICAgIENvcHlyaWdodCDCqSAyMDEyLTIwMTMgQ29sbGFib3JhLCBMdGQuXG4gKlxuICogICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gKiAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSAoaW5jbHVkaW5nIHRoZVxuICogICAgbmV4dCBwYXJhZ3JhcGgpIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWxcbiAqICAgIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogICAgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAqICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICogICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAqICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqICAgIFNPRlRXQVJFLlxuICogIFxuICovXG5cbmltcG9ydCB7IENvbm5lY3Rpb24gfSBmcm9tICd3ZXN0ZmllbGQtcnVudGltZS1jb21tb24nXG5jb25zdCB7IHVpbnQsIHVpbnRPcHRpb25hbCwgaW50LCBpbnRPcHRpb25hbCwgZml4ZWQsIFxuXHRmaXhlZE9wdGlvbmFsLCBvYmplY3QsIG9iamVjdE9wdGlvbmFsLCBuZXdPYmplY3QsIHN0cmluZywgXG5cdHN0cmluZ09wdGlvbmFsLCBhcnJheSwgYXJyYXlPcHRpb25hbCwgXG5cdGZpbGVEZXNjcmlwdG9yT3B0aW9uYWwsIGZpbGVEZXNjcmlwdG9yLCBcbmgsIHUsIGksIGYsIG8sIG4sIHMsIGEgfSA9IENvbm5lY3Rpb25cbmltcG9ydCBQcm94eSBmcm9tICcuL1Byb3h5J1xuaW1wb3J0IFdsQ2FsbGJhY2tQcm94eSBmcm9tICcuL1dsQ2FsbGJhY2tQcm94eSdcbmltcG9ydCBXbFJlZ2lzdHJ5UHJveHkgZnJvbSAnLi9XbFJlZ2lzdHJ5UHJveHknXG5cbi8qKlxuICpcbiAqICAgICAgVGhlIGNvcmUgZ2xvYmFsIG9iamVjdC4gIFRoaXMgaXMgYSBzcGVjaWFsIHNpbmdsZXRvbiBvYmplY3QuICBJdFxuICogICAgICBpcyB1c2VkIGZvciBpbnRlcm5hbCBXYXlsYW5kIHByb3RvY29sIGZlYXR1cmVzLlxuICogICAgXG4gKi9cbmNsYXNzIFdsRGlzcGxheVByb3h5IGV4dGVuZHMgUHJveHkge1xuXG5cdC8qKlxuXHQgKlxuXHQgKlx0VGhlIHN5bmMgcmVxdWVzdCBhc2tzIHRoZSBzZXJ2ZXIgdG8gZW1pdCB0aGUgJ2RvbmUnIGV2ZW50XG5cdCAqXHRvbiB0aGUgcmV0dXJuZWQgd2xfY2FsbGJhY2sgb2JqZWN0LiAgU2luY2UgcmVxdWVzdHMgYXJlXG5cdCAqXHRoYW5kbGVkIGluLW9yZGVyIGFuZCBldmVudHMgYXJlIGRlbGl2ZXJlZCBpbi1vcmRlciwgdGhpcyBjYW5cblx0ICpcdGJlIHVzZWQgYXMgYSBiYXJyaWVyIHRvIGVuc3VyZSBhbGwgcHJldmlvdXMgcmVxdWVzdHMgYW5kIHRoZVxuXHQgKlx0cmVzdWx0aW5nIGV2ZW50cyBoYXZlIGJlZW4gaGFuZGxlZC5cblx0ICpcblx0ICpcdFRoZSBvYmplY3QgcmV0dXJuZWQgYnkgdGhpcyByZXF1ZXN0IHdpbGwgYmUgZGVzdHJveWVkIGJ5IHRoZVxuXHQgKlx0Y29tcG9zaXRvciBhZnRlciB0aGUgY2FsbGJhY2sgaXMgZmlyZWQgYW5kIGFzIHN1Y2ggdGhlIGNsaWVudCBtdXN0IG5vdFxuXHQgKlx0YXR0ZW1wdCB0byB1c2UgaXQgYWZ0ZXIgdGhhdCBwb2ludC5cblx0ICpcblx0ICpcdFRoZSBjYWxsYmFja19kYXRhIHBhc3NlZCBpbiB0aGUgY2FsbGJhY2sgaXMgdGhlIGV2ZW50IHNlcmlhbC5cblx0ICogICAgICBcblx0ICpcblx0ICogQHJldHVybiB7V2xDYWxsYmFja1Byb3h5fSBjYWxsYmFjayBvYmplY3QgZm9yIHRoZSBzeW5jIHJlcXVlc3QgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRzeW5jICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFyc2hhbGxDb25zdHJ1Y3Rvcih0aGlzLmlkLCAwLCBXbENhbGxiYWNrUHJveHksIFtuZXdPYmplY3QoKV0pXG5cdH1cblxuXHQvKipcblx0ICpcblx0ICpcdFRoaXMgcmVxdWVzdCBjcmVhdGVzIGEgcmVnaXN0cnkgb2JqZWN0IHRoYXQgYWxsb3dzIHRoZSBjbGllbnRcblx0ICpcdHRvIGxpc3QgYW5kIGJpbmQgdGhlIGdsb2JhbCBvYmplY3RzIGF2YWlsYWJsZSBmcm9tIHRoZVxuXHQgKlx0Y29tcG9zaXRvci5cblx0ICogICAgICBcblx0ICpcblx0ICogQHJldHVybiB7V2xSZWdpc3RyeVByb3h5fSBnbG9iYWwgcmVnaXN0cnkgb2JqZWN0IFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0Z2V0UmVnaXN0cnkgKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXJzaGFsbENvbnN0cnVjdG9yKHRoaXMuaWQsIDEsIFdsUmVnaXN0cnlQcm94eSwgW25ld09iamVjdCgpXSlcblx0fVxuXG5cdC8qKlxuXHQgKiBEbyBub3QgY29uc3RydWN0IHByb3hpZXMgZGlyZWN0bHkuIEluc3RlYWQgdXNlIG9uZSBvZiB0aGUgZmFjdG9yeSBtZXRob2RzIGZyb20gb3RoZXIgcHJveGllcy5cblx0ICpAcGFyYW0ge0Rpc3BsYXl9ZGlzcGxheVxuXHQgKkBwYXJhbSB7Q29ubmVjdGlvbn1jb25uZWN0aW9uXG5cdCAqQHBhcmFtIHtudW1iZXJ9aWRcblx0ICovXG5cdGNvbnN0cnVjdG9yIChkaXNwbGF5LCBjb25uZWN0aW9uLCBpZCkge1xuXHRcdHN1cGVyKGRpc3BsYXksIGNvbm5lY3Rpb24sIGlkKVxuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtXbERpc3BsYXlFdmVudHN8bnVsbH1cblx0XHQgKi9cblx0XHR0aGlzLmxpc3RlbmVyID0gbnVsbFxuXHR9XG5cblx0YXN5bmMgWzBdIChtZXNzYWdlKSB7XG5cdFx0YXdhaXQgdGhpcy5saXN0ZW5lci5lcnJvcihvKG1lc3NhZ2UsIGZhbHNlLCB0aGlzLl9jb25uZWN0aW9uKSwgdShtZXNzYWdlKSwgcyhtZXNzYWdlLCBmYWxzZSkpXG5cdH1cblxuXHRhc3luYyBbMV0gKG1lc3NhZ2UpIHtcblx0XHRhd2FpdCB0aGlzLmxpc3RlbmVyLmRlbGV0ZUlkKHUobWVzc2FnZSkpXG5cdH1cblxufVxuV2xEaXNwbGF5UHJveHkucHJvdG9jb2xOYW1lID0gJ3dsX2Rpc3BsYXknXG5cbldsRGlzcGxheVByb3h5LkVycm9yID0ge1xuICAvKipcbiAgICogc2VydmVyIGNvdWxkbid0IGZpbmQgb2JqZWN0XG4gICAqL1xuICBpbnZhbGlkT2JqZWN0OiAwLFxuICAvKipcbiAgICogbWV0aG9kIGRvZXNuJ3QgZXhpc3Qgb24gdGhlIHNwZWNpZmllZCBpbnRlcmZhY2VcbiAgICovXG4gIGludmFsaWRNZXRob2Q6IDEsXG4gIC8qKlxuICAgKiBzZXJ2ZXIgaXMgb3V0IG9mIG1lbW9yeVxuICAgKi9cbiAgbm9NZW1vcnk6IDJcbn1cblxuZXhwb3J0IGRlZmF1bHQgV2xEaXNwbGF5UHJveHlcbiIsIi8qXG4gKlxuICogICAgQ29weXJpZ2h0IMKpIDIwMDgtMjAxMSBLcmlzdGlhbiBIw7hnc2JlcmdcbiAqICAgIENvcHlyaWdodCDCqSAyMDEwLTIwMTEgSW50ZWwgQ29ycG9yYXRpb25cbiAqICAgIENvcHlyaWdodCDCqSAyMDEyLTIwMTMgQ29sbGFib3JhLCBMdGQuXG4gKlxuICogICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gKiAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSAoaW5jbHVkaW5nIHRoZVxuICogICAgbmV4dCBwYXJhZ3JhcGgpIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWxcbiAqICAgIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogICAgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAqICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICogICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAqICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqICAgIFNPRlRXQVJFLlxuICogIFxuICovXG5cbi8qKlxuICogQGludGVyZmFjZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXbEtleWJvYXJkRXZlbnRzIHtcblxuXHQvKipcblx0ICpcblx0ICpcdFRoaXMgZXZlbnQgcHJvdmlkZXMgYSBmaWxlIGRlc2NyaXB0b3IgdG8gdGhlIGNsaWVudCB3aGljaCBjYW4gYmVcblx0ICpcdG1lbW9yeS1tYXBwZWQgdG8gcHJvdmlkZSBhIGtleWJvYXJkIG1hcHBpbmcgZGVzY3JpcHRpb24uXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBmb3JtYXQga2V5bWFwIGZvcm1hdCBcblx0ICogQHBhcmFtIHtXZWJGRH0gZmQga2V5bWFwIGZpbGUgZGVzY3JpcHRvciBcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNpemUga2V5bWFwIHNpemUsIGluIGJ5dGVzIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0a2V5bWFwKGZvcm1hdCwgZmQsIHNpemUpIHt9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHROb3RpZmljYXRpb24gdGhhdCB0aGlzIHNlYXQncyBrZXlib2FyZCBmb2N1cyBpcyBvbiBhIGNlcnRhaW5cblx0ICpcdHN1cmZhY2UuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzZXJpYWwgc2VyaWFsIG51bWJlciBvZiB0aGUgZW50ZXIgZXZlbnQgXG5cdCAqIEBwYXJhbSB7Kn0gc3VyZmFjZSBzdXJmYWNlIGdhaW5pbmcga2V5Ym9hcmQgZm9jdXMgXG5cdCAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGtleXMgdGhlIGN1cnJlbnRseSBwcmVzc2VkIGtleXMgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRlbnRlcihzZXJpYWwsIHN1cmZhY2UsIGtleXMpIHt9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHROb3RpZmljYXRpb24gdGhhdCB0aGlzIHNlYXQncyBrZXlib2FyZCBmb2N1cyBpcyBubyBsb25nZXIgb25cblx0ICpcdGEgY2VydGFpbiBzdXJmYWNlLlxuXHQgKlxuXHQgKlx0VGhlIGxlYXZlIG5vdGlmaWNhdGlvbiBpcyBzZW50IGJlZm9yZSB0aGUgZW50ZXIgbm90aWZpY2F0aW9uXG5cdCAqXHRmb3IgdGhlIG5ldyBmb2N1cy5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNlcmlhbCBzZXJpYWwgbnVtYmVyIG9mIHRoZSBsZWF2ZSBldmVudCBcblx0ICogQHBhcmFtIHsqfSBzdXJmYWNlIHN1cmZhY2UgdGhhdCBsb3N0IGtleWJvYXJkIGZvY3VzIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0bGVhdmUoc2VyaWFsLCBzdXJmYWNlKSB7fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0QSBrZXkgd2FzIHByZXNzZWQgb3IgcmVsZWFzZWQuXG5cdCAqXHRUaGUgdGltZSBhcmd1bWVudCBpcyBhIHRpbWVzdGFtcCB3aXRoIG1pbGxpc2Vjb25kXG5cdCAqXHRncmFudWxhcml0eSwgd2l0aCBhbiB1bmRlZmluZWQgYmFzZS5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNlcmlhbCBzZXJpYWwgbnVtYmVyIG9mIHRoZSBrZXkgZXZlbnQgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIHRpbWVzdGFtcCB3aXRoIG1pbGxpc2Vjb25kIGdyYW51bGFyaXR5IFxuXHQgKiBAcGFyYW0ge251bWJlcn0ga2V5IGtleSB0aGF0IHByb2R1Y2VkIHRoZSBldmVudCBcblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXRlIHBoeXNpY2FsIHN0YXRlIG9mIHRoZSBrZXkgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRrZXkoc2VyaWFsLCB0aW1lLCBrZXksIHN0YXRlKSB7fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0Tm90aWZpZXMgY2xpZW50cyB0aGF0IHRoZSBtb2RpZmllciBhbmQvb3IgZ3JvdXAgc3RhdGUgaGFzXG5cdCAqXHRjaGFuZ2VkLCBhbmQgaXQgc2hvdWxkIHVwZGF0ZSBpdHMgbG9jYWwgc3RhdGUuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzZXJpYWwgc2VyaWFsIG51bWJlciBvZiB0aGUgbW9kaWZpZXJzIGV2ZW50IFxuXHQgKiBAcGFyYW0ge251bWJlcn0gbW9kc0RlcHJlc3NlZCBkZXByZXNzZWQgbW9kaWZpZXJzIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gbW9kc0xhdGNoZWQgbGF0Y2hlZCBtb2RpZmllcnMgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtb2RzTG9ja2VkIGxvY2tlZCBtb2RpZmllcnMgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBncm91cCBrZXlib2FyZCBsYXlvdXQgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRtb2RpZmllcnMoc2VyaWFsLCBtb2RzRGVwcmVzc2VkLCBtb2RzTGF0Y2hlZCwgbW9kc0xvY2tlZCwgZ3JvdXApIHt9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRJbmZvcm1zIHRoZSBjbGllbnQgYWJvdXQgdGhlIGtleWJvYXJkJ3MgcmVwZWF0IHJhdGUgYW5kIGRlbGF5LlxuXHQgKlxuXHQgKlx0VGhpcyBldmVudCBpcyBzZW50IGFzIHNvb24gYXMgdGhlIHdsX2tleWJvYXJkIG9iamVjdCBoYXMgYmVlbiBjcmVhdGVkLFxuXHQgKlx0YW5kIGlzIGd1YXJhbnRlZWQgdG8gYmUgcmVjZWl2ZWQgYnkgdGhlIGNsaWVudCBiZWZvcmUgYW55IGtleSBwcmVzc1xuXHQgKlx0ZXZlbnQuXG5cdCAqXG5cdCAqXHROZWdhdGl2ZSB2YWx1ZXMgZm9yIGVpdGhlciByYXRlIG9yIGRlbGF5IGFyZSBpbGxlZ2FsLiBBIHJhdGUgb2YgemVyb1xuXHQgKlx0d2lsbCBkaXNhYmxlIGFueSByZXBlYXRpbmcgKHJlZ2FyZGxlc3Mgb2YgdGhlIHZhbHVlIG9mIGRlbGF5KS5cblx0ICpcblx0ICpcdFRoaXMgZXZlbnQgY2FuIGJlIHNlbnQgbGF0ZXIgb24gYXMgd2VsbCB3aXRoIGEgbmV3IHZhbHVlIGlmIG5lY2Vzc2FyeSxcblx0ICpcdHNvIGNsaWVudHMgc2hvdWxkIGNvbnRpbnVlIGxpc3RlbmluZyBmb3IgdGhlIGV2ZW50IHBhc3QgdGhlIGNyZWF0aW9uXG5cdCAqXHRvZiB3bF9rZXlib2FyZC5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHJhdGUgdGhlIHJhdGUgb2YgcmVwZWF0aW5nIGtleXMgaW4gY2hhcmFjdGVycyBwZXIgc2Vjb25kIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgZGVsYXkgaW4gbWlsbGlzZWNvbmRzIHNpbmNlIGtleSBkb3duIHVudGlsIHJlcGVhdGluZyBzdGFydHMgXG5cdCAqXG5cdCAqIEBzaW5jZSA0XG5cdCAqXG5cdCAqL1xuXHRyZXBlYXRJbmZvKHJhdGUsIGRlbGF5KSB7fVxufVxuXG4iLCIvKlxuICpcbiAqICAgIENvcHlyaWdodCDCqSAyMDA4LTIwMTEgS3Jpc3RpYW4gSMO4Z3NiZXJnXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMC0yMDExIEludGVsIENvcnBvcmF0aW9uXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMi0yMDEzIENvbGxhYm9yYSwgTHRkLlxuICpcbiAqICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICogICAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICogICAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAqICAgIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gKiAgICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogICAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgKGluY2x1ZGluZyB0aGVcbiAqICAgIG5leHQgcGFyYWdyYXBoKSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsXG4gKiAgICBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogICAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqICAgIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gKiAgICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAqICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gKiAgICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiAgICBTT0ZUV0FSRS5cbiAqICBcbiAqL1xuXG5pbXBvcnQgeyBDb25uZWN0aW9uIH0gZnJvbSAnd2VzdGZpZWxkLXJ1bnRpbWUtY29tbW9uJ1xuY29uc3QgeyB1aW50LCB1aW50T3B0aW9uYWwsIGludCwgaW50T3B0aW9uYWwsIGZpeGVkLCBcblx0Zml4ZWRPcHRpb25hbCwgb2JqZWN0LCBvYmplY3RPcHRpb25hbCwgbmV3T2JqZWN0LCBzdHJpbmcsIFxuXHRzdHJpbmdPcHRpb25hbCwgYXJyYXksIGFycmF5T3B0aW9uYWwsIFxuXHRmaWxlRGVzY3JpcHRvck9wdGlvbmFsLCBmaWxlRGVzY3JpcHRvciwgXG5oLCB1LCBpLCBmLCBvLCBuLCBzLCBhIH0gPSBDb25uZWN0aW9uXG5pbXBvcnQgUHJveHkgZnJvbSAnLi9Qcm94eSdcblxuLyoqXG4gKlxuICogICAgICBUaGUgd2xfa2V5Ym9hcmQgaW50ZXJmYWNlIHJlcHJlc2VudHMgb25lIG9yIG1vcmUga2V5Ym9hcmRzXG4gKiAgICAgIGFzc29jaWF0ZWQgd2l0aCBhIHNlYXQuXG4gKiAgICBcbiAqL1xuY2xhc3MgV2xLZXlib2FyZFByb3h5IGV4dGVuZHMgUHJveHkge1xuXG5cdC8qKlxuXHQgKiBAc2luY2UgM1xuXHQgKlxuXHQgKi9cblx0cmVsZWFzZSAoKSB7XG5cdFx0c3VwZXIuZGVzdHJveSgpXG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgMCwgW10pXG5cdH1cblxuXHQvKipcblx0ICogRG8gbm90IGNvbnN0cnVjdCBwcm94aWVzIGRpcmVjdGx5LiBJbnN0ZWFkIHVzZSBvbmUgb2YgdGhlIGZhY3RvcnkgbWV0aG9kcyBmcm9tIG90aGVyIHByb3hpZXMuXG5cdCAqQHBhcmFtIHtEaXNwbGF5fWRpc3BsYXlcblx0ICpAcGFyYW0ge0Nvbm5lY3Rpb259Y29ubmVjdGlvblxuXHQgKkBwYXJhbSB7bnVtYmVyfWlkXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciAoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpIHtcblx0XHRzdXBlcihkaXNwbGF5LCBjb25uZWN0aW9uLCBpZClcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7V2xLZXlib2FyZEV2ZW50c3xudWxsfVxuXHRcdCAqL1xuXHRcdHRoaXMubGlzdGVuZXIgPSBudWxsXG5cdH1cblxuXHRhc3luYyBbMF0gKG1lc3NhZ2UpIHtcblx0XHRhd2FpdCB0aGlzLmxpc3RlbmVyLmtleW1hcCh1KG1lc3NhZ2UpLCBoKG1lc3NhZ2UpLCB1KG1lc3NhZ2UpKVxuXHR9XG5cblx0YXN5bmMgWzFdIChtZXNzYWdlKSB7XG5cdFx0YXdhaXQgdGhpcy5saXN0ZW5lci5lbnRlcih1KG1lc3NhZ2UpLCBvKG1lc3NhZ2UsIGZhbHNlLCB0aGlzLl9jb25uZWN0aW9uKSwgYShtZXNzYWdlLCBmYWxzZSkpXG5cdH1cblxuXHRhc3luYyBbMl0gKG1lc3NhZ2UpIHtcblx0XHRhd2FpdCB0aGlzLmxpc3RlbmVyLmxlYXZlKHUobWVzc2FnZSksIG8obWVzc2FnZSwgZmFsc2UsIHRoaXMuX2Nvbm5lY3Rpb24pKVxuXHR9XG5cblx0YXN5bmMgWzNdIChtZXNzYWdlKSB7XG5cdFx0YXdhaXQgdGhpcy5saXN0ZW5lci5rZXkodShtZXNzYWdlKSwgdShtZXNzYWdlKSwgdShtZXNzYWdlKSwgdShtZXNzYWdlKSlcblx0fVxuXG5cdGFzeW5jIFs0XSAobWVzc2FnZSkge1xuXHRcdGF3YWl0IHRoaXMubGlzdGVuZXIubW9kaWZpZXJzKHUobWVzc2FnZSksIHUobWVzc2FnZSksIHUobWVzc2FnZSksIHUobWVzc2FnZSksIHUobWVzc2FnZSkpXG5cdH1cblxuXHRhc3luYyBbNV0gKG1lc3NhZ2UpIHtcblx0XHRhd2FpdCB0aGlzLmxpc3RlbmVyLnJlcGVhdEluZm8oaShtZXNzYWdlKSwgaShtZXNzYWdlKSlcblx0fVxuXG59XG5XbEtleWJvYXJkUHJveHkucHJvdG9jb2xOYW1lID0gJ3dsX2tleWJvYXJkJ1xuXG5XbEtleWJvYXJkUHJveHkuS2V5bWFwRm9ybWF0ID0ge1xuICAvKipcbiAgICogbm8ga2V5bWFwOyBjbGllbnQgbXVzdCB1bmRlcnN0YW5kIGhvdyB0byBpbnRlcnByZXQgdGhlIHJhdyBrZXljb2RlXG4gICAqL1xuICBub0tleW1hcDogMCxcbiAgLyoqXG4gICAqIGxpYnhrYmNvbW1vbiBjb21wYXRpYmxlOyB0byBkZXRlcm1pbmUgdGhlIHhrYiBrZXljb2RlLCBjbGllbnRzIG11c3QgYWRkIDggdG8gdGhlIGtleSBldmVudCBrZXljb2RlXG4gICAqL1xuICB4a2JWMTogMVxufVxuXG5XbEtleWJvYXJkUHJveHkuS2V5U3RhdGUgPSB7XG4gIC8qKlxuICAgKiBrZXkgaXMgbm90IHByZXNzZWRcbiAgICovXG4gIHJlbGVhc2VkOiAwLFxuICAvKipcbiAgICoga2V5IGlzIHByZXNzZWRcbiAgICovXG4gIHByZXNzZWQ6IDFcbn1cblxuZXhwb3J0IGRlZmF1bHQgV2xLZXlib2FyZFByb3h5XG4iLCIvKlxuICpcbiAqICAgIENvcHlyaWdodCDCqSAyMDA4LTIwMTEgS3Jpc3RpYW4gSMO4Z3NiZXJnXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMC0yMDExIEludGVsIENvcnBvcmF0aW9uXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMi0yMDEzIENvbGxhYm9yYSwgTHRkLlxuICpcbiAqICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICogICAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICogICAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAqICAgIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gKiAgICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogICAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgKGluY2x1ZGluZyB0aGVcbiAqICAgIG5leHQgcGFyYWdyYXBoKSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsXG4gKiAgICBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogICAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqICAgIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gKiAgICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAqICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gKiAgICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiAgICBTT0ZUV0FSRS5cbiAqICBcbiAqL1xuXG4vKipcbiAqIEBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2xPdXRwdXRFdmVudHMge1xuXG5cdC8qKlxuXHQgKlxuXHQgKlx0VGhlIGdlb21ldHJ5IGV2ZW50IGRlc2NyaWJlcyBnZW9tZXRyaWMgcHJvcGVydGllcyBvZiB0aGUgb3V0cHV0LlxuXHQgKlx0VGhlIGV2ZW50IGlzIHNlbnQgd2hlbiBiaW5kaW5nIHRvIHRoZSBvdXRwdXQgb2JqZWN0IGFuZCB3aGVuZXZlclxuXHQgKlx0YW55IG9mIHRoZSBwcm9wZXJ0aWVzIGNoYW5nZS5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHggeCBwb3NpdGlvbiB3aXRoaW4gdGhlIGdsb2JhbCBjb21wb3NpdG9yIHNwYWNlIFxuXHQgKiBAcGFyYW0ge251bWJlcn0geSB5IHBvc2l0aW9uIHdpdGhpbiB0aGUgZ2xvYmFsIGNvbXBvc2l0b3Igc3BhY2UgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwaHlzaWNhbFdpZHRoIHdpZHRoIGluIG1pbGxpbWV0ZXJzIG9mIHRoZSBvdXRwdXQgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBwaHlzaWNhbEhlaWdodCBoZWlnaHQgaW4gbWlsbGltZXRlcnMgb2YgdGhlIG91dHB1dCBcblx0ICogQHBhcmFtIHtudW1iZXJ9IHN1YnBpeGVsIHN1YnBpeGVsIG9yaWVudGF0aW9uIG9mIHRoZSBvdXRwdXQgXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtYWtlIHRleHR1YWwgZGVzY3JpcHRpb24gb2YgdGhlIG1hbnVmYWN0dXJlciBcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1vZGVsIHRleHR1YWwgZGVzY3JpcHRpb24gb2YgdGhlIG1vZGVsIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gdHJhbnNmb3JtIHRyYW5zZm9ybSB0aGF0IG1hcHMgZnJhbWVidWZmZXIgdG8gb3V0cHV0IFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0Z2VvbWV0cnkoeCwgeSwgcGh5c2ljYWxXaWR0aCwgcGh5c2ljYWxIZWlnaHQsIHN1YnBpeGVsLCBtYWtlLCBtb2RlbCwgdHJhbnNmb3JtKSB7fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0VGhlIG1vZGUgZXZlbnQgZGVzY3JpYmVzIGFuIGF2YWlsYWJsZSBtb2RlIGZvciB0aGUgb3V0cHV0LlxuXHQgKlxuXHQgKlx0VGhlIGV2ZW50IGlzIHNlbnQgd2hlbiBiaW5kaW5nIHRvIHRoZSBvdXRwdXQgb2JqZWN0IGFuZCB0aGVyZVxuXHQgKlx0d2lsbCBhbHdheXMgYmUgb25lIG1vZGUsIHRoZSBjdXJyZW50IG1vZGUuICBUaGUgZXZlbnQgaXMgc2VudFxuXHQgKlx0YWdhaW4gaWYgYW4gb3V0cHV0IGNoYW5nZXMgbW9kZSwgZm9yIHRoZSBtb2RlIHRoYXQgaXMgbm93XG5cdCAqXHRjdXJyZW50LiAgSW4gb3RoZXIgd29yZHMsIHRoZSBjdXJyZW50IG1vZGUgaXMgYWx3YXlzIHRoZSBsYXN0XG5cdCAqXHRtb2RlIHRoYXQgd2FzIHJlY2VpdmVkIHdpdGggdGhlIGN1cnJlbnQgZmxhZyBzZXQuXG5cdCAqXG5cdCAqXHRUaGUgc2l6ZSBvZiBhIG1vZGUgaXMgZ2l2ZW4gaW4gcGh5c2ljYWwgaGFyZHdhcmUgdW5pdHMgb2Zcblx0ICpcdHRoZSBvdXRwdXQgZGV2aWNlLiBUaGlzIGlzIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBhc1xuXHQgKlx0dGhlIG91dHB1dCBzaXplIGluIHRoZSBnbG9iYWwgY29tcG9zaXRvciBzcGFjZS4gRm9yIGluc3RhbmNlLFxuXHQgKlx0dGhlIG91dHB1dCBtYXkgYmUgc2NhbGVkLCBhcyBkZXNjcmliZWQgaW4gd2xfb3V0cHV0LnNjYWxlLFxuXHQgKlx0b3IgdHJhbnNmb3JtZWQsIGFzIGRlc2NyaWJlZCBpbiB3bF9vdXRwdXQudHJhbnNmb3JtLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZmxhZ3MgYml0ZmllbGQgb2YgbW9kZSBmbGFncyBcblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIHdpZHRoIG9mIHRoZSBtb2RlIGluIGhhcmR3YXJlIHVuaXRzIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IGhlaWdodCBvZiB0aGUgbW9kZSBpbiBoYXJkd2FyZSB1bml0cyBcblx0ICogQHBhcmFtIHtudW1iZXJ9IHJlZnJlc2ggdmVydGljYWwgcmVmcmVzaCByYXRlIGluIG1IeiBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdG1vZGUoZmxhZ3MsIHdpZHRoLCBoZWlnaHQsIHJlZnJlc2gpIHt9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRUaGlzIGV2ZW50IGlzIHNlbnQgYWZ0ZXIgYWxsIG90aGVyIHByb3BlcnRpZXMgaGF2ZSBiZWVuXG5cdCAqXHRzZW50IGFmdGVyIGJpbmRpbmcgdG8gdGhlIG91dHB1dCBvYmplY3QgYW5kIGFmdGVyIGFueVxuXHQgKlx0b3RoZXIgcHJvcGVydHkgY2hhbmdlcyBkb25lIGFmdGVyIHRoYXQuIFRoaXMgYWxsb3dzXG5cdCAqXHRjaGFuZ2VzIHRvIHRoZSBvdXRwdXQgcHJvcGVydGllcyB0byBiZSBzZWVuIGFzXG5cdCAqXHRhdG9taWMsIGV2ZW4gaWYgdGhleSBoYXBwZW4gdmlhIG11bHRpcGxlIGV2ZW50cy5cblx0ICogICAgICBcblx0ICpcblx0ICpcblx0ICogQHNpbmNlIDJcblx0ICpcblx0ICovXG5cdGRvbmUoKSB7fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0VGhpcyBldmVudCBjb250YWlucyBzY2FsaW5nIGdlb21ldHJ5IGluZm9ybWF0aW9uXG5cdCAqXHR0aGF0IGlzIG5vdCBpbiB0aGUgZ2VvbWV0cnkgZXZlbnQuIEl0IG1heSBiZSBzZW50IGFmdGVyXG5cdCAqXHRiaW5kaW5nIHRoZSBvdXRwdXQgb2JqZWN0IG9yIGlmIHRoZSBvdXRwdXQgc2NhbGUgY2hhbmdlc1xuXHQgKlx0bGF0ZXIuIElmIGl0IGlzIG5vdCBzZW50LCB0aGUgY2xpZW50IHNob3VsZCBhc3N1bWUgYVxuXHQgKlx0c2NhbGUgb2YgMS5cblx0ICpcblx0ICpcdEEgc2NhbGUgbGFyZ2VyIHRoYW4gMSBtZWFucyB0aGF0IHRoZSBjb21wb3NpdG9yIHdpbGxcblx0ICpcdGF1dG9tYXRpY2FsbHkgc2NhbGUgc3VyZmFjZSBidWZmZXJzIGJ5IHRoaXMgYW1vdW50XG5cdCAqXHR3aGVuIHJlbmRlcmluZy4gVGhpcyBpcyB1c2VkIGZvciB2ZXJ5IGhpZ2ggcmVzb2x1dGlvblxuXHQgKlx0ZGlzcGxheXMgd2hlcmUgYXBwbGljYXRpb25zIHJlbmRlcmluZyBhdCB0aGUgbmF0aXZlXG5cdCAqXHRyZXNvbHV0aW9uIHdvdWxkIGJlIHRvbyBzbWFsbCB0byBiZSBsZWdpYmxlLlxuXHQgKlxuXHQgKlx0SXQgaXMgaW50ZW5kZWQgdGhhdCBzY2FsaW5nIGF3YXJlIGNsaWVudHMgdHJhY2sgdGhlXG5cdCAqXHRjdXJyZW50IG91dHB1dCBvZiBhIHN1cmZhY2UsIGFuZCBpZiBpdCBpcyBvbiBhIHNjYWxlZFxuXHQgKlx0b3V0cHV0IGl0IHNob3VsZCB1c2Ugd2xfc3VyZmFjZS5zZXRfYnVmZmVyX3NjYWxlIHdpdGhcblx0ICpcdHRoZSBzY2FsZSBvZiB0aGUgb3V0cHV0LiBUaGF0IHdheSB0aGUgY29tcG9zaXRvciBjYW5cblx0ICpcdGF2b2lkIHNjYWxpbmcgdGhlIHN1cmZhY2UsIGFuZCB0aGUgY2xpZW50IGNhbiBzdXBwbHlcblx0ICpcdGEgaGlnaGVyIGRldGFpbCBpbWFnZS5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGZhY3RvciBzY2FsaW5nIGZhY3RvciBvZiBvdXRwdXQgXG5cdCAqXG5cdCAqIEBzaW5jZSAyXG5cdCAqXG5cdCAqL1xuXHRzY2FsZShmYWN0b3IpIHt9XG59XG5cbiIsIi8qXG4gKlxuICogICAgQ29weXJpZ2h0IMKpIDIwMDgtMjAxMSBLcmlzdGlhbiBIw7hnc2JlcmdcbiAqICAgIENvcHlyaWdodCDCqSAyMDEwLTIwMTEgSW50ZWwgQ29ycG9yYXRpb25cbiAqICAgIENvcHlyaWdodCDCqSAyMDEyLTIwMTMgQ29sbGFib3JhLCBMdGQuXG4gKlxuICogICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gKiAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSAoaW5jbHVkaW5nIHRoZVxuICogICAgbmV4dCBwYXJhZ3JhcGgpIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWxcbiAqICAgIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogICAgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAqICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICogICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAqICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqICAgIFNPRlRXQVJFLlxuICogIFxuICovXG5cbmltcG9ydCB7IENvbm5lY3Rpb24gfSBmcm9tICd3ZXN0ZmllbGQtcnVudGltZS1jb21tb24nXG5jb25zdCB7IHVpbnQsIHVpbnRPcHRpb25hbCwgaW50LCBpbnRPcHRpb25hbCwgZml4ZWQsIFxuXHRmaXhlZE9wdGlvbmFsLCBvYmplY3QsIG9iamVjdE9wdGlvbmFsLCBuZXdPYmplY3QsIHN0cmluZywgXG5cdHN0cmluZ09wdGlvbmFsLCBhcnJheSwgYXJyYXlPcHRpb25hbCwgXG5cdGZpbGVEZXNjcmlwdG9yT3B0aW9uYWwsIGZpbGVEZXNjcmlwdG9yLCBcbmgsIHUsIGksIGYsIG8sIG4sIHMsIGEgfSA9IENvbm5lY3Rpb25cbmltcG9ydCBQcm94eSBmcm9tICcuL1Byb3h5J1xuXG4vKipcbiAqXG4gKiAgICAgIEFuIG91dHB1dCBkZXNjcmliZXMgcGFydCBvZiB0aGUgY29tcG9zaXRvciBnZW9tZXRyeS4gIFRoZVxuICogICAgICBjb21wb3NpdG9yIHdvcmtzIGluIHRoZSAnY29tcG9zaXRvciBjb29yZGluYXRlIHN5c3RlbScgYW5kIGFuXG4gKiAgICAgIG91dHB1dCBjb3JyZXNwb25kcyB0byBhIHJlY3Rhbmd1bGFyIGFyZWEgaW4gdGhhdCBzcGFjZSB0aGF0IGlzXG4gKiAgICAgIGFjdHVhbGx5IHZpc2libGUuICBUaGlzIHR5cGljYWxseSBjb3JyZXNwb25kcyB0byBhIG1vbml0b3IgdGhhdFxuICogICAgICBkaXNwbGF5cyBwYXJ0IG9mIHRoZSBjb21wb3NpdG9yIHNwYWNlLiAgVGhpcyBvYmplY3QgaXMgcHVibGlzaGVkXG4gKiAgICAgIGFzIGdsb2JhbCBkdXJpbmcgc3RhcnQgdXAsIG9yIHdoZW4gYSBtb25pdG9yIGlzIGhvdHBsdWdnZWQuXG4gKiAgICBcbiAqL1xuY2xhc3MgV2xPdXRwdXRQcm94eSBleHRlbmRzIFByb3h5IHtcblxuXHQvKipcblx0ICpcblx0ICpcdFVzaW5nIHRoaXMgcmVxdWVzdCBhIGNsaWVudCBjYW4gdGVsbCB0aGUgc2VydmVyIHRoYXQgaXQgaXMgbm90IGdvaW5nIHRvXG5cdCAqXHR1c2UgdGhlIG91dHB1dCBvYmplY3QgYW55bW9yZS5cblx0ICogICAgICBcblx0ICogQHNpbmNlIDNcblx0ICpcblx0ICovXG5cdHJlbGVhc2UgKCkge1xuXHRcdHN1cGVyLmRlc3Ryb3koKVxuXHRcdHRoaXMuX21hcnNoYWxsKHRoaXMuaWQsIDAsIFtdKVxuXHR9XG5cblx0LyoqXG5cdCAqIERvIG5vdCBjb25zdHJ1Y3QgcHJveGllcyBkaXJlY3RseS4gSW5zdGVhZCB1c2Ugb25lIG9mIHRoZSBmYWN0b3J5IG1ldGhvZHMgZnJvbSBvdGhlciBwcm94aWVzLlxuXHQgKkBwYXJhbSB7RGlzcGxheX1kaXNwbGF5XG5cdCAqQHBhcmFtIHtDb25uZWN0aW9ufWNvbm5lY3Rpb25cblx0ICpAcGFyYW0ge251bWJlcn1pZFxuXHQgKi9cblx0Y29uc3RydWN0b3IgKGRpc3BsYXksIGNvbm5lY3Rpb24sIGlkKSB7XG5cdFx0c3VwZXIoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge1dsT3V0cHV0RXZlbnRzfG51bGx9XG5cdFx0ICovXG5cdFx0dGhpcy5saXN0ZW5lciA9IG51bGxcblx0fVxuXG5cdGFzeW5jIFswXSAobWVzc2FnZSkge1xuXHRcdGF3YWl0IHRoaXMubGlzdGVuZXIuZ2VvbWV0cnkoaShtZXNzYWdlKSwgaShtZXNzYWdlKSwgaShtZXNzYWdlKSwgaShtZXNzYWdlKSwgaShtZXNzYWdlKSwgcyhtZXNzYWdlLCBmYWxzZSksIHMobWVzc2FnZSwgZmFsc2UpLCBpKG1lc3NhZ2UpKVxuXHR9XG5cblx0YXN5bmMgWzFdIChtZXNzYWdlKSB7XG5cdFx0YXdhaXQgdGhpcy5saXN0ZW5lci5tb2RlKHUobWVzc2FnZSksIGkobWVzc2FnZSksIGkobWVzc2FnZSksIGkobWVzc2FnZSkpXG5cdH1cblxuXHRhc3luYyBbMl0gKG1lc3NhZ2UpIHtcblx0XHRhd2FpdCB0aGlzLmxpc3RlbmVyLmRvbmUoKVxuXHR9XG5cblx0YXN5bmMgWzNdIChtZXNzYWdlKSB7XG5cdFx0YXdhaXQgdGhpcy5saXN0ZW5lci5zY2FsZShpKG1lc3NhZ2UpKVxuXHR9XG5cbn1cbldsT3V0cHV0UHJveHkucHJvdG9jb2xOYW1lID0gJ3dsX291dHB1dCdcblxuV2xPdXRwdXRQcm94eS5TdWJwaXhlbCA9IHtcbiAgLyoqXG4gICAqIHVua25vd24gZ2VvbWV0cnlcbiAgICovXG4gIHVua25vd246IDAsXG4gIC8qKlxuICAgKiBubyBnZW9tZXRyeVxuICAgKi9cbiAgbm9uZTogMSxcbiAgLyoqXG4gICAqIGhvcml6b250YWwgUkdCXG4gICAqL1xuICBob3Jpem9udGFsUmdiOiAyLFxuICAvKipcbiAgICogaG9yaXpvbnRhbCBCR1JcbiAgICovXG4gIGhvcml6b250YWxCZ3I6IDMsXG4gIC8qKlxuICAgKiB2ZXJ0aWNhbCBSR0JcbiAgICovXG4gIHZlcnRpY2FsUmdiOiA0LFxuICAvKipcbiAgICogdmVydGljYWwgQkdSXG4gICAqL1xuICB2ZXJ0aWNhbEJncjogNVxufVxuXG5XbE91dHB1dFByb3h5LlRyYW5zZm9ybSA9IHtcbiAgLyoqXG4gICAqIG5vIHRyYW5zZm9ybVxuICAgKi9cbiAgbm9ybWFsOiAwLFxuICAvKipcbiAgICogOTAgZGVncmVlcyBjb3VudGVyLWNsb2Nrd2lzZVxuICAgKi9cbiAgOTA6IDEsXG4gIC8qKlxuICAgKiAxODAgZGVncmVlcyBjb3VudGVyLWNsb2Nrd2lzZVxuICAgKi9cbiAgMTgwOiAyLFxuICAvKipcbiAgICogMjcwIGRlZ3JlZXMgY291bnRlci1jbG9ja3dpc2VcbiAgICovXG4gIDI3MDogMyxcbiAgLyoqXG4gICAqIDE4MCBkZWdyZWUgZmxpcCBhcm91bmQgYSB2ZXJ0aWNhbCBheGlzXG4gICAqL1xuICBmbGlwcGVkOiA0LFxuICAvKipcbiAgICogZmxpcCBhbmQgcm90YXRlIDkwIGRlZ3JlZXMgY291bnRlci1jbG9ja3dpc2VcbiAgICovXG4gIGZsaXBwZWQ5MDogNSxcbiAgLyoqXG4gICAqIGZsaXAgYW5kIHJvdGF0ZSAxODAgZGVncmVlcyBjb3VudGVyLWNsb2Nrd2lzZVxuICAgKi9cbiAgZmxpcHBlZDE4MDogNixcbiAgLyoqXG4gICAqIGZsaXAgYW5kIHJvdGF0ZSAyNzAgZGVncmVlcyBjb3VudGVyLWNsb2Nrd2lzZVxuICAgKi9cbiAgZmxpcHBlZDI3MDogN1xufVxuXG5XbE91dHB1dFByb3h5Lk1vZGUgPSB7XG4gIC8qKlxuICAgKiBpbmRpY2F0ZXMgdGhpcyBpcyB0aGUgY3VycmVudCBtb2RlXG4gICAqL1xuICBjdXJyZW50OiAweDEsXG4gIC8qKlxuICAgKiBpbmRpY2F0ZXMgdGhpcyBpcyB0aGUgcHJlZmVycmVkIG1vZGVcbiAgICovXG4gIHByZWZlcnJlZDogMHgyXG59XG5cbmV4cG9ydCBkZWZhdWx0IFdsT3V0cHV0UHJveHlcbiIsIi8qXG4gKlxuICogICAgQ29weXJpZ2h0IMKpIDIwMDgtMjAxMSBLcmlzdGlhbiBIw7hnc2JlcmdcbiAqICAgIENvcHlyaWdodCDCqSAyMDEwLTIwMTEgSW50ZWwgQ29ycG9yYXRpb25cbiAqICAgIENvcHlyaWdodCDCqSAyMDEyLTIwMTMgQ29sbGFib3JhLCBMdGQuXG4gKlxuICogICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gKiAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSAoaW5jbHVkaW5nIHRoZVxuICogICAgbmV4dCBwYXJhZ3JhcGgpIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWxcbiAqICAgIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogICAgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAqICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICogICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAqICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqICAgIFNPRlRXQVJFLlxuICogIFxuICovXG5cbi8qKlxuICogQGludGVyZmFjZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXbFBvaW50ZXJFdmVudHMge1xuXG5cdC8qKlxuXHQgKlxuXHQgKlx0Tm90aWZpY2F0aW9uIHRoYXQgdGhpcyBzZWF0J3MgcG9pbnRlciBpcyBmb2N1c2VkIG9uIGEgY2VydGFpblxuXHQgKlx0c3VyZmFjZS5cblx0ICpcblx0ICpcdFdoZW4gYSBzZWF0J3MgZm9jdXMgZW50ZXJzIGEgc3VyZmFjZSwgdGhlIHBvaW50ZXIgaW1hZ2Vcblx0ICpcdGlzIHVuZGVmaW5lZCBhbmQgYSBjbGllbnQgc2hvdWxkIHJlc3BvbmQgdG8gdGhpcyBldmVudCBieSBzZXR0aW5nXG5cdCAqXHRhbiBhcHByb3ByaWF0ZSBwb2ludGVyIGltYWdlIHdpdGggdGhlIHNldF9jdXJzb3IgcmVxdWVzdC5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNlcmlhbCBzZXJpYWwgbnVtYmVyIG9mIHRoZSBlbnRlciBldmVudCBcblx0ICogQHBhcmFtIHsqfSBzdXJmYWNlIHN1cmZhY2UgZW50ZXJlZCBieSB0aGUgcG9pbnRlciBcblx0ICogQHBhcmFtIHtGaXhlZH0gc3VyZmFjZVggc3VyZmFjZS1sb2NhbCB4IGNvb3JkaW5hdGUgXG5cdCAqIEBwYXJhbSB7Rml4ZWR9IHN1cmZhY2VZIHN1cmZhY2UtbG9jYWwgeSBjb29yZGluYXRlIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0ZW50ZXIoc2VyaWFsLCBzdXJmYWNlLCBzdXJmYWNlWCwgc3VyZmFjZVkpIHt9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHROb3RpZmljYXRpb24gdGhhdCB0aGlzIHNlYXQncyBwb2ludGVyIGlzIG5vIGxvbmdlciBmb2N1c2VkIG9uXG5cdCAqXHRhIGNlcnRhaW4gc3VyZmFjZS5cblx0ICpcblx0ICpcdFRoZSBsZWF2ZSBub3RpZmljYXRpb24gaXMgc2VudCBiZWZvcmUgdGhlIGVudGVyIG5vdGlmaWNhdGlvblxuXHQgKlx0Zm9yIHRoZSBuZXcgZm9jdXMuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzZXJpYWwgc2VyaWFsIG51bWJlciBvZiB0aGUgbGVhdmUgZXZlbnQgXG5cdCAqIEBwYXJhbSB7Kn0gc3VyZmFjZSBzdXJmYWNlIGxlZnQgYnkgdGhlIHBvaW50ZXIgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRsZWF2ZShzZXJpYWwsIHN1cmZhY2UpIHt9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHROb3RpZmljYXRpb24gb2YgcG9pbnRlciBsb2NhdGlvbiBjaGFuZ2UuIFRoZSBhcmd1bWVudHNcblx0ICpcdHN1cmZhY2VfeCBhbmQgc3VyZmFjZV95IGFyZSB0aGUgbG9jYXRpb24gcmVsYXRpdmUgdG8gdGhlXG5cdCAqXHRmb2N1c2VkIHN1cmZhY2UuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIHRpbWVzdGFtcCB3aXRoIG1pbGxpc2Vjb25kIGdyYW51bGFyaXR5IFxuXHQgKiBAcGFyYW0ge0ZpeGVkfSBzdXJmYWNlWCBzdXJmYWNlLWxvY2FsIHggY29vcmRpbmF0ZSBcblx0ICogQHBhcmFtIHtGaXhlZH0gc3VyZmFjZVkgc3VyZmFjZS1sb2NhbCB5IGNvb3JkaW5hdGUgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRtb3Rpb24odGltZSwgc3VyZmFjZVgsIHN1cmZhY2VZKSB7fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0TW91c2UgYnV0dG9uIGNsaWNrIGFuZCByZWxlYXNlIG5vdGlmaWNhdGlvbnMuXG5cdCAqXG5cdCAqXHRUaGUgbG9jYXRpb24gb2YgdGhlIGNsaWNrIGlzIGdpdmVuIGJ5IHRoZSBsYXN0IG1vdGlvbiBvclxuXHQgKlx0ZW50ZXIgZXZlbnQuXG5cdCAqXHRUaGUgdGltZSBhcmd1bWVudCBpcyBhIHRpbWVzdGFtcCB3aXRoIG1pbGxpc2Vjb25kXG5cdCAqXHRncmFudWxhcml0eSwgd2l0aCBhbiB1bmRlZmluZWQgYmFzZS5cblx0ICpcblx0ICpcdFRoZSBidXR0b24gaXMgYSBidXR0b24gY29kZSBhcyBkZWZpbmVkIGluIHRoZSBMaW51eCBrZXJuZWwnc1xuXHQgKlx0bGludXgvaW5wdXQtZXZlbnQtY29kZXMuaCBoZWFkZXIgZmlsZSwgZS5nLiBCVE5fTEVGVC5cblx0ICpcblx0ICpcdEFueSAxNi1iaXQgYnV0dG9uIGNvZGUgdmFsdWUgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSBhZGRpdGlvbnMgdG8gdGhlXG5cdCAqXHRrZXJuZWwncyBldmVudCBjb2RlIGxpc3QuIEFsbCBvdGhlciBidXR0b24gY29kZXMgYWJvdmUgMHhGRkZGIGFyZVxuXHQgKlx0Y3VycmVudGx5IHVuZGVmaW5lZCBidXQgbWF5IGJlIHVzZWQgaW4gZnV0dXJlIHZlcnNpb25zIG9mIHRoaXNcblx0ICpcdHByb3RvY29sLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2VyaWFsIHNlcmlhbCBudW1iZXIgb2YgdGhlIGJ1dHRvbiBldmVudCBcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgdGltZXN0YW1wIHdpdGggbWlsbGlzZWNvbmQgZ3JhbnVsYXJpdHkgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBidXR0b24gYnV0dG9uIHRoYXQgcHJvZHVjZWQgdGhlIGV2ZW50IFxuXHQgKiBAcGFyYW0ge251bWJlcn0gc3RhdGUgcGh5c2ljYWwgc3RhdGUgb2YgdGhlIGJ1dHRvbiBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdGJ1dHRvbihzZXJpYWwsIHRpbWUsIGJ1dHRvbiwgc3RhdGUpIHt9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRTY3JvbGwgYW5kIG90aGVyIGF4aXMgbm90aWZpY2F0aW9ucy5cblx0ICpcblx0ICpcdEZvciBzY3JvbGwgZXZlbnRzICh2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBzY3JvbGwgYXhlcyksIHRoZVxuXHQgKlx0dmFsdWUgcGFyYW1ldGVyIGlzIHRoZSBsZW5ndGggb2YgYSB2ZWN0b3IgYWxvbmcgdGhlIHNwZWNpZmllZFxuXHQgKlx0YXhpcyBpbiBhIGNvb3JkaW5hdGUgc3BhY2UgaWRlbnRpY2FsIHRvIHRob3NlIG9mIG1vdGlvbiBldmVudHMsXG5cdCAqXHRyZXByZXNlbnRpbmcgYSByZWxhdGl2ZSBtb3ZlbWVudCBhbG9uZyB0aGUgc3BlY2lmaWVkIGF4aXMuXG5cdCAqXG5cdCAqXHRGb3IgZGV2aWNlcyB0aGF0IHN1cHBvcnQgbW92ZW1lbnRzIG5vbi1wYXJhbGxlbCB0byBheGVzIG11bHRpcGxlXG5cdCAqXHRheGlzIGV2ZW50cyB3aWxsIGJlIGVtaXR0ZWQuXG5cdCAqXG5cdCAqXHRXaGVuIGFwcGxpY2FibGUsIGZvciBleGFtcGxlIGZvciB0b3VjaCBwYWRzLCB0aGUgc2VydmVyIGNhblxuXHQgKlx0Y2hvb3NlIHRvIGVtaXQgc2Nyb2xsIGV2ZW50cyB3aGVyZSB0aGUgbW90aW9uIHZlY3RvciBpc1xuXHQgKlx0ZXF1aXZhbGVudCB0byBhIG1vdGlvbiBldmVudCB2ZWN0b3IuXG5cdCAqXG5cdCAqXHRXaGVuIGFwcGxpY2FibGUsIGEgY2xpZW50IGNhbiB0cmFuc2Zvcm0gaXRzIGNvbnRlbnQgcmVsYXRpdmUgdG8gdGhlXG5cdCAqXHRzY3JvbGwgZGlzdGFuY2UuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lIHRpbWVzdGFtcCB3aXRoIG1pbGxpc2Vjb25kIGdyYW51bGFyaXR5IFxuXHQgKiBAcGFyYW0ge251bWJlcn0gYXhpcyBheGlzIHR5cGUgXG5cdCAqIEBwYXJhbSB7Rml4ZWR9IHZhbHVlIGxlbmd0aCBvZiB2ZWN0b3IgaW4gc3VyZmFjZS1sb2NhbCBjb29yZGluYXRlIHNwYWNlIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0YXhpcyh0aW1lLCBheGlzLCB2YWx1ZSkge31cblxuXHQvKipcblx0ICpcblx0ICpcdEluZGljYXRlcyB0aGUgZW5kIG9mIGEgc2V0IG9mIGV2ZW50cyB0aGF0IGxvZ2ljYWxseSBiZWxvbmcgdG9nZXRoZXIuXG5cdCAqXHRBIGNsaWVudCBpcyBleHBlY3RlZCB0byBhY2N1bXVsYXRlIHRoZSBkYXRhIGluIGFsbCBldmVudHMgd2l0aGluIHRoZVxuXHQgKlx0ZnJhbWUgYmVmb3JlIHByb2NlZWRpbmcuXG5cdCAqXG5cdCAqXHRBbGwgd2xfcG9pbnRlciBldmVudHMgYmVmb3JlIGEgd2xfcG9pbnRlci5mcmFtZSBldmVudCBiZWxvbmdcblx0ICpcdGxvZ2ljYWxseSB0b2dldGhlci4gRm9yIGV4YW1wbGUsIGluIGEgZGlhZ29uYWwgc2Nyb2xsIG1vdGlvbiB0aGVcblx0ICpcdGNvbXBvc2l0b3Igd2lsbCBzZW5kIGFuIG9wdGlvbmFsIHdsX3BvaW50ZXIuYXhpc19zb3VyY2UgZXZlbnQsIHR3b1xuXHQgKlx0d2xfcG9pbnRlci5heGlzIGV2ZW50cyAoaG9yaXpvbnRhbCBhbmQgdmVydGljYWwpIGFuZCBmaW5hbGx5IGFcblx0ICpcdHdsX3BvaW50ZXIuZnJhbWUgZXZlbnQuIFRoZSBjbGllbnQgbWF5IHVzZSB0aGlzIGluZm9ybWF0aW9uIHRvXG5cdCAqXHRjYWxjdWxhdGUgYSBkaWFnb25hbCB2ZWN0b3IgZm9yIHNjcm9sbGluZy5cblx0ICpcblx0ICpcdFdoZW4gbXVsdGlwbGUgd2xfcG9pbnRlci5heGlzIGV2ZW50cyBvY2N1ciB3aXRoaW4gdGhlIHNhbWUgZnJhbWUsXG5cdCAqXHR0aGUgbW90aW9uIHZlY3RvciBpcyB0aGUgY29tYmluZWQgbW90aW9uIG9mIGFsbCBldmVudHMuXG5cdCAqXHRXaGVuIGEgd2xfcG9pbnRlci5heGlzIGFuZCBhIHdsX3BvaW50ZXIuYXhpc19zdG9wIGV2ZW50IG9jY3VyIHdpdGhpblxuXHQgKlx0dGhlIHNhbWUgZnJhbWUsIHRoaXMgaW5kaWNhdGVzIHRoYXQgYXhpcyBtb3ZlbWVudCBpbiBvbmUgYXhpcyBoYXNcblx0ICpcdHN0b3BwZWQgYnV0IGNvbnRpbnVlcyBpbiB0aGUgb3RoZXIgYXhpcy5cblx0ICpcdFdoZW4gbXVsdGlwbGUgd2xfcG9pbnRlci5heGlzX3N0b3AgZXZlbnRzIG9jY3VyIHdpdGhpbiB0aGUgc2FtZVxuXHQgKlx0ZnJhbWUsIHRoaXMgaW5kaWNhdGVzIHRoYXQgdGhlc2UgYXhlcyBzdG9wcGVkIGluIHRoZSBzYW1lIGluc3RhbmNlLlxuXHQgKlxuXHQgKlx0QSB3bF9wb2ludGVyLmZyYW1lIGV2ZW50IGlzIHNlbnQgZm9yIGV2ZXJ5IGxvZ2ljYWwgZXZlbnQgZ3JvdXAsXG5cdCAqXHRldmVuIGlmIHRoZSBncm91cCBvbmx5IGNvbnRhaW5zIGEgc2luZ2xlIHdsX3BvaW50ZXIgZXZlbnQuXG5cdCAqXHRTcGVjaWZpY2FsbHksIGEgY2xpZW50IG1heSBnZXQgYSBzZXF1ZW5jZTogbW90aW9uLCBmcmFtZSwgYnV0dG9uLFxuXHQgKlx0ZnJhbWUsIGF4aXMsIGZyYW1lLCBheGlzX3N0b3AsIGZyYW1lLlxuXHQgKlxuXHQgKlx0VGhlIHdsX3BvaW50ZXIuZW50ZXIgYW5kIHdsX3BvaW50ZXIubGVhdmUgZXZlbnRzIGFyZSBsb2dpY2FsIGV2ZW50c1xuXHQgKlx0Z2VuZXJhdGVkIGJ5IHRoZSBjb21wb3NpdG9yIGFuZCBub3QgdGhlIGhhcmR3YXJlLiBUaGVzZSBldmVudHMgYXJlXG5cdCAqXHRhbHNvIGdyb3VwZWQgYnkgYSB3bF9wb2ludGVyLmZyYW1lLiBXaGVuIGEgcG9pbnRlciBtb3ZlcyBmcm9tIG9uZVxuXHQgKlx0c3VyZmFjZSB0byBhbm90aGVyLCBhIGNvbXBvc2l0b3Igc2hvdWxkIGdyb3VwIHRoZVxuXHQgKlx0d2xfcG9pbnRlci5sZWF2ZSBldmVudCB3aXRoaW4gdGhlIHNhbWUgd2xfcG9pbnRlci5mcmFtZS5cblx0ICpcdEhvd2V2ZXIsIGEgY2xpZW50IG11c3Qgbm90IHJlbHkgb24gd2xfcG9pbnRlci5sZWF2ZSBhbmRcblx0ICpcdHdsX3BvaW50ZXIuZW50ZXIgYmVpbmcgaW4gdGhlIHNhbWUgd2xfcG9pbnRlci5mcmFtZS5cblx0ICpcdENvbXBvc2l0b3Itc3BlY2lmaWMgcG9saWNpZXMgbWF5IHJlcXVpcmUgdGhlIHdsX3BvaW50ZXIubGVhdmUgYW5kXG5cdCAqXHR3bF9wb2ludGVyLmVudGVyIGV2ZW50IGJlaW5nIHNwbGl0IGFjcm9zcyBtdWx0aXBsZSB3bF9wb2ludGVyLmZyYW1lXG5cdCAqXHRncm91cHMuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqXG5cdCAqIEBzaW5jZSA1XG5cdCAqXG5cdCAqL1xuXHRmcmFtZSgpIHt9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRTb3VyY2UgaW5mb3JtYXRpb24gZm9yIHNjcm9sbCBhbmQgb3RoZXIgYXhlcy5cblx0ICpcblx0ICpcdFRoaXMgZXZlbnQgZG9lcyBub3Qgb2NjdXIgb24gaXRzIG93bi4gSXQgaXMgc2VudCBiZWZvcmUgYVxuXHQgKlx0d2xfcG9pbnRlci5mcmFtZSBldmVudCBhbmQgY2FycmllcyB0aGUgc291cmNlIGluZm9ybWF0aW9uIGZvclxuXHQgKlx0YWxsIGV2ZW50cyB3aXRoaW4gdGhhdCBmcmFtZS5cblx0ICpcblx0ICpcdFRoZSBzb3VyY2Ugc3BlY2lmaWVzIGhvdyB0aGlzIGV2ZW50IHdhcyBnZW5lcmF0ZWQuIElmIHRoZSBzb3VyY2UgaXNcblx0ICpcdHdsX3BvaW50ZXIuYXhpc19zb3VyY2UuZmluZ2VyLCBhIHdsX3BvaW50ZXIuYXhpc19zdG9wIGV2ZW50IHdpbGwgYmVcblx0ICpcdHNlbnQgd2hlbiB0aGUgdXNlciBsaWZ0cyB0aGUgZmluZ2VyIG9mZiB0aGUgZGV2aWNlLlxuXHQgKlxuXHQgKlx0SWYgdGhlIHNvdXJjZSBpcyB3bF9wb2ludGVyLmF4aXNfc291cmNlLndoZWVsLFxuXHQgKlx0d2xfcG9pbnRlci5heGlzX3NvdXJjZS53aGVlbF90aWx0IG9yXG5cdCAqXHR3bF9wb2ludGVyLmF4aXNfc291cmNlLmNvbnRpbnVvdXMsIGEgd2xfcG9pbnRlci5heGlzX3N0b3AgZXZlbnQgbWF5XG5cdCAqXHRvciBtYXkgbm90IGJlIHNlbnQuIFdoZXRoZXIgYSBjb21wb3NpdG9yIHNlbmRzIGFuIGF4aXNfc3RvcCBldmVudFxuXHQgKlx0Zm9yIHRoZXNlIHNvdXJjZXMgaXMgaGFyZHdhcmUtc3BlY2lmaWMgYW5kIGltcGxlbWVudGF0aW9uLWRlcGVuZGVudDtcblx0ICpcdGNsaWVudHMgbXVzdCBub3QgcmVseSBvbiByZWNlaXZpbmcgYW4gYXhpc19zdG9wIGV2ZW50IGZvciB0aGVzZVxuXHQgKlx0c2Nyb2xsIHNvdXJjZXMgYW5kIHNob3VsZCB0cmVhdCBzY3JvbGwgc2VxdWVuY2VzIGZyb20gdGhlc2Ugc2Nyb2xsXG5cdCAqXHRzb3VyY2VzIGFzIHVudGVybWluYXRlZCBieSBkZWZhdWx0LlxuXHQgKlxuXHQgKlx0VGhpcyBldmVudCBpcyBvcHRpb25hbC4gSWYgdGhlIHNvdXJjZSBpcyB1bmtub3duIGZvciBhIHBhcnRpY3VsYXJcblx0ICpcdGF4aXMgZXZlbnQgc2VxdWVuY2UsIG5vIGV2ZW50IGlzIHNlbnQuXG5cdCAqXHRPbmx5IG9uZSB3bF9wb2ludGVyLmF4aXNfc291cmNlIGV2ZW50IGlzIHBlcm1pdHRlZCBwZXIgZnJhbWUuXG5cdCAqXG5cdCAqXHRUaGUgb3JkZXIgb2Ygd2xfcG9pbnRlci5heGlzX2Rpc2NyZXRlIGFuZCB3bF9wb2ludGVyLmF4aXNfc291cmNlIGlzXG5cdCAqXHRub3QgZ3VhcmFudGVlZC5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGF4aXNTb3VyY2Ugc291cmNlIG9mIHRoZSBheGlzIGV2ZW50IFxuXHQgKlxuXHQgKiBAc2luY2UgNVxuXHQgKlxuXHQgKi9cblx0YXhpc1NvdXJjZShheGlzU291cmNlKSB7fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0U3RvcCBub3RpZmljYXRpb24gZm9yIHNjcm9sbCBhbmQgb3RoZXIgYXhlcy5cblx0ICpcblx0ICpcdEZvciBzb21lIHdsX3BvaW50ZXIuYXhpc19zb3VyY2UgdHlwZXMsIGEgd2xfcG9pbnRlci5heGlzX3N0b3AgZXZlbnRcblx0ICpcdGlzIHNlbnQgdG8gbm90aWZ5IGEgY2xpZW50IHRoYXQgdGhlIGF4aXMgc2VxdWVuY2UgaGFzIHRlcm1pbmF0ZWQuXG5cdCAqXHRUaGlzIGVuYWJsZXMgdGhlIGNsaWVudCB0byBpbXBsZW1lbnQga2luZXRpYyBzY3JvbGxpbmcuXG5cdCAqXHRTZWUgdGhlIHdsX3BvaW50ZXIuYXhpc19zb3VyY2UgZG9jdW1lbnRhdGlvbiBmb3IgaW5mb3JtYXRpb24gb24gd2hlblxuXHQgKlx0dGhpcyBldmVudCBtYXkgYmUgZ2VuZXJhdGVkLlxuXHQgKlxuXHQgKlx0QW55IHdsX3BvaW50ZXIuYXhpcyBldmVudHMgd2l0aCB0aGUgc2FtZSBheGlzX3NvdXJjZSBhZnRlciB0aGlzXG5cdCAqXHRldmVudCBzaG91bGQgYmUgY29uc2lkZXJlZCBhcyB0aGUgc3RhcnQgb2YgYSBuZXcgYXhpcyBtb3Rpb24uXG5cdCAqXG5cdCAqXHRUaGUgdGltZXN0YW1wIGlzIHRvIGJlIGludGVycHJldGVkIGlkZW50aWNhbCB0byB0aGUgdGltZXN0YW1wIGluIHRoZVxuXHQgKlx0d2xfcG9pbnRlci5heGlzIGV2ZW50LiBUaGUgdGltZXN0YW1wIHZhbHVlIG1heSBiZSB0aGUgc2FtZSBhcyBhXG5cdCAqXHRwcmVjZWRpbmcgd2xfcG9pbnRlci5heGlzIGV2ZW50LlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gdGltZSB0aW1lc3RhbXAgd2l0aCBtaWxsaXNlY29uZCBncmFudWxhcml0eSBcblx0ICogQHBhcmFtIHtudW1iZXJ9IGF4aXMgdGhlIGF4aXMgc3RvcHBlZCB3aXRoIHRoaXMgZXZlbnQgXG5cdCAqXG5cdCAqIEBzaW5jZSA1XG5cdCAqXG5cdCAqL1xuXHRheGlzU3RvcCh0aW1lLCBheGlzKSB7fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0RGlzY3JldGUgc3RlcCBpbmZvcm1hdGlvbiBmb3Igc2Nyb2xsIGFuZCBvdGhlciBheGVzLlxuXHQgKlxuXHQgKlx0VGhpcyBldmVudCBjYXJyaWVzIHRoZSBheGlzIHZhbHVlIG9mIHRoZSB3bF9wb2ludGVyLmF4aXMgZXZlbnQgaW5cblx0ICpcdGRpc2NyZXRlIHN0ZXBzIChlLmcuIG1vdXNlIHdoZWVsIGNsaWNrcykuXG5cdCAqXG5cdCAqXHRUaGlzIGV2ZW50IGRvZXMgbm90IG9jY3VyIG9uIGl0cyBvd24sIGl0IGlzIGNvdXBsZWQgd2l0aCBhXG5cdCAqXHR3bF9wb2ludGVyLmF4aXMgZXZlbnQgdGhhdCByZXByZXNlbnRzIHRoaXMgYXhpcyB2YWx1ZSBvbiBhXG5cdCAqXHRjb250aW51b3VzIHNjYWxlLiBUaGUgcHJvdG9jb2wgZ3VhcmFudGVlcyB0aGF0IGVhY2ggYXhpc19kaXNjcmV0ZVxuXHQgKlx0ZXZlbnQgaXMgYWx3YXlzIGZvbGxvd2VkIGJ5IGV4YWN0bHkgb25lIGF4aXMgZXZlbnQgd2l0aCB0aGUgc2FtZVxuXHQgKlx0YXhpcyBudW1iZXIgd2l0aGluIHRoZSBzYW1lIHdsX3BvaW50ZXIuZnJhbWUuIE5vdGUgdGhhdCB0aGUgcHJvdG9jb2xcblx0ICpcdGFsbG93cyBmb3Igb3RoZXIgZXZlbnRzIHRvIG9jY3VyIGJldHdlZW4gdGhlIGF4aXNfZGlzY3JldGUgYW5kXG5cdCAqXHRpdHMgY291cGxlZCBheGlzIGV2ZW50LCBpbmNsdWRpbmcgb3RoZXIgYXhpc19kaXNjcmV0ZSBvciBheGlzXG5cdCAqXHRldmVudHMuXG5cdCAqXG5cdCAqXHRUaGlzIGV2ZW50IGlzIG9wdGlvbmFsOyBjb250aW51b3VzIHNjcm9sbGluZyBkZXZpY2VzXG5cdCAqXHRsaWtlIHR3by1maW5nZXIgc2Nyb2xsaW5nIG9uIHRvdWNocGFkcyBkbyBub3QgaGF2ZSBkaXNjcmV0ZVxuXHQgKlx0c3RlcHMgYW5kIGRvIG5vdCBnZW5lcmF0ZSB0aGlzIGV2ZW50LlxuXHQgKlxuXHQgKlx0VGhlIGRpc2NyZXRlIHZhbHVlIGNhcnJpZXMgdGhlIGRpcmVjdGlvbmFsIGluZm9ybWF0aW9uLiBlLmcuIGEgdmFsdWVcblx0ICpcdG9mIC0yIGlzIHR3byBzdGVwcyB0b3dhcmRzIHRoZSBuZWdhdGl2ZSBkaXJlY3Rpb24gb2YgdGhpcyBheGlzLlxuXHQgKlxuXHQgKlx0VGhlIGF4aXMgbnVtYmVyIGlzIGlkZW50aWNhbCB0byB0aGUgYXhpcyBudW1iZXIgaW4gdGhlIGFzc29jaWF0ZWRcblx0ICpcdGF4aXMgZXZlbnQuXG5cdCAqXG5cdCAqXHRUaGUgb3JkZXIgb2Ygd2xfcG9pbnRlci5heGlzX2Rpc2NyZXRlIGFuZCB3bF9wb2ludGVyLmF4aXNfc291cmNlIGlzXG5cdCAqXHRub3QgZ3VhcmFudGVlZC5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGF4aXMgYXhpcyB0eXBlIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gZGlzY3JldGUgbnVtYmVyIG9mIHN0ZXBzIFxuXHQgKlxuXHQgKiBAc2luY2UgNVxuXHQgKlxuXHQgKi9cblx0YXhpc0Rpc2NyZXRlKGF4aXMsIGRpc2NyZXRlKSB7fVxufVxuXG4iLCIvKlxuICpcbiAqICAgIENvcHlyaWdodCDCqSAyMDA4LTIwMTEgS3Jpc3RpYW4gSMO4Z3NiZXJnXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMC0yMDExIEludGVsIENvcnBvcmF0aW9uXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMi0yMDEzIENvbGxhYm9yYSwgTHRkLlxuICpcbiAqICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICogICAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICogICAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAqICAgIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gKiAgICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogICAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgKGluY2x1ZGluZyB0aGVcbiAqICAgIG5leHQgcGFyYWdyYXBoKSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsXG4gKiAgICBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogICAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqICAgIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gKiAgICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAqICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gKiAgICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiAgICBTT0ZUV0FSRS5cbiAqICBcbiAqL1xuXG5pbXBvcnQgeyBDb25uZWN0aW9uIH0gZnJvbSAnd2VzdGZpZWxkLXJ1bnRpbWUtY29tbW9uJ1xuY29uc3QgeyB1aW50LCB1aW50T3B0aW9uYWwsIGludCwgaW50T3B0aW9uYWwsIGZpeGVkLCBcblx0Zml4ZWRPcHRpb25hbCwgb2JqZWN0LCBvYmplY3RPcHRpb25hbCwgbmV3T2JqZWN0LCBzdHJpbmcsIFxuXHRzdHJpbmdPcHRpb25hbCwgYXJyYXksIGFycmF5T3B0aW9uYWwsIFxuXHRmaWxlRGVzY3JpcHRvck9wdGlvbmFsLCBmaWxlRGVzY3JpcHRvciwgXG5oLCB1LCBpLCBmLCBvLCBuLCBzLCBhIH0gPSBDb25uZWN0aW9uXG5pbXBvcnQgUHJveHkgZnJvbSAnLi9Qcm94eSdcblxuLyoqXG4gKlxuICogICAgICBUaGUgd2xfcG9pbnRlciBpbnRlcmZhY2UgcmVwcmVzZW50cyBvbmUgb3IgbW9yZSBpbnB1dCBkZXZpY2VzLFxuICogICAgICBzdWNoIGFzIG1pY2UsIHdoaWNoIGNvbnRyb2wgdGhlIHBvaW50ZXIgbG9jYXRpb24gYW5kIHBvaW50ZXJfZm9jdXNcbiAqICAgICAgb2YgYSBzZWF0LlxuICpcbiAqICAgICAgVGhlIHdsX3BvaW50ZXIgaW50ZXJmYWNlIGdlbmVyYXRlcyBtb3Rpb24sIGVudGVyIGFuZCBsZWF2ZVxuICogICAgICBldmVudHMgZm9yIHRoZSBzdXJmYWNlcyB0aGF0IHRoZSBwb2ludGVyIGlzIGxvY2F0ZWQgb3ZlcixcbiAqICAgICAgYW5kIGJ1dHRvbiBhbmQgYXhpcyBldmVudHMgZm9yIGJ1dHRvbiBwcmVzc2VzLCBidXR0b24gcmVsZWFzZXNcbiAqICAgICAgYW5kIHNjcm9sbGluZy5cbiAqICAgIFxuICovXG5jbGFzcyBXbFBvaW50ZXJQcm94eSBleHRlbmRzIFByb3h5IHtcblxuXHQvKipcblx0ICpcblx0ICpcdFNldCB0aGUgcG9pbnRlciBzdXJmYWNlLCBpLmUuLCB0aGUgc3VyZmFjZSB0aGF0IGNvbnRhaW5zIHRoZVxuXHQgKlx0cG9pbnRlciBpbWFnZSAoY3Vyc29yKS4gVGhpcyByZXF1ZXN0IGdpdmVzIHRoZSBzdXJmYWNlIHRoZSByb2xlXG5cdCAqXHRvZiBhIGN1cnNvci4gSWYgdGhlIHN1cmZhY2UgYWxyZWFkeSBoYXMgYW5vdGhlciByb2xlLCBpdCByYWlzZXNcblx0ICpcdGEgcHJvdG9jb2wgZXJyb3IuXG5cdCAqXG5cdCAqXHRUaGUgY3Vyc29yIGFjdHVhbGx5IGNoYW5nZXMgb25seSBpZiB0aGUgcG9pbnRlclxuXHQgKlx0Zm9jdXMgZm9yIHRoaXMgZGV2aWNlIGlzIG9uZSBvZiB0aGUgcmVxdWVzdGluZyBjbGllbnQncyBzdXJmYWNlc1xuXHQgKlx0b3IgdGhlIHN1cmZhY2UgcGFyYW1ldGVyIGlzIHRoZSBjdXJyZW50IHBvaW50ZXIgc3VyZmFjZS4gSWZcblx0ICpcdHRoZXJlIHdhcyBhIHByZXZpb3VzIHN1cmZhY2Ugc2V0IHdpdGggdGhpcyByZXF1ZXN0IGl0IGlzXG5cdCAqXHRyZXBsYWNlZC4gSWYgc3VyZmFjZSBpcyBOVUxMLCB0aGUgcG9pbnRlciBpbWFnZSBpcyBoaWRkZW4uXG5cdCAqXG5cdCAqXHRUaGUgcGFyYW1ldGVycyBob3RzcG90X3ggYW5kIGhvdHNwb3RfeSBkZWZpbmUgdGhlIHBvc2l0aW9uIG9mXG5cdCAqXHR0aGUgcG9pbnRlciBzdXJmYWNlIHJlbGF0aXZlIHRvIHRoZSBwb2ludGVyIGxvY2F0aW9uLiBJdHNcblx0ICpcdHRvcC1sZWZ0IGNvcm5lciBpcyBhbHdheXMgYXQgKHgsIHkpIC0gKGhvdHNwb3RfeCwgaG90c3BvdF95KSxcblx0ICpcdHdoZXJlICh4LCB5KSBhcmUgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludGVyIGxvY2F0aW9uLCBpblxuXHQgKlx0c3VyZmFjZS1sb2NhbCBjb29yZGluYXRlcy5cblx0ICpcblx0ICpcdE9uIHN1cmZhY2UuYXR0YWNoIHJlcXVlc3RzIHRvIHRoZSBwb2ludGVyIHN1cmZhY2UsIGhvdHNwb3RfeFxuXHQgKlx0YW5kIGhvdHNwb3RfeSBhcmUgZGVjcmVtZW50ZWQgYnkgdGhlIHggYW5kIHkgcGFyYW1ldGVyc1xuXHQgKlx0cGFzc2VkIHRvIHRoZSByZXF1ZXN0LiBBdHRhY2ggbXVzdCBiZSBjb25maXJtZWQgYnlcblx0ICpcdHdsX3N1cmZhY2UuY29tbWl0IGFzIHVzdWFsLlxuXHQgKlxuXHQgKlx0VGhlIGhvdHNwb3QgY2FuIGFsc28gYmUgdXBkYXRlZCBieSBwYXNzaW5nIHRoZSBjdXJyZW50bHkgc2V0XG5cdCAqXHRwb2ludGVyIHN1cmZhY2UgdG8gdGhpcyByZXF1ZXN0IHdpdGggbmV3IHZhbHVlcyBmb3IgaG90c3BvdF94XG5cdCAqXHRhbmQgaG90c3BvdF95LlxuXHQgKlxuXHQgKlx0VGhlIGN1cnJlbnQgYW5kIHBlbmRpbmcgaW5wdXQgcmVnaW9ucyBvZiB0aGUgd2xfc3VyZmFjZSBhcmVcblx0ICpcdGNsZWFyZWQsIGFuZCB3bF9zdXJmYWNlLnNldF9pbnB1dF9yZWdpb24gaXMgaWdub3JlZCB1bnRpbCB0aGVcblx0ICpcdHdsX3N1cmZhY2UgaXMgbm8gbG9uZ2VyIHVzZWQgYXMgdGhlIGN1cnNvci4gV2hlbiB0aGUgdXNlIGFzIGFcblx0ICpcdGN1cnNvciBlbmRzLCB0aGUgY3VycmVudCBhbmQgcGVuZGluZyBpbnB1dCByZWdpb25zIGJlY29tZVxuXHQgKlx0dW5kZWZpbmVkLCBhbmQgdGhlIHdsX3N1cmZhY2UgaXMgdW5tYXBwZWQuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzZXJpYWwgc2VyaWFsIG51bWJlciBvZiB0aGUgZW50ZXIgZXZlbnQgXG5cdCAqIEBwYXJhbSB7Pyp9IHN1cmZhY2UgcG9pbnRlciBzdXJmYWNlIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gaG90c3BvdFggc3VyZmFjZS1sb2NhbCB4IGNvb3JkaW5hdGUgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBob3RzcG90WSBzdXJmYWNlLWxvY2FsIHkgY29vcmRpbmF0ZSBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdHNldEN1cnNvciAoc2VyaWFsLCBzdXJmYWNlLCBob3RzcG90WCwgaG90c3BvdFkpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCAwLCBbdWludChzZXJpYWwpLCBvYmplY3RPcHRpb25hbChzdXJmYWNlKSwgaW50KGhvdHNwb3RYKSwgaW50KGhvdHNwb3RZKV0pXG5cdH1cblxuXHQvKipcblx0ICpcblx0ICpcdFVzaW5nIHRoaXMgcmVxdWVzdCBhIGNsaWVudCBjYW4gdGVsbCB0aGUgc2VydmVyIHRoYXQgaXQgaXMgbm90IGdvaW5nIHRvXG5cdCAqXHR1c2UgdGhlIHBvaW50ZXIgb2JqZWN0IGFueW1vcmUuXG5cdCAqXG5cdCAqXHRUaGlzIHJlcXVlc3QgZGVzdHJveXMgdGhlIHBvaW50ZXIgcHJveHkgb2JqZWN0LCBzbyBjbGllbnRzIG11c3Qgbm90IGNhbGxcblx0ICpcdHdsX3BvaW50ZXJfZGVzdHJveSgpIGFmdGVyIHVzaW5nIHRoaXMgcmVxdWVzdC5cblx0ICogICAgICBcblx0ICogQHNpbmNlIDNcblx0ICpcblx0ICovXG5cdHJlbGVhc2UgKCkge1xuXHRcdHN1cGVyLmRlc3Ryb3koKVxuXHRcdHRoaXMuX21hcnNoYWxsKHRoaXMuaWQsIDEsIFtdKVxuXHR9XG5cblx0LyoqXG5cdCAqIERvIG5vdCBjb25zdHJ1Y3QgcHJveGllcyBkaXJlY3RseS4gSW5zdGVhZCB1c2Ugb25lIG9mIHRoZSBmYWN0b3J5IG1ldGhvZHMgZnJvbSBvdGhlciBwcm94aWVzLlxuXHQgKkBwYXJhbSB7RGlzcGxheX1kaXNwbGF5XG5cdCAqQHBhcmFtIHtDb25uZWN0aW9ufWNvbm5lY3Rpb25cblx0ICpAcGFyYW0ge251bWJlcn1pZFxuXHQgKi9cblx0Y29uc3RydWN0b3IgKGRpc3BsYXksIGNvbm5lY3Rpb24sIGlkKSB7XG5cdFx0c3VwZXIoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge1dsUG9pbnRlckV2ZW50c3xudWxsfVxuXHRcdCAqL1xuXHRcdHRoaXMubGlzdGVuZXIgPSBudWxsXG5cdH1cblxuXHRhc3luYyBbMF0gKG1lc3NhZ2UpIHtcblx0XHRhd2FpdCB0aGlzLmxpc3RlbmVyLmVudGVyKHUobWVzc2FnZSksIG8obWVzc2FnZSwgZmFsc2UsIHRoaXMuX2Nvbm5lY3Rpb24pLCBmKG1lc3NhZ2UpLCBmKG1lc3NhZ2UpKVxuXHR9XG5cblx0YXN5bmMgWzFdIChtZXNzYWdlKSB7XG5cdFx0YXdhaXQgdGhpcy5saXN0ZW5lci5sZWF2ZSh1KG1lc3NhZ2UpLCBvKG1lc3NhZ2UsIGZhbHNlLCB0aGlzLl9jb25uZWN0aW9uKSlcblx0fVxuXG5cdGFzeW5jIFsyXSAobWVzc2FnZSkge1xuXHRcdGF3YWl0IHRoaXMubGlzdGVuZXIubW90aW9uKHUobWVzc2FnZSksIGYobWVzc2FnZSksIGYobWVzc2FnZSkpXG5cdH1cblxuXHRhc3luYyBbM10gKG1lc3NhZ2UpIHtcblx0XHRhd2FpdCB0aGlzLmxpc3RlbmVyLmJ1dHRvbih1KG1lc3NhZ2UpLCB1KG1lc3NhZ2UpLCB1KG1lc3NhZ2UpLCB1KG1lc3NhZ2UpKVxuXHR9XG5cblx0YXN5bmMgWzRdIChtZXNzYWdlKSB7XG5cdFx0YXdhaXQgdGhpcy5saXN0ZW5lci5heGlzKHUobWVzc2FnZSksIHUobWVzc2FnZSksIGYobWVzc2FnZSkpXG5cdH1cblxuXHRhc3luYyBbNV0gKG1lc3NhZ2UpIHtcblx0XHRhd2FpdCB0aGlzLmxpc3RlbmVyLmZyYW1lKClcblx0fVxuXG5cdGFzeW5jIFs2XSAobWVzc2FnZSkge1xuXHRcdGF3YWl0IHRoaXMubGlzdGVuZXIuYXhpc1NvdXJjZSh1KG1lc3NhZ2UpKVxuXHR9XG5cblx0YXN5bmMgWzddIChtZXNzYWdlKSB7XG5cdFx0YXdhaXQgdGhpcy5saXN0ZW5lci5heGlzU3RvcCh1KG1lc3NhZ2UpLCB1KG1lc3NhZ2UpKVxuXHR9XG5cblx0YXN5bmMgWzhdIChtZXNzYWdlKSB7XG5cdFx0YXdhaXQgdGhpcy5saXN0ZW5lci5heGlzRGlzY3JldGUodShtZXNzYWdlKSwgaShtZXNzYWdlKSlcblx0fVxuXG59XG5XbFBvaW50ZXJQcm94eS5wcm90b2NvbE5hbWUgPSAnd2xfcG9pbnRlcidcblxuV2xQb2ludGVyUHJveHkuRXJyb3IgPSB7XG4gIC8qKlxuICAgKiBnaXZlbiB3bF9zdXJmYWNlIGhhcyBhbm90aGVyIHJvbGVcbiAgICovXG4gIHJvbGU6IDBcbn1cblxuV2xQb2ludGVyUHJveHkuQnV0dG9uU3RhdGUgPSB7XG4gIC8qKlxuICAgKiB0aGUgYnV0dG9uIGlzIG5vdCBwcmVzc2VkXG4gICAqL1xuICByZWxlYXNlZDogMCxcbiAgLyoqXG4gICAqIHRoZSBidXR0b24gaXMgcHJlc3NlZFxuICAgKi9cbiAgcHJlc3NlZDogMVxufVxuXG5XbFBvaW50ZXJQcm94eS5BeGlzID0ge1xuICAvKipcbiAgICogdmVydGljYWwgYXhpc1xuICAgKi9cbiAgdmVydGljYWxTY3JvbGw6IDAsXG4gIC8qKlxuICAgKiBob3Jpem9udGFsIGF4aXNcbiAgICovXG4gIGhvcml6b250YWxTY3JvbGw6IDFcbn1cblxuV2xQb2ludGVyUHJveHkuQXhpc1NvdXJjZSA9IHtcbiAgLyoqXG4gICAqIGEgcGh5c2ljYWwgd2hlZWwgcm90YXRpb25cbiAgICovXG4gIHdoZWVsOiAwLFxuICAvKipcbiAgICogZmluZ2VyIG9uIGEgdG91Y2ggc3VyZmFjZVxuICAgKi9cbiAgZmluZ2VyOiAxLFxuICAvKipcbiAgICogY29udGludW91cyBjb29yZGluYXRlIHNwYWNlXG4gICAqL1xuICBjb250aW51b3VzOiAyLFxuICAvKipcbiAgICogYSBwaHlzaWNhbCB3aGVlbCB0aWx0XG4gICAqL1xuICB3aGVlbFRpbHQ6IDNcbn1cblxuZXhwb3J0IGRlZmF1bHQgV2xQb2ludGVyUHJveHlcbiIsIi8qXG4gKlxuICogICAgQ29weXJpZ2h0IMKpIDIwMDgtMjAxMSBLcmlzdGlhbiBIw7hnc2JlcmdcbiAqICAgIENvcHlyaWdodCDCqSAyMDEwLTIwMTEgSW50ZWwgQ29ycG9yYXRpb25cbiAqICAgIENvcHlyaWdodCDCqSAyMDEyLTIwMTMgQ29sbGFib3JhLCBMdGQuXG4gKlxuICogICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gKiAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSAoaW5jbHVkaW5nIHRoZVxuICogICAgbmV4dCBwYXJhZ3JhcGgpIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWxcbiAqICAgIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogICAgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAqICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICogICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAqICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqICAgIFNPRlRXQVJFLlxuICogIFxuICovXG5cbmltcG9ydCB7IENvbm5lY3Rpb24gfSBmcm9tICd3ZXN0ZmllbGQtcnVudGltZS1jb21tb24nXG5jb25zdCB7IHVpbnQsIHVpbnRPcHRpb25hbCwgaW50LCBpbnRPcHRpb25hbCwgZml4ZWQsIFxuXHRmaXhlZE9wdGlvbmFsLCBvYmplY3QsIG9iamVjdE9wdGlvbmFsLCBuZXdPYmplY3QsIHN0cmluZywgXG5cdHN0cmluZ09wdGlvbmFsLCBhcnJheSwgYXJyYXlPcHRpb25hbCwgXG5cdGZpbGVEZXNjcmlwdG9yT3B0aW9uYWwsIGZpbGVEZXNjcmlwdG9yLCBcbmgsIHUsIGksIGYsIG8sIG4sIHMsIGEgfSA9IENvbm5lY3Rpb25cbmltcG9ydCBQcm94eSBmcm9tICcuL1Byb3h5J1xuXG4vKipcbiAqXG4gKiAgICAgIEEgcmVnaW9uIG9iamVjdCBkZXNjcmliZXMgYW4gYXJlYS5cbiAqXG4gKiAgICAgIFJlZ2lvbiBvYmplY3RzIGFyZSB1c2VkIHRvIGRlc2NyaWJlIHRoZSBvcGFxdWUgYW5kIGlucHV0XG4gKiAgICAgIHJlZ2lvbnMgb2YgYSBzdXJmYWNlLlxuICogICAgXG4gKi9cbmNsYXNzIFdsUmVnaW9uUHJveHkgZXh0ZW5kcyBQcm94eSB7XG5cblx0LyoqXG5cdCAqXG5cdCAqXHREZXN0cm95IHRoZSByZWdpb24uICBUaGlzIHdpbGwgaW52YWxpZGF0ZSB0aGUgb2JqZWN0IElELlxuXHQgKiAgICAgIFxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0ZGVzdHJveSAoKSB7XG5cdFx0c3VwZXIuZGVzdHJveSgpXG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgMCwgW10pXG5cdH1cblxuXHQvKipcblx0ICpcblx0ICpcdEFkZCB0aGUgc3BlY2lmaWVkIHJlY3RhbmdsZSB0byB0aGUgcmVnaW9uLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCByZWdpb24tbG9jYWwgeCBjb29yZGluYXRlIFxuXHQgKiBAcGFyYW0ge251bWJlcn0geSByZWdpb24tbG9jYWwgeSBjb29yZGluYXRlIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggcmVjdGFuZ2xlIHdpZHRoIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IHJlY3RhbmdsZSBoZWlnaHQgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRhZGQgKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCAxLCBbaW50KHgpLCBpbnQoeSksIGludCh3aWR0aCksIGludChoZWlnaHQpXSlcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0U3VidHJhY3QgdGhlIHNwZWNpZmllZCByZWN0YW5nbGUgZnJvbSB0aGUgcmVnaW9uLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCByZWdpb24tbG9jYWwgeCBjb29yZGluYXRlIFxuXHQgKiBAcGFyYW0ge251bWJlcn0geSByZWdpb24tbG9jYWwgeSBjb29yZGluYXRlIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggcmVjdGFuZ2xlIHdpZHRoIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IHJlY3RhbmdsZSBoZWlnaHQgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRzdWJ0cmFjdCAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdHRoaXMuX21hcnNoYWxsKHRoaXMuaWQsIDIsIFtpbnQoeCksIGludCh5KSwgaW50KHdpZHRoKSwgaW50KGhlaWdodCldKVxuXHR9XG5cblx0LyoqXG5cdCAqIERvIG5vdCBjb25zdHJ1Y3QgcHJveGllcyBkaXJlY3RseS4gSW5zdGVhZCB1c2Ugb25lIG9mIHRoZSBmYWN0b3J5IG1ldGhvZHMgZnJvbSBvdGhlciBwcm94aWVzLlxuXHQgKkBwYXJhbSB7RGlzcGxheX1kaXNwbGF5XG5cdCAqQHBhcmFtIHtDb25uZWN0aW9ufWNvbm5lY3Rpb25cblx0ICpAcGFyYW0ge251bWJlcn1pZFxuXHQgKi9cblx0Y29uc3RydWN0b3IgKGRpc3BsYXksIGNvbm5lY3Rpb24sIGlkKSB7XG5cdFx0c3VwZXIoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge1dsUmVnaW9uRXZlbnRzfG51bGx9XG5cdFx0ICovXG5cdFx0dGhpcy5saXN0ZW5lciA9IG51bGxcblx0fVxuXG59XG5XbFJlZ2lvblByb3h5LnByb3RvY29sTmFtZSA9ICd3bF9yZWdpb24nXG5cbmV4cG9ydCBkZWZhdWx0IFdsUmVnaW9uUHJveHlcbiIsIi8qXG4gKlxuICogICAgQ29weXJpZ2h0IMKpIDIwMDgtMjAxMSBLcmlzdGlhbiBIw7hnc2JlcmdcbiAqICAgIENvcHlyaWdodCDCqSAyMDEwLTIwMTEgSW50ZWwgQ29ycG9yYXRpb25cbiAqICAgIENvcHlyaWdodCDCqSAyMDEyLTIwMTMgQ29sbGFib3JhLCBMdGQuXG4gKlxuICogICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gKiAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSAoaW5jbHVkaW5nIHRoZVxuICogICAgbmV4dCBwYXJhZ3JhcGgpIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWxcbiAqICAgIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogICAgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAqICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICogICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAqICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqICAgIFNPRlRXQVJFLlxuICogIFxuICovXG5cbi8qKlxuICogQGludGVyZmFjZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXbFJlZ2lzdHJ5RXZlbnRzIHtcblxuXHQvKipcblx0ICpcblx0ICpcdE5vdGlmeSB0aGUgY2xpZW50IG9mIGdsb2JhbCBvYmplY3RzLlxuXHQgKlxuXHQgKlx0VGhlIGV2ZW50IG5vdGlmaWVzIHRoZSBjbGllbnQgdGhhdCBhIGdsb2JhbCBvYmplY3Qgd2l0aFxuXHQgKlx0dGhlIGdpdmVuIG5hbWUgaXMgbm93IGF2YWlsYWJsZSwgYW5kIGl0IGltcGxlbWVudHMgdGhlXG5cdCAqXHRnaXZlbiB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBpbnRlcmZhY2UuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBuYW1lIG51bWVyaWMgbmFtZSBvZiB0aGUgZ2xvYmFsIG9iamVjdCBcblx0ICogQHBhcmFtIHtzdHJpbmd9IGludGVyZmFjZSBpbnRlcmZhY2UgaW1wbGVtZW50ZWQgYnkgdGhlIG9iamVjdCBcblx0ICogQHBhcmFtIHtudW1iZXJ9IHZlcnNpb24gaW50ZXJmYWNlIHZlcnNpb24gXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRnbG9iYWwobmFtZSwgaW50ZXJmYWNlXywgdmVyc2lvbikge31cblxuXHQvKipcblx0ICpcblx0ICpcdE5vdGlmeSB0aGUgY2xpZW50IG9mIHJlbW92ZWQgZ2xvYmFsIG9iamVjdHMuXG5cdCAqXG5cdCAqXHRUaGlzIGV2ZW50IG5vdGlmaWVzIHRoZSBjbGllbnQgdGhhdCB0aGUgZ2xvYmFsIGlkZW50aWZpZWRcblx0ICpcdGJ5IG5hbWUgaXMgbm8gbG9uZ2VyIGF2YWlsYWJsZS4gIElmIHRoZSBjbGllbnQgYm91bmQgdG9cblx0ICpcdHRoZSBnbG9iYWwgdXNpbmcgdGhlIGJpbmQgcmVxdWVzdCwgdGhlIGNsaWVudCBzaG91bGQgbm93XG5cdCAqXHRkZXN0cm95IHRoYXQgb2JqZWN0LlxuXHQgKlxuXHQgKlx0VGhlIG9iamVjdCByZW1haW5zIHZhbGlkIGFuZCByZXF1ZXN0cyB0byB0aGUgb2JqZWN0IHdpbGwgYmVcblx0ICpcdGlnbm9yZWQgdW50aWwgdGhlIGNsaWVudCBkZXN0cm95cyBpdCwgdG8gYXZvaWQgcmFjZXMgYmV0d2VlblxuXHQgKlx0dGhlIGdsb2JhbCBnb2luZyBhd2F5IGFuZCBhIGNsaWVudCBzZW5kaW5nIGEgcmVxdWVzdCB0byBpdC5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IG5hbWUgbnVtZXJpYyBuYW1lIG9mIHRoZSBnbG9iYWwgb2JqZWN0IFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0Z2xvYmFsUmVtb3ZlKG5hbWUpIHt9XG59XG5cbiIsIi8qXG4gKlxuICogICAgQ29weXJpZ2h0IMKpIDIwMDgtMjAxMSBLcmlzdGlhbiBIw7hnc2JlcmdcbiAqICAgIENvcHlyaWdodCDCqSAyMDEwLTIwMTEgSW50ZWwgQ29ycG9yYXRpb25cbiAqICAgIENvcHlyaWdodCDCqSAyMDEyLTIwMTMgQ29sbGFib3JhLCBMdGQuXG4gKlxuICogICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gKiAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSAoaW5jbHVkaW5nIHRoZVxuICogICAgbmV4dCBwYXJhZ3JhcGgpIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWxcbiAqICAgIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogICAgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAqICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICogICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAqICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqICAgIFNPRlRXQVJFLlxuICogIFxuICovXG5cbmltcG9ydCB7IENvbm5lY3Rpb24gfSBmcm9tICd3ZXN0ZmllbGQtcnVudGltZS1jb21tb24nXG5jb25zdCB7IHVpbnQsIHVpbnRPcHRpb25hbCwgaW50LCBpbnRPcHRpb25hbCwgZml4ZWQsIFxuXHRmaXhlZE9wdGlvbmFsLCBvYmplY3QsIG9iamVjdE9wdGlvbmFsLCBuZXdPYmplY3QsIHN0cmluZywgXG5cdHN0cmluZ09wdGlvbmFsLCBhcnJheSwgYXJyYXlPcHRpb25hbCwgXG5cdGZpbGVEZXNjcmlwdG9yT3B0aW9uYWwsIGZpbGVEZXNjcmlwdG9yLCBcbmgsIHUsIGksIGYsIG8sIG4sIHMsIGEgfSA9IENvbm5lY3Rpb25cbmltcG9ydCBQcm94eSBmcm9tICcuL1Byb3h5J1xuXG4vKipcbiAqXG4gKiAgICAgIFRoZSBzaW5nbGV0b24gZ2xvYmFsIHJlZ2lzdHJ5IG9iamVjdC4gIFRoZSBzZXJ2ZXIgaGFzIGEgbnVtYmVyIG9mXG4gKiAgICAgIGdsb2JhbCBvYmplY3RzIHRoYXQgYXJlIGF2YWlsYWJsZSB0byBhbGwgY2xpZW50cy4gIFRoZXNlIG9iamVjdHNcbiAqICAgICAgdHlwaWNhbGx5IHJlcHJlc2VudCBhbiBhY3R1YWwgb2JqZWN0IGluIHRoZSBzZXJ2ZXIgKGZvciBleGFtcGxlLFxuICogICAgICBhbiBpbnB1dCBkZXZpY2UpIG9yIHRoZXkgYXJlIHNpbmdsZXRvbiBvYmplY3RzIHRoYXQgcHJvdmlkZVxuICogICAgICBleHRlbnNpb24gZnVuY3Rpb25hbGl0eS5cbiAqXG4gKiAgICAgIFdoZW4gYSBjbGllbnQgY3JlYXRlcyBhIHJlZ2lzdHJ5IG9iamVjdCwgdGhlIHJlZ2lzdHJ5IG9iamVjdFxuICogICAgICB3aWxsIGVtaXQgYSBnbG9iYWwgZXZlbnQgZm9yIGVhY2ggZ2xvYmFsIGN1cnJlbnRseSBpbiB0aGVcbiAqICAgICAgcmVnaXN0cnkuICBHbG9iYWxzIGNvbWUgYW5kIGdvIGFzIGEgcmVzdWx0IG9mIGRldmljZSBvclxuICogICAgICBtb25pdG9yIGhvdHBsdWdzLCByZWNvbmZpZ3VyYXRpb24gb3Igb3RoZXIgZXZlbnRzLCBhbmQgdGhlXG4gKiAgICAgIHJlZ2lzdHJ5IHdpbGwgc2VuZCBvdXQgZ2xvYmFsIGFuZCBnbG9iYWxfcmVtb3ZlIGV2ZW50cyB0b1xuICogICAgICBrZWVwIHRoZSBjbGllbnQgdXAgdG8gZGF0ZSB3aXRoIHRoZSBjaGFuZ2VzLiAgVG8gbWFyayB0aGUgZW5kXG4gKiAgICAgIG9mIHRoZSBpbml0aWFsIGJ1cnN0IG9mIGV2ZW50cywgdGhlIGNsaWVudCBjYW4gdXNlIHRoZVxuICogICAgICB3bF9kaXNwbGF5LnN5bmMgcmVxdWVzdCBpbW1lZGlhdGVseSBhZnRlciBjYWxsaW5nXG4gKiAgICAgIHdsX2Rpc3BsYXkuZ2V0X3JlZ2lzdHJ5LlxuICpcbiAqICAgICAgQSBjbGllbnQgY2FuIGJpbmQgdG8gYSBnbG9iYWwgb2JqZWN0IGJ5IHVzaW5nIHRoZSBiaW5kXG4gKiAgICAgIHJlcXVlc3QuICBUaGlzIGNyZWF0ZXMgYSBjbGllbnQtc2lkZSBoYW5kbGUgdGhhdCBsZXRzIHRoZSBvYmplY3RcbiAqICAgICAgZW1pdCBldmVudHMgdG8gdGhlIGNsaWVudCBhbmQgbGV0cyB0aGUgY2xpZW50IGludm9rZSByZXF1ZXN0cyBvblxuICogICAgICB0aGUgb2JqZWN0LlxuICogICAgXG4gKi9cbmNsYXNzIFdsUmVnaXN0cnlQcm94eSBleHRlbmRzIFByb3h5IHtcblx0LyoqXG5cdCogQmluZCBhIG5ldyBvYmplY3QgdG8gdGhlIGdsb2JhbC5cblx0KlxuXHQqIEJpbmRzIGEgbmV3LCBjbGllbnQtY3JlYXRlZCBvYmplY3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgc3BlY2lmaWVkIG5hbWUgYXMgdGhlIGlkZW50aWZpZXIuXG5cdCpcblx0KiBAcGFyYW0ge251bWJlcn0gbmFtZSB1bmlxdWUgbnVtZXJpYyBuYW1lIG9mIHRoZSBnbG9iYWxcblx0KiBAcGFyYW0ge3N0cmluZ30gaW50ZXJmYWNlXyBpbnRlcmZhY2UgaW1wbGVtZW50ZWQgYnkgdGhlIG5ldyBvYmplY3Rcblx0KiBAcGFyYW0ge0Z1bmN0aW9ufSBwcm94eUNsYXNzXG5cdCogQHBhcmFtIHtudW1iZXJ9IHZlcnNpb24gVGhlIHZlcnNpb24gdXNlZCBhbmQgc3VwcG9ydGVkIGJ5IHRoZSBjbGllbnRcblx0KiBAcmV0dXJuIHtPYmplY3R9IGEgbmV3IGJvdW5kZWQgb2JqZWN0XG5cdCovXG5cdGJpbmQgKG5hbWUsIGludGVyZmFjZV8sIHByb3h5Q2xhc3MsIHZlcnNpb24pIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFyc2hhbGxDb25zdHJ1Y3Rvcih0aGlzLmlkLCAwLCBwcm94eUNsYXNzLCBbdWludChuYW1lKSwgc3RyaW5nKGludGVyZmFjZV8pLCB1aW50KHZlcnNpb24pLCBuZXdPYmplY3QoKV0pXG5cdH1cblxuXHQvKipcblx0ICogRG8gbm90IGNvbnN0cnVjdCBwcm94aWVzIGRpcmVjdGx5LiBJbnN0ZWFkIHVzZSBvbmUgb2YgdGhlIGZhY3RvcnkgbWV0aG9kcyBmcm9tIG90aGVyIHByb3hpZXMuXG5cdCAqQHBhcmFtIHtEaXNwbGF5fWRpc3BsYXlcblx0ICpAcGFyYW0ge0Nvbm5lY3Rpb259Y29ubmVjdGlvblxuXHQgKkBwYXJhbSB7bnVtYmVyfWlkXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciAoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpIHtcblx0XHRzdXBlcihkaXNwbGF5LCBjb25uZWN0aW9uLCBpZClcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7V2xSZWdpc3RyeUV2ZW50c3xudWxsfVxuXHRcdCAqL1xuXHRcdHRoaXMubGlzdGVuZXIgPSBudWxsXG5cdH1cblxuXHRhc3luYyBbMF0gKG1lc3NhZ2UpIHtcblx0XHRhd2FpdCB0aGlzLmxpc3RlbmVyLmdsb2JhbCh1KG1lc3NhZ2UpLCBzKG1lc3NhZ2UsIGZhbHNlKSwgdShtZXNzYWdlKSlcblx0fVxuXG5cdGFzeW5jIFsxXSAobWVzc2FnZSkge1xuXHRcdGF3YWl0IHRoaXMubGlzdGVuZXIuZ2xvYmFsUmVtb3ZlKHUobWVzc2FnZSkpXG5cdH1cblxufVxuV2xSZWdpc3RyeVByb3h5LnByb3RvY29sTmFtZSA9ICd3bF9yZWdpc3RyeSdcblxuZXhwb3J0IGRlZmF1bHQgV2xSZWdpc3RyeVByb3h5XG4iLCIvKlxuICpcbiAqICAgIENvcHlyaWdodCDCqSAyMDA4LTIwMTEgS3Jpc3RpYW4gSMO4Z3NiZXJnXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMC0yMDExIEludGVsIENvcnBvcmF0aW9uXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMi0yMDEzIENvbGxhYm9yYSwgTHRkLlxuICpcbiAqICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICogICAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICogICAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAqICAgIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gKiAgICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogICAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgKGluY2x1ZGluZyB0aGVcbiAqICAgIG5leHQgcGFyYWdyYXBoKSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsXG4gKiAgICBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogICAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqICAgIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gKiAgICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAqICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gKiAgICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiAgICBTT0ZUV0FSRS5cbiAqICBcbiAqL1xuXG4vKipcbiAqIEBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2xTZWF0RXZlbnRzIHtcblxuXHQvKipcblx0ICpcblx0ICpcdFRoaXMgaXMgZW1pdHRlZCB3aGVuZXZlciBhIHNlYXQgZ2FpbnMgb3IgbG9zZXMgdGhlIHBvaW50ZXIsXG5cdCAqXHRrZXlib2FyZCBvciB0b3VjaCBjYXBhYmlsaXRpZXMuICBUaGUgYXJndW1lbnQgaXMgYSBjYXBhYmlsaXR5XG5cdCAqXHRlbnVtIGNvbnRhaW5pbmcgdGhlIGNvbXBsZXRlIHNldCBvZiBjYXBhYmlsaXRpZXMgdGhpcyBzZWF0IGhhcy5cblx0ICpcblx0ICpcdFdoZW4gdGhlIHBvaW50ZXIgY2FwYWJpbGl0eSBpcyBhZGRlZCwgYSBjbGllbnQgbWF5IGNyZWF0ZSBhXG5cdCAqXHR3bF9wb2ludGVyIG9iamVjdCB1c2luZyB0aGUgd2xfc2VhdC5nZXRfcG9pbnRlciByZXF1ZXN0LiBUaGlzIG9iamVjdFxuXHQgKlx0d2lsbCByZWNlaXZlIHBvaW50ZXIgZXZlbnRzIHVudGlsIHRoZSBjYXBhYmlsaXR5IGlzIHJlbW92ZWQgaW4gdGhlXG5cdCAqXHRmdXR1cmUuXG5cdCAqXG5cdCAqXHRXaGVuIHRoZSBwb2ludGVyIGNhcGFiaWxpdHkgaXMgcmVtb3ZlZCwgYSBjbGllbnQgc2hvdWxkIGRlc3Ryb3kgdGhlXG5cdCAqXHR3bF9wb2ludGVyIG9iamVjdHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBzZWF0IHdoZXJlIHRoZSBjYXBhYmlsaXR5IHdhc1xuXHQgKlx0cmVtb3ZlZCwgdXNpbmcgdGhlIHdsX3BvaW50ZXIucmVsZWFzZSByZXF1ZXN0LiBObyBmdXJ0aGVyIHBvaW50ZXJcblx0ICpcdGV2ZW50cyB3aWxsIGJlIHJlY2VpdmVkIG9uIHRoZXNlIG9iamVjdHMuXG5cdCAqXG5cdCAqXHRJbiBzb21lIGNvbXBvc2l0b3JzLCBpZiBhIHNlYXQgcmVnYWlucyB0aGUgcG9pbnRlciBjYXBhYmlsaXR5IGFuZCBhXG5cdCAqXHRjbGllbnQgaGFzIGEgcHJldmlvdXNseSBvYnRhaW5lZCB3bF9wb2ludGVyIG9iamVjdCBvZiB2ZXJzaW9uIDQgb3Jcblx0ICpcdGxlc3MsIHRoYXQgb2JqZWN0IG1heSBzdGFydCBzZW5kaW5nIHBvaW50ZXIgZXZlbnRzIGFnYWluLiBUaGlzXG5cdCAqXHRiZWhhdmlvciBpcyBjb25zaWRlcmVkIGEgbWlzaW50ZXJwcmV0YXRpb24gb2YgdGhlIGludGVuZGVkIGJlaGF2aW9yXG5cdCAqXHRhbmQgbXVzdCBub3QgYmUgcmVsaWVkIHVwb24gYnkgdGhlIGNsaWVudC4gd2xfcG9pbnRlciBvYmplY3RzIG9mXG5cdCAqXHR2ZXJzaW9uIDUgb3IgbGF0ZXIgbXVzdCBub3Qgc2VuZCBldmVudHMgaWYgY3JlYXRlZCBiZWZvcmUgdGhlIG1vc3Rcblx0ICpcdHJlY2VudCBldmVudCBub3RpZnlpbmcgdGhlIGNsaWVudCBvZiBhbiBhZGRlZCBwb2ludGVyIGNhcGFiaWxpdHkuXG5cdCAqXG5cdCAqXHRUaGUgYWJvdmUgYmVoYXZpb3IgYWxzbyBhcHBsaWVzIHRvIHdsX2tleWJvYXJkIGFuZCB3bF90b3VjaCB3aXRoIHRoZVxuXHQgKlx0a2V5Ym9hcmQgYW5kIHRvdWNoIGNhcGFiaWxpdGllcywgcmVzcGVjdGl2ZWx5LlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gY2FwYWJpbGl0aWVzIGNhcGFiaWxpdGllcyBvZiB0aGUgc2VhdCBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdGNhcGFiaWxpdGllcyhjYXBhYmlsaXRpZXMpIHt9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRJbiBhIG11bHRpc2VhdCBjb25maWd1cmF0aW9uIHRoaXMgY2FuIGJlIHVzZWQgYnkgdGhlIGNsaWVudCB0byBoZWxwXG5cdCAqXHRpZGVudGlmeSB3aGljaCBwaHlzaWNhbCBkZXZpY2VzIHRoZSBzZWF0IHJlcHJlc2VudHMuIEJhc2VkIG9uXG5cdCAqXHR0aGUgc2VhdCBjb25maWd1cmF0aW9uIHVzZWQgYnkgdGhlIGNvbXBvc2l0b3IuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHNlYXQgaWRlbnRpZmllciBcblx0ICpcblx0ICogQHNpbmNlIDJcblx0ICpcblx0ICovXG5cdG5hbWUobmFtZSkge31cbn1cblxuIiwiLypcbiAqXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAwOC0yMDExIEtyaXN0aWFuIEjDuGdzYmVyZ1xuICogICAgQ29weXJpZ2h0IMKpIDIwMTAtMjAxMSBJbnRlbCBDb3Jwb3JhdGlvblxuICogICAgQ29weXJpZ2h0IMKpIDIwMTItMjAxMyBDb2xsYWJvcmEsIEx0ZC5cbiAqXG4gKiAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAqICAgICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAqICAgIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gKiAgICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICogICAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAqICAgIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIChpbmNsdWRpbmcgdGhlXG4gKiAgICBuZXh0IHBhcmFncmFwaCkgc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbFxuICogICAgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAqICAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiAgICBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICogICAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gKiAgICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICogICAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogICAgU09GVFdBUkUuXG4gKiAgXG4gKi9cblxuaW1wb3J0IHsgQ29ubmVjdGlvbiB9IGZyb20gJ3dlc3RmaWVsZC1ydW50aW1lLWNvbW1vbidcbmNvbnN0IHsgdWludCwgdWludE9wdGlvbmFsLCBpbnQsIGludE9wdGlvbmFsLCBmaXhlZCwgXG5cdGZpeGVkT3B0aW9uYWwsIG9iamVjdCwgb2JqZWN0T3B0aW9uYWwsIG5ld09iamVjdCwgc3RyaW5nLCBcblx0c3RyaW5nT3B0aW9uYWwsIGFycmF5LCBhcnJheU9wdGlvbmFsLCBcblx0ZmlsZURlc2NyaXB0b3JPcHRpb25hbCwgZmlsZURlc2NyaXB0b3IsIFxuaCwgdSwgaSwgZiwgbywgbiwgcywgYSB9ID0gQ29ubmVjdGlvblxuaW1wb3J0IFByb3h5IGZyb20gJy4vUHJveHknXG5pbXBvcnQgV2xQb2ludGVyUHJveHkgZnJvbSAnLi9XbFBvaW50ZXJQcm94eSdcbmltcG9ydCBXbEtleWJvYXJkUHJveHkgZnJvbSAnLi9XbEtleWJvYXJkUHJveHknXG5pbXBvcnQgV2xUb3VjaFByb3h5IGZyb20gJy4vV2xUb3VjaFByb3h5J1xuXG4vKipcbiAqXG4gKiAgICAgIEEgc2VhdCBpcyBhIGdyb3VwIG9mIGtleWJvYXJkcywgcG9pbnRlciBhbmQgdG91Y2ggZGV2aWNlcy4gVGhpc1xuICogICAgICBvYmplY3QgaXMgcHVibGlzaGVkIGFzIGEgZ2xvYmFsIGR1cmluZyBzdGFydCB1cCwgb3Igd2hlbiBzdWNoIGFcbiAqICAgICAgZGV2aWNlIGlzIGhvdCBwbHVnZ2VkLiAgQSBzZWF0IHR5cGljYWxseSBoYXMgYSBwb2ludGVyIGFuZFxuICogICAgICBtYWludGFpbnMgYSBrZXlib2FyZCBmb2N1cyBhbmQgYSBwb2ludGVyIGZvY3VzLlxuICogICAgXG4gKi9cbmNsYXNzIFdsU2VhdFByb3h5IGV4dGVuZHMgUHJveHkge1xuXG5cdC8qKlxuXHQgKlxuXHQgKlx0VGhlIElEIHByb3ZpZGVkIHdpbGwgYmUgaW5pdGlhbGl6ZWQgdG8gdGhlIHdsX3BvaW50ZXIgaW50ZXJmYWNlXG5cdCAqXHRmb3IgdGhpcyBzZWF0LlxuXHQgKlxuXHQgKlx0VGhpcyByZXF1ZXN0IG9ubHkgdGFrZXMgZWZmZWN0IGlmIHRoZSBzZWF0IGhhcyB0aGUgcG9pbnRlclxuXHQgKlx0Y2FwYWJpbGl0eSwgb3IgaGFzIGhhZCB0aGUgcG9pbnRlciBjYXBhYmlsaXR5IGluIHRoZSBwYXN0LlxuXHQgKlx0SXQgaXMgYSBwcm90b2NvbCB2aW9sYXRpb24gdG8gaXNzdWUgdGhpcyByZXF1ZXN0IG9uIGEgc2VhdCB0aGF0IGhhc1xuXHQgKlx0bmV2ZXIgaGFkIHRoZSBwb2ludGVyIGNhcGFiaWxpdHkuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEByZXR1cm4ge1dsUG9pbnRlclByb3h5fSBzZWF0IHBvaW50ZXIgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRnZXRQb2ludGVyICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFyc2hhbGxDb25zdHJ1Y3Rvcih0aGlzLmlkLCAwLCBXbFBvaW50ZXJQcm94eSwgW25ld09iamVjdCgpXSlcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0VGhlIElEIHByb3ZpZGVkIHdpbGwgYmUgaW5pdGlhbGl6ZWQgdG8gdGhlIHdsX2tleWJvYXJkIGludGVyZmFjZVxuXHQgKlx0Zm9yIHRoaXMgc2VhdC5cblx0ICpcblx0ICpcdFRoaXMgcmVxdWVzdCBvbmx5IHRha2VzIGVmZmVjdCBpZiB0aGUgc2VhdCBoYXMgdGhlIGtleWJvYXJkXG5cdCAqXHRjYXBhYmlsaXR5LCBvciBoYXMgaGFkIHRoZSBrZXlib2FyZCBjYXBhYmlsaXR5IGluIHRoZSBwYXN0LlxuXHQgKlx0SXQgaXMgYSBwcm90b2NvbCB2aW9sYXRpb24gdG8gaXNzdWUgdGhpcyByZXF1ZXN0IG9uIGEgc2VhdCB0aGF0IGhhc1xuXHQgKlx0bmV2ZXIgaGFkIHRoZSBrZXlib2FyZCBjYXBhYmlsaXR5LlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcmV0dXJuIHtXbEtleWJvYXJkUHJveHl9IHNlYXQga2V5Ym9hcmQgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRnZXRLZXlib2FyZCAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hcnNoYWxsQ29uc3RydWN0b3IodGhpcy5pZCwgMSwgV2xLZXlib2FyZFByb3h5LCBbbmV3T2JqZWN0KCldKVxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRUaGUgSUQgcHJvdmlkZWQgd2lsbCBiZSBpbml0aWFsaXplZCB0byB0aGUgd2xfdG91Y2ggaW50ZXJmYWNlXG5cdCAqXHRmb3IgdGhpcyBzZWF0LlxuXHQgKlxuXHQgKlx0VGhpcyByZXF1ZXN0IG9ubHkgdGFrZXMgZWZmZWN0IGlmIHRoZSBzZWF0IGhhcyB0aGUgdG91Y2hcblx0ICpcdGNhcGFiaWxpdHksIG9yIGhhcyBoYWQgdGhlIHRvdWNoIGNhcGFiaWxpdHkgaW4gdGhlIHBhc3QuXG5cdCAqXHRJdCBpcyBhIHByb3RvY29sIHZpb2xhdGlvbiB0byBpc3N1ZSB0aGlzIHJlcXVlc3Qgb24gYSBzZWF0IHRoYXQgaGFzXG5cdCAqXHRuZXZlciBoYWQgdGhlIHRvdWNoIGNhcGFiaWxpdHkuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEByZXR1cm4ge1dsVG91Y2hQcm94eX0gc2VhdCB0b3VjaCBpbnRlcmZhY2UgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRnZXRUb3VjaCAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hcnNoYWxsQ29uc3RydWN0b3IodGhpcy5pZCwgMiwgV2xUb3VjaFByb3h5LCBbbmV3T2JqZWN0KCldKVxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRVc2luZyB0aGlzIHJlcXVlc3QgYSBjbGllbnQgY2FuIHRlbGwgdGhlIHNlcnZlciB0aGF0IGl0IGlzIG5vdCBnb2luZyB0b1xuXHQgKlx0dXNlIHRoZSBzZWF0IG9iamVjdCBhbnltb3JlLlxuXHQgKiAgICAgIFxuXHQgKiBAc2luY2UgNVxuXHQgKlxuXHQgKi9cblx0cmVsZWFzZSAoKSB7XG5cdFx0c3VwZXIuZGVzdHJveSgpXG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgMywgW10pXG5cdH1cblxuXHQvKipcblx0ICogRG8gbm90IGNvbnN0cnVjdCBwcm94aWVzIGRpcmVjdGx5LiBJbnN0ZWFkIHVzZSBvbmUgb2YgdGhlIGZhY3RvcnkgbWV0aG9kcyBmcm9tIG90aGVyIHByb3hpZXMuXG5cdCAqQHBhcmFtIHtEaXNwbGF5fWRpc3BsYXlcblx0ICpAcGFyYW0ge0Nvbm5lY3Rpb259Y29ubmVjdGlvblxuXHQgKkBwYXJhbSB7bnVtYmVyfWlkXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciAoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpIHtcblx0XHRzdXBlcihkaXNwbGF5LCBjb25uZWN0aW9uLCBpZClcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7V2xTZWF0RXZlbnRzfG51bGx9XG5cdFx0ICovXG5cdFx0dGhpcy5saXN0ZW5lciA9IG51bGxcblx0fVxuXG5cdGFzeW5jIFswXSAobWVzc2FnZSkge1xuXHRcdGF3YWl0IHRoaXMubGlzdGVuZXIuY2FwYWJpbGl0aWVzKHUobWVzc2FnZSkpXG5cdH1cblxuXHRhc3luYyBbMV0gKG1lc3NhZ2UpIHtcblx0XHRhd2FpdCB0aGlzLmxpc3RlbmVyLm5hbWUocyhtZXNzYWdlLCBmYWxzZSkpXG5cdH1cblxufVxuV2xTZWF0UHJveHkucHJvdG9jb2xOYW1lID0gJ3dsX3NlYXQnXG5cbldsU2VhdFByb3h5LkNhcGFiaWxpdHkgPSB7XG4gIC8qKlxuICAgKiB0aGUgc2VhdCBoYXMgcG9pbnRlciBkZXZpY2VzXG4gICAqL1xuICBwb2ludGVyOiAxLFxuICAvKipcbiAgICogdGhlIHNlYXQgaGFzIG9uZSBvciBtb3JlIGtleWJvYXJkc1xuICAgKi9cbiAga2V5Ym9hcmQ6IDIsXG4gIC8qKlxuICAgKiB0aGUgc2VhdCBoYXMgdG91Y2ggZGV2aWNlc1xuICAgKi9cbiAgdG91Y2g6IDRcbn1cblxuZXhwb3J0IGRlZmF1bHQgV2xTZWF0UHJveHlcbiIsIi8qXG4gKlxuICogICAgQ29weXJpZ2h0IMKpIDIwMDgtMjAxMSBLcmlzdGlhbiBIw7hnc2JlcmdcbiAqICAgIENvcHlyaWdodCDCqSAyMDEwLTIwMTEgSW50ZWwgQ29ycG9yYXRpb25cbiAqICAgIENvcHlyaWdodCDCqSAyMDEyLTIwMTMgQ29sbGFib3JhLCBMdGQuXG4gKlxuICogICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gKiAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSAoaW5jbHVkaW5nIHRoZVxuICogICAgbmV4dCBwYXJhZ3JhcGgpIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWxcbiAqICAgIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogICAgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAqICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICogICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAqICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqICAgIFNPRlRXQVJFLlxuICogIFxuICovXG5cbmltcG9ydCB7IENvbm5lY3Rpb24gfSBmcm9tICd3ZXN0ZmllbGQtcnVudGltZS1jb21tb24nXG5jb25zdCB7IHVpbnQsIHVpbnRPcHRpb25hbCwgaW50LCBpbnRPcHRpb25hbCwgZml4ZWQsIFxuXHRmaXhlZE9wdGlvbmFsLCBvYmplY3QsIG9iamVjdE9wdGlvbmFsLCBuZXdPYmplY3QsIHN0cmluZywgXG5cdHN0cmluZ09wdGlvbmFsLCBhcnJheSwgYXJyYXlPcHRpb25hbCwgXG5cdGZpbGVEZXNjcmlwdG9yT3B0aW9uYWwsIGZpbGVEZXNjcmlwdG9yLCBcbmgsIHUsIGksIGYsIG8sIG4sIHMsIGEgfSA9IENvbm5lY3Rpb25cbmltcG9ydCBQcm94eSBmcm9tICcuL1Byb3h5J1xuaW1wb3J0IFdsU2hlbGxTdXJmYWNlUHJveHkgZnJvbSAnLi9XbFNoZWxsU3VyZmFjZVByb3h5J1xuXG4vKipcbiAqXG4gKiAgICAgIFRoaXMgaW50ZXJmYWNlIGlzIGltcGxlbWVudGVkIGJ5IHNlcnZlcnMgdGhhdCBwcm92aWRlXG4gKiAgICAgIGRlc2t0b3Atc3R5bGUgdXNlciBpbnRlcmZhY2VzLlxuICpcbiAqICAgICAgSXQgYWxsb3dzIGNsaWVudHMgdG8gYXNzb2NpYXRlIGEgd2xfc2hlbGxfc3VyZmFjZSB3aXRoXG4gKiAgICAgIGEgYmFzaWMgc3VyZmFjZS5cbiAqICAgIFxuICovXG5jbGFzcyBXbFNoZWxsUHJveHkgZXh0ZW5kcyBQcm94eSB7XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRDcmVhdGUgYSBzaGVsbCBzdXJmYWNlIGZvciBhbiBleGlzdGluZyBzdXJmYWNlLiBUaGlzIGdpdmVzXG5cdCAqXHR0aGUgd2xfc3VyZmFjZSB0aGUgcm9sZSBvZiBhIHNoZWxsIHN1cmZhY2UuIElmIHRoZSB3bF9zdXJmYWNlXG5cdCAqXHRhbHJlYWR5IGhhcyBhbm90aGVyIHJvbGUsIGl0IHJhaXNlcyBhIHByb3RvY29sIGVycm9yLlxuXHQgKlxuXHQgKlx0T25seSBvbmUgc2hlbGwgc3VyZmFjZSBjYW4gYmUgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gc3VyZmFjZS5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHsqfSBzdXJmYWNlIHN1cmZhY2UgdG8gYmUgZ2l2ZW4gdGhlIHNoZWxsIHN1cmZhY2Ugcm9sZSBcblx0ICogQHJldHVybiB7V2xTaGVsbFN1cmZhY2VQcm94eX0gc2hlbGwgc3VyZmFjZSB0byBjcmVhdGUgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRnZXRTaGVsbFN1cmZhY2UgKHN1cmZhY2UpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFyc2hhbGxDb25zdHJ1Y3Rvcih0aGlzLmlkLCAwLCBXbFNoZWxsU3VyZmFjZVByb3h5LCBbbmV3T2JqZWN0KCksIG9iamVjdChzdXJmYWNlKV0pXG5cdH1cblxuXHQvKipcblx0ICogRG8gbm90IGNvbnN0cnVjdCBwcm94aWVzIGRpcmVjdGx5LiBJbnN0ZWFkIHVzZSBvbmUgb2YgdGhlIGZhY3RvcnkgbWV0aG9kcyBmcm9tIG90aGVyIHByb3hpZXMuXG5cdCAqQHBhcmFtIHtEaXNwbGF5fWRpc3BsYXlcblx0ICpAcGFyYW0ge0Nvbm5lY3Rpb259Y29ubmVjdGlvblxuXHQgKkBwYXJhbSB7bnVtYmVyfWlkXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciAoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpIHtcblx0XHRzdXBlcihkaXNwbGF5LCBjb25uZWN0aW9uLCBpZClcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7V2xTaGVsbEV2ZW50c3xudWxsfVxuXHRcdCAqL1xuXHRcdHRoaXMubGlzdGVuZXIgPSBudWxsXG5cdH1cblxufVxuV2xTaGVsbFByb3h5LnByb3RvY29sTmFtZSA9ICd3bF9zaGVsbCdcblxuV2xTaGVsbFByb3h5LkVycm9yID0ge1xuICAvKipcbiAgICogZ2l2ZW4gd2xfc3VyZmFjZSBoYXMgYW5vdGhlciByb2xlXG4gICAqL1xuICByb2xlOiAwXG59XG5cbmV4cG9ydCBkZWZhdWx0IFdsU2hlbGxQcm94eVxuIiwiLypcbiAqXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAwOC0yMDExIEtyaXN0aWFuIEjDuGdzYmVyZ1xuICogICAgQ29weXJpZ2h0IMKpIDIwMTAtMjAxMSBJbnRlbCBDb3Jwb3JhdGlvblxuICogICAgQ29weXJpZ2h0IMKpIDIwMTItMjAxMyBDb2xsYWJvcmEsIEx0ZC5cbiAqXG4gKiAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAqICAgICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAqICAgIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gKiAgICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICogICAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAqICAgIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIChpbmNsdWRpbmcgdGhlXG4gKiAgICBuZXh0IHBhcmFncmFwaCkgc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbFxuICogICAgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAqICAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiAgICBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICogICAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gKiAgICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICogICAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogICAgU09GVFdBUkUuXG4gKiAgXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJmYWNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdsU2hlbGxTdXJmYWNlRXZlbnRzIHtcblxuXHQvKipcblx0ICpcblx0ICpcdFBpbmcgYSBjbGllbnQgdG8gY2hlY2sgaWYgaXQgaXMgcmVjZWl2aW5nIGV2ZW50cyBhbmQgc2VuZGluZ1xuXHQgKlx0cmVxdWVzdHMuIEEgY2xpZW50IGlzIGV4cGVjdGVkIHRvIHJlcGx5IHdpdGggYSBwb25nIHJlcXVlc3QuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzZXJpYWwgc2VyaWFsIG51bWJlciBvZiB0aGUgcGluZyBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdHBpbmcoc2VyaWFsKSB7fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0VGhlIGNvbmZpZ3VyZSBldmVudCBhc2tzIHRoZSBjbGllbnQgdG8gcmVzaXplIGl0cyBzdXJmYWNlLlxuXHQgKlxuXHQgKlx0VGhlIHNpemUgaXMgYSBoaW50LCBpbiB0aGUgc2Vuc2UgdGhhdCB0aGUgY2xpZW50IGlzIGZyZWUgdG9cblx0ICpcdGlnbm9yZSBpdCBpZiBpdCBkb2Vzbid0IHJlc2l6ZSwgcGljayBhIHNtYWxsZXIgc2l6ZSAodG9cblx0ICpcdHNhdGlzZnkgYXNwZWN0IHJhdGlvIG9yIHJlc2l6ZSBpbiBzdGVwcyBvZiBOeE0gcGl4ZWxzKS5cblx0ICpcblx0ICpcdFRoZSBlZGdlcyBwYXJhbWV0ZXIgcHJvdmlkZXMgYSBoaW50IGFib3V0IGhvdyB0aGUgc3VyZmFjZVxuXHQgKlx0d2FzIHJlc2l6ZWQuIFRoZSBjbGllbnQgbWF5IHVzZSB0aGlzIGluZm9ybWF0aW9uIHRvIGRlY2lkZVxuXHQgKlx0aG93IHRvIGFkanVzdCBpdHMgY29udGVudCB0byB0aGUgbmV3IHNpemUgKGUuZy4gYSBzY3JvbGxpbmdcblx0ICpcdGFyZWEgbWlnaHQgYWRqdXN0IGl0cyBjb250ZW50IHBvc2l0aW9uIHRvIGxlYXZlIHRoZSB2aWV3YWJsZVxuXHQgKlx0Y29udGVudCB1bm1vdmVkKS5cblx0ICpcblx0ICpcdFRoZSBjbGllbnQgaXMgZnJlZSB0byBkaXNtaXNzIGFsbCBidXQgdGhlIGxhc3QgY29uZmlndXJlXG5cdCAqXHRldmVudCBpdCByZWNlaXZlZC5cblx0ICpcblx0ICpcdFRoZSB3aWR0aCBhbmQgaGVpZ2h0IGFyZ3VtZW50cyBzcGVjaWZ5IHRoZSBzaXplIG9mIHRoZSB3aW5kb3dcblx0ICpcdGluIHN1cmZhY2UtbG9jYWwgY29vcmRpbmF0ZXMuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBlZGdlcyBob3cgdGhlIHN1cmZhY2Ugd2FzIHJlc2l6ZWQgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBuZXcgd2lkdGggb2YgdGhlIHN1cmZhY2UgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgbmV3IGhlaWdodCBvZiB0aGUgc3VyZmFjZSBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdGNvbmZpZ3VyZShlZGdlcywgd2lkdGgsIGhlaWdodCkge31cblxuXHQvKipcblx0ICpcblx0ICpcdFRoZSBwb3B1cF9kb25lIGV2ZW50IGlzIHNlbnQgb3V0IHdoZW4gYSBwb3B1cCBncmFiIGlzIGJyb2tlbixcblx0ICpcdHRoYXQgaXMsIHdoZW4gdGhlIHVzZXIgY2xpY2tzIGEgc3VyZmFjZSB0aGF0IGRvZXNuJ3QgYmVsb25nXG5cdCAqXHR0byB0aGUgY2xpZW50IG93bmluZyB0aGUgcG9wdXAgc3VyZmFjZS5cblx0ICogICAgICBcblx0ICpcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdHBvcHVwRG9uZSgpIHt9XG59XG5cbiIsIi8qXG4gKlxuICogICAgQ29weXJpZ2h0IMKpIDIwMDgtMjAxMSBLcmlzdGlhbiBIw7hnc2JlcmdcbiAqICAgIENvcHlyaWdodCDCqSAyMDEwLTIwMTEgSW50ZWwgQ29ycG9yYXRpb25cbiAqICAgIENvcHlyaWdodCDCqSAyMDEyLTIwMTMgQ29sbGFib3JhLCBMdGQuXG4gKlxuICogICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gKiAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSAoaW5jbHVkaW5nIHRoZVxuICogICAgbmV4dCBwYXJhZ3JhcGgpIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWxcbiAqICAgIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogICAgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAqICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICogICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAqICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqICAgIFNPRlRXQVJFLlxuICogIFxuICovXG5cbmltcG9ydCB7IENvbm5lY3Rpb24gfSBmcm9tICd3ZXN0ZmllbGQtcnVudGltZS1jb21tb24nXG5jb25zdCB7IHVpbnQsIHVpbnRPcHRpb25hbCwgaW50LCBpbnRPcHRpb25hbCwgZml4ZWQsIFxuXHRmaXhlZE9wdGlvbmFsLCBvYmplY3QsIG9iamVjdE9wdGlvbmFsLCBuZXdPYmplY3QsIHN0cmluZywgXG5cdHN0cmluZ09wdGlvbmFsLCBhcnJheSwgYXJyYXlPcHRpb25hbCwgXG5cdGZpbGVEZXNjcmlwdG9yT3B0aW9uYWwsIGZpbGVEZXNjcmlwdG9yLCBcbmgsIHUsIGksIGYsIG8sIG4sIHMsIGEgfSA9IENvbm5lY3Rpb25cbmltcG9ydCBQcm94eSBmcm9tICcuL1Byb3h5J1xuXG4vKipcbiAqXG4gKiAgICAgIEFuIGludGVyZmFjZSB0aGF0IG1heSBiZSBpbXBsZW1lbnRlZCBieSBhIHdsX3N1cmZhY2UsIGZvclxuICogICAgICBpbXBsZW1lbnRhdGlvbnMgdGhhdCBwcm92aWRlIGEgZGVza3RvcC1zdHlsZSB1c2VyIGludGVyZmFjZS5cbiAqXG4gKiAgICAgIEl0IHByb3ZpZGVzIHJlcXVlc3RzIHRvIHRyZWF0IHN1cmZhY2VzIGxpa2UgdG9wbGV2ZWwsIGZ1bGxzY3JlZW5cbiAqICAgICAgb3IgcG9wdXAgd2luZG93cywgbW92ZSwgcmVzaXplIG9yIG1heGltaXplIHRoZW0sIGFzc29jaWF0ZVxuICogICAgICBtZXRhZGF0YSBsaWtlIHRpdGxlIGFuZCBjbGFzcywgZXRjLlxuICpcbiAqICAgICAgT24gdGhlIHNlcnZlciBzaWRlIHRoZSBvYmplY3QgaXMgYXV0b21hdGljYWxseSBkZXN0cm95ZWQgd2hlblxuICogICAgICB0aGUgcmVsYXRlZCB3bF9zdXJmYWNlIGlzIGRlc3Ryb3llZC4gT24gdGhlIGNsaWVudCBzaWRlLFxuICogICAgICB3bF9zaGVsbF9zdXJmYWNlX2Rlc3Ryb3koKSBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgZGVzdHJveWluZ1xuICogICAgICB0aGUgd2xfc3VyZmFjZSBvYmplY3QuXG4gKiAgICBcbiAqL1xuY2xhc3MgV2xTaGVsbFN1cmZhY2VQcm94eSBleHRlbmRzIFByb3h5IHtcblxuXHQvKipcblx0ICpcblx0ICpcdEEgY2xpZW50IG11c3QgcmVzcG9uZCB0byBhIHBpbmcgZXZlbnQgd2l0aCBhIHBvbmcgcmVxdWVzdCBvclxuXHQgKlx0dGhlIGNsaWVudCBtYXkgYmUgZGVlbWVkIHVucmVzcG9uc2l2ZS5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNlcmlhbCBzZXJpYWwgbnVtYmVyIG9mIHRoZSBwaW5nIGV2ZW50IFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0cG9uZyAoc2VyaWFsKSB7XG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgMCwgW3VpbnQoc2VyaWFsKV0pXG5cdH1cblxuXHQvKipcblx0ICpcblx0ICpcdFN0YXJ0IGEgcG9pbnRlci1kcml2ZW4gbW92ZSBvZiB0aGUgc3VyZmFjZS5cblx0ICpcblx0ICpcdFRoaXMgcmVxdWVzdCBtdXN0IGJlIHVzZWQgaW4gcmVzcG9uc2UgdG8gYSBidXR0b24gcHJlc3MgZXZlbnQuXG5cdCAqXHRUaGUgc2VydmVyIG1heSBpZ25vcmUgbW92ZSByZXF1ZXN0cyBkZXBlbmRpbmcgb24gdGhlIHN0YXRlIG9mXG5cdCAqXHR0aGUgc3VyZmFjZSAoZS5nLiBmdWxsc2NyZWVuIG9yIG1heGltaXplZCkuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7Kn0gc2VhdCBzZWF0IHdob3NlIHBvaW50ZXIgaXMgdXNlZCBcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNlcmlhbCBzZXJpYWwgbnVtYmVyIG9mIHRoZSBpbXBsaWNpdCBncmFiIG9uIHRoZSBwb2ludGVyIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0bW92ZSAoc2VhdCwgc2VyaWFsKSB7XG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgMSwgW29iamVjdChzZWF0KSwgdWludChzZXJpYWwpXSlcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0U3RhcnQgYSBwb2ludGVyLWRyaXZlbiByZXNpemluZyBvZiB0aGUgc3VyZmFjZS5cblx0ICpcblx0ICpcdFRoaXMgcmVxdWVzdCBtdXN0IGJlIHVzZWQgaW4gcmVzcG9uc2UgdG8gYSBidXR0b24gcHJlc3MgZXZlbnQuXG5cdCAqXHRUaGUgc2VydmVyIG1heSBpZ25vcmUgcmVzaXplIHJlcXVlc3RzIGRlcGVuZGluZyBvbiB0aGUgc3RhdGUgb2Zcblx0ICpcdHRoZSBzdXJmYWNlIChlLmcuIGZ1bGxzY3JlZW4gb3IgbWF4aW1pemVkKS5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHsqfSBzZWF0IHNlYXQgd2hvc2UgcG9pbnRlciBpcyB1c2VkIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2VyaWFsIHNlcmlhbCBudW1iZXIgb2YgdGhlIGltcGxpY2l0IGdyYWIgb24gdGhlIHBvaW50ZXIgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBlZGdlcyB3aGljaCBlZGdlIG9yIGNvcm5lciBpcyBiZWluZyBkcmFnZ2VkIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0cmVzaXplIChzZWF0LCBzZXJpYWwsIGVkZ2VzKSB7XG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgMiwgW29iamVjdChzZWF0KSwgdWludChzZXJpYWwpLCB1aW50KGVkZ2VzKV0pXG5cdH1cblxuXHQvKipcblx0ICpcblx0ICpcdE1hcCB0aGUgc3VyZmFjZSBhcyBhIHRvcGxldmVsIHN1cmZhY2UuXG5cdCAqXG5cdCAqXHRBIHRvcGxldmVsIHN1cmZhY2UgaXMgbm90IGZ1bGxzY3JlZW4sIG1heGltaXplZCBvciB0cmFuc2llbnQuXG5cdCAqICAgICAgXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRzZXRUb3BsZXZlbCAoKSB7XG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgMywgW10pXG5cdH1cblxuXHQvKipcblx0ICpcblx0ICpcdE1hcCB0aGUgc3VyZmFjZSByZWxhdGl2ZSB0byBhbiBleGlzdGluZyBzdXJmYWNlLlxuXHQgKlxuXHQgKlx0VGhlIHggYW5kIHkgYXJndW1lbnRzIHNwZWNpZnkgdGhlIGxvY2F0aW9uIG9mIHRoZSB1cHBlciBsZWZ0XG5cdCAqXHRjb3JuZXIgb2YgdGhlIHN1cmZhY2UgcmVsYXRpdmUgdG8gdGhlIHVwcGVyIGxlZnQgY29ybmVyIG9mIHRoZVxuXHQgKlx0cGFyZW50IHN1cmZhY2UsIGluIHN1cmZhY2UtbG9jYWwgY29vcmRpbmF0ZXMuXG5cdCAqXG5cdCAqXHRUaGUgZmxhZ3MgYXJndW1lbnQgY29udHJvbHMgZGV0YWlscyBvZiB0aGUgdHJhbnNpZW50IGJlaGF2aW91ci5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHsqfSBwYXJlbnQgcGFyZW50IHN1cmZhY2UgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IHN1cmZhY2UtbG9jYWwgeCBjb29yZGluYXRlIFxuXHQgKiBAcGFyYW0ge251bWJlcn0geSBzdXJmYWNlLWxvY2FsIHkgY29vcmRpbmF0ZSBcblx0ICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzIHRyYW5zaWVudCBzdXJmYWNlIGJlaGF2aW9yIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0c2V0VHJhbnNpZW50IChwYXJlbnQsIHgsIHksIGZsYWdzKSB7XG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgNCwgW29iamVjdChwYXJlbnQpLCBpbnQoeCksIGludCh5KSwgdWludChmbGFncyldKVxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRNYXAgdGhlIHN1cmZhY2UgYXMgYSBmdWxsc2NyZWVuIHN1cmZhY2UuXG5cdCAqXG5cdCAqXHRJZiBhbiBvdXRwdXQgcGFyYW1ldGVyIGlzIGdpdmVuIHRoZW4gdGhlIHN1cmZhY2Ugd2lsbCBiZSBtYWRlXG5cdCAqXHRmdWxsc2NyZWVuIG9uIHRoYXQgb3V0cHV0LiBJZiB0aGUgY2xpZW50IGRvZXMgbm90IHNwZWNpZnkgdGhlXG5cdCAqXHRvdXRwdXQgdGhlbiB0aGUgY29tcG9zaXRvciB3aWxsIGFwcGx5IGl0cyBwb2xpY3kgLSB1c3VhbGx5XG5cdCAqXHRjaG9vc2luZyB0aGUgb3V0cHV0IG9uIHdoaWNoIHRoZSBzdXJmYWNlIGhhcyB0aGUgYmlnZ2VzdCBzdXJmYWNlXG5cdCAqXHRhcmVhLlxuXHQgKlxuXHQgKlx0VGhlIGNsaWVudCBtYXkgc3BlY2lmeSBhIG1ldGhvZCB0byByZXNvbHZlIGEgc2l6ZSBjb25mbGljdFxuXHQgKlx0YmV0d2VlbiB0aGUgb3V0cHV0IHNpemUgYW5kIHRoZSBzdXJmYWNlIHNpemUgLSB0aGlzIGlzIHByb3ZpZGVkXG5cdCAqXHR0aHJvdWdoIHRoZSBtZXRob2QgcGFyYW1ldGVyLlxuXHQgKlxuXHQgKlx0VGhlIGZyYW1lcmF0ZSBwYXJhbWV0ZXIgaXMgdXNlZCBvbmx5IHdoZW4gdGhlIG1ldGhvZCBpcyBzZXRcblx0ICpcdHRvIFwiZHJpdmVyXCIsIHRvIGluZGljYXRlIHRoZSBwcmVmZXJyZWQgZnJhbWVyYXRlLiBBIHZhbHVlIG9mIDBcblx0ICpcdGluZGljYXRlcyB0aGF0IHRoZSBjbGllbnQgZG9lcyBub3QgY2FyZSBhYm91dCBmcmFtZXJhdGUuICBUaGVcblx0ICpcdGZyYW1lcmF0ZSBpcyBzcGVjaWZpZWQgaW4gbUh6LCB0aGF0IGlzIGZyYW1lcmF0ZSBvZiA2MDAwMCBpcyA2MEh6LlxuXHQgKlxuXHQgKlx0QSBtZXRob2Qgb2YgXCJzY2FsZVwiIG9yIFwiZHJpdmVyXCIgaW1wbGllcyBhIHNjYWxpbmcgb3BlcmF0aW9uIG9mXG5cdCAqXHR0aGUgc3VyZmFjZSwgZWl0aGVyIHZpYSBhIGRpcmVjdCBzY2FsaW5nIG9wZXJhdGlvbiBvciBhIGNoYW5nZSBvZlxuXHQgKlx0dGhlIG91dHB1dCBtb2RlLiBUaGlzIHdpbGwgb3ZlcnJpZGUgYW55IGtpbmQgb2Ygb3V0cHV0IHNjYWxpbmcsIHNvXG5cdCAqXHR0aGF0IG1hcHBpbmcgYSBzdXJmYWNlIHdpdGggYSBidWZmZXIgc2l6ZSBlcXVhbCB0byB0aGUgbW9kZSBjYW5cblx0ICpcdGZpbGwgdGhlIHNjcmVlbiBpbmRlcGVuZGVudCBvZiBidWZmZXJfc2NhbGUuXG5cdCAqXG5cdCAqXHRBIG1ldGhvZCBvZiBcImZpbGxcIiBtZWFucyB3ZSBkb24ndCBzY2FsZSB1cCB0aGUgYnVmZmVyLCBob3dldmVyXG5cdCAqXHRhbnkgb3V0cHV0IHNjYWxlIGlzIGFwcGxpZWQuIFRoaXMgbWVhbnMgdGhhdCB5b3UgbWF5IHJ1biBpbnRvXG5cdCAqXHRhbiBlZGdlIGNhc2Ugd2hlcmUgdGhlIGFwcGxpY2F0aW9uIG1hcHMgYSBidWZmZXIgd2l0aCB0aGUgc2FtZVxuXHQgKlx0c2l6ZSBvZiB0aGUgb3V0cHV0IG1vZGUgYnV0IGJ1ZmZlcl9zY2FsZSAxICh0aHVzIG1ha2luZyBhXG5cdCAqXHRzdXJmYWNlIGxhcmdlciB0aGFuIHRoZSBvdXRwdXQpLiBJbiB0aGlzIGNhc2UgaXQgaXMgYWxsb3dlZCB0b1xuXHQgKlx0ZG93bnNjYWxlIHRoZSByZXN1bHRzIHRvIGZpdCB0aGUgc2NyZWVuLlxuXHQgKlxuXHQgKlx0VGhlIGNvbXBvc2l0b3IgbXVzdCByZXBseSB0byB0aGlzIHJlcXVlc3Qgd2l0aCBhIGNvbmZpZ3VyZSBldmVudFxuXHQgKlx0d2l0aCB0aGUgZGltZW5zaW9ucyBmb3IgdGhlIG91dHB1dCBvbiB3aGljaCB0aGUgc3VyZmFjZSB3aWxsXG5cdCAqXHRiZSBtYWRlIGZ1bGxzY3JlZW4uXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBtZXRob2QgbWV0aG9kIGZvciByZXNvbHZpbmcgc2l6ZSBjb25mbGljdCBcblx0ICogQHBhcmFtIHtudW1iZXJ9IGZyYW1lcmF0ZSBmcmFtZXJhdGUgaW4gbUh6IFxuXHQgKiBAcGFyYW0gez8qfSBvdXRwdXQgb3V0cHV0IG9uIHdoaWNoIHRoZSBzdXJmYWNlIGlzIHRvIGJlIGZ1bGxzY3JlZW4gXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRzZXRGdWxsc2NyZWVuIChtZXRob2QsIGZyYW1lcmF0ZSwgb3V0cHV0KSB7XG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgNSwgW3VpbnQobWV0aG9kKSwgdWludChmcmFtZXJhdGUpLCBvYmplY3RPcHRpb25hbChvdXRwdXQpXSlcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0TWFwIHRoZSBzdXJmYWNlIGFzIGEgcG9wdXAuXG5cdCAqXG5cdCAqXHRBIHBvcHVwIHN1cmZhY2UgaXMgYSB0cmFuc2llbnQgc3VyZmFjZSB3aXRoIGFuIGFkZGVkIHBvaW50ZXJcblx0ICpcdGdyYWIuXG5cdCAqXG5cdCAqXHRBbiBleGlzdGluZyBpbXBsaWNpdCBncmFiIHdpbGwgYmUgY2hhbmdlZCB0byBvd25lci1ldmVudHMgbW9kZSxcblx0ICpcdGFuZCB0aGUgcG9wdXAgZ3JhYiB3aWxsIGNvbnRpbnVlIGFmdGVyIHRoZSBpbXBsaWNpdCBncmFiIGVuZHNcblx0ICpcdChpLmUuIHJlbGVhc2luZyB0aGUgbW91c2UgYnV0dG9uIGRvZXMgbm90IGNhdXNlIHRoZSBwb3B1cCB0b1xuXHQgKlx0YmUgdW5tYXBwZWQpLlxuXHQgKlxuXHQgKlx0VGhlIHBvcHVwIGdyYWIgY29udGludWVzIHVudGlsIHRoZSB3aW5kb3cgaXMgZGVzdHJveWVkIG9yIGFcblx0ICpcdG1vdXNlIGJ1dHRvbiBpcyBwcmVzc2VkIGluIGFueSBvdGhlciBjbGllbnQncyB3aW5kb3cuIEEgY2xpY2tcblx0ICpcdGluIGFueSBvZiB0aGUgY2xpZW50J3Mgc3VyZmFjZXMgaXMgcmVwb3J0ZWQgYXMgbm9ybWFsLCBob3dldmVyLFxuXHQgKlx0Y2xpY2tzIGluIG90aGVyIGNsaWVudHMnIHN1cmZhY2VzIHdpbGwgYmUgZGlzY2FyZGVkIGFuZCB0cmlnZ2VyXG5cdCAqXHR0aGUgY2FsbGJhY2suXG5cdCAqXG5cdCAqXHRUaGUgeCBhbmQgeSBhcmd1bWVudHMgc3BlY2lmeSB0aGUgbG9jYXRpb24gb2YgdGhlIHVwcGVyIGxlZnRcblx0ICpcdGNvcm5lciBvZiB0aGUgc3VyZmFjZSByZWxhdGl2ZSB0byB0aGUgdXBwZXIgbGVmdCBjb3JuZXIgb2YgdGhlXG5cdCAqXHRwYXJlbnQgc3VyZmFjZSwgaW4gc3VyZmFjZS1sb2NhbCBjb29yZGluYXRlcy5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHsqfSBzZWF0IHNlYXQgd2hvc2UgcG9pbnRlciBpcyB1c2VkIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2VyaWFsIHNlcmlhbCBudW1iZXIgb2YgdGhlIGltcGxpY2l0IGdyYWIgb24gdGhlIHBvaW50ZXIgXG5cdCAqIEBwYXJhbSB7Kn0gcGFyZW50IHBhcmVudCBzdXJmYWNlIFxuXHQgKiBAcGFyYW0ge251bWJlcn0geCBzdXJmYWNlLWxvY2FsIHggY29vcmRpbmF0ZSBcblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgc3VyZmFjZS1sb2NhbCB5IGNvb3JkaW5hdGUgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBmbGFncyB0cmFuc2llbnQgc3VyZmFjZSBiZWhhdmlvciBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdHNldFBvcHVwIChzZWF0LCBzZXJpYWwsIHBhcmVudCwgeCwgeSwgZmxhZ3MpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCA2LCBbb2JqZWN0KHNlYXQpLCB1aW50KHNlcmlhbCksIG9iamVjdChwYXJlbnQpLCBpbnQoeCksIGludCh5KSwgdWludChmbGFncyldKVxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRNYXAgdGhlIHN1cmZhY2UgYXMgYSBtYXhpbWl6ZWQgc3VyZmFjZS5cblx0ICpcblx0ICpcdElmIGFuIG91dHB1dCBwYXJhbWV0ZXIgaXMgZ2l2ZW4gdGhlbiB0aGUgc3VyZmFjZSB3aWxsIGJlXG5cdCAqXHRtYXhpbWl6ZWQgb24gdGhhdCBvdXRwdXQuIElmIHRoZSBjbGllbnQgZG9lcyBub3Qgc3BlY2lmeSB0aGVcblx0ICpcdG91dHB1dCB0aGVuIHRoZSBjb21wb3NpdG9yIHdpbGwgYXBwbHkgaXRzIHBvbGljeSAtIHVzdWFsbHlcblx0ICpcdGNob29zaW5nIHRoZSBvdXRwdXQgb24gd2hpY2ggdGhlIHN1cmZhY2UgaGFzIHRoZSBiaWdnZXN0IHN1cmZhY2Vcblx0ICpcdGFyZWEuXG5cdCAqXG5cdCAqXHRUaGUgY29tcG9zaXRvciB3aWxsIHJlcGx5IHdpdGggYSBjb25maWd1cmUgZXZlbnQgdGVsbGluZ1xuXHQgKlx0dGhlIGV4cGVjdGVkIG5ldyBzdXJmYWNlIHNpemUuIFRoZSBvcGVyYXRpb24gaXMgY29tcGxldGVkXG5cdCAqXHRvbiB0aGUgbmV4dCBidWZmZXIgYXR0YWNoIHRvIHRoaXMgc3VyZmFjZS5cblx0ICpcblx0ICpcdEEgbWF4aW1pemVkIHN1cmZhY2UgdHlwaWNhbGx5IGZpbGxzIHRoZSBlbnRpcmUgb3V0cHV0IGl0IGlzXG5cdCAqXHRib3VuZCB0bywgZXhjZXB0IGZvciBkZXNrdG9wIGVsZW1lbnRzIHN1Y2ggYXMgcGFuZWxzLiBUaGlzIGlzXG5cdCAqXHR0aGUgbWFpbiBkaWZmZXJlbmNlIGJldHdlZW4gYSBtYXhpbWl6ZWQgc2hlbGwgc3VyZmFjZSBhbmQgYVxuXHQgKlx0ZnVsbHNjcmVlbiBzaGVsbCBzdXJmYWNlLlxuXHQgKlxuXHQgKlx0VGhlIGRldGFpbHMgZGVwZW5kIG9uIHRoZSBjb21wb3NpdG9yIGltcGxlbWVudGF0aW9uLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0gez8qfSBvdXRwdXQgb3V0cHV0IG9uIHdoaWNoIHRoZSBzdXJmYWNlIGlzIHRvIGJlIG1heGltaXplZCBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdHNldE1heGltaXplZCAob3V0cHV0KSB7XG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgNywgW29iamVjdE9wdGlvbmFsKG91dHB1dCldKVxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRTZXQgYSBzaG9ydCB0aXRsZSBmb3IgdGhlIHN1cmZhY2UuXG5cdCAqXG5cdCAqXHRUaGlzIHN0cmluZyBtYXkgYmUgdXNlZCB0byBpZGVudGlmeSB0aGUgc3VyZmFjZSBpbiBhIHRhc2sgYmFyLFxuXHQgKlx0d2luZG93IGxpc3QsIG9yIG90aGVyIHVzZXIgaW50ZXJmYWNlIGVsZW1lbnRzIHByb3ZpZGVkIGJ5IHRoZVxuXHQgKlx0Y29tcG9zaXRvci5cblx0ICpcblx0ICpcdFRoZSBzdHJpbmcgbXVzdCBiZSBlbmNvZGVkIGluIFVURi04LlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGUgc3VyZmFjZSB0aXRsZSBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdHNldFRpdGxlICh0aXRsZSkge1xuXHRcdHRoaXMuX21hcnNoYWxsKHRoaXMuaWQsIDgsIFtzdHJpbmcodGl0bGUpXSlcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0U2V0IGEgY2xhc3MgZm9yIHRoZSBzdXJmYWNlLlxuXHQgKlxuXHQgKlx0VGhlIHN1cmZhY2UgY2xhc3MgaWRlbnRpZmllcyB0aGUgZ2VuZXJhbCBjbGFzcyBvZiBhcHBsaWNhdGlvbnNcblx0ICpcdHRvIHdoaWNoIHRoZSBzdXJmYWNlIGJlbG9uZ3MuIEEgY29tbW9uIGNvbnZlbnRpb24gaXMgdG8gdXNlIHRoZVxuXHQgKlx0ZmlsZSBuYW1lIChvciB0aGUgZnVsbCBwYXRoIGlmIGl0IGlzIGEgbm9uLXN0YW5kYXJkIGxvY2F0aW9uKSBvZlxuXHQgKlx0dGhlIGFwcGxpY2F0aW9uJ3MgLmRlc2t0b3AgZmlsZSBhcyB0aGUgY2xhc3MuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjbGF6eiBzdXJmYWNlIGNsYXNzIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0c2V0Q2xhc3MgKGNsYXp6KSB7XG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgOSwgW3N0cmluZyhjbGF6eildKVxuXHR9XG5cblx0LyoqXG5cdCAqIERvIG5vdCBjb25zdHJ1Y3QgcHJveGllcyBkaXJlY3RseS4gSW5zdGVhZCB1c2Ugb25lIG9mIHRoZSBmYWN0b3J5IG1ldGhvZHMgZnJvbSBvdGhlciBwcm94aWVzLlxuXHQgKkBwYXJhbSB7RGlzcGxheX1kaXNwbGF5XG5cdCAqQHBhcmFtIHtDb25uZWN0aW9ufWNvbm5lY3Rpb25cblx0ICpAcGFyYW0ge251bWJlcn1pZFxuXHQgKi9cblx0Y29uc3RydWN0b3IgKGRpc3BsYXksIGNvbm5lY3Rpb24sIGlkKSB7XG5cdFx0c3VwZXIoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge1dsU2hlbGxTdXJmYWNlRXZlbnRzfG51bGx9XG5cdFx0ICovXG5cdFx0dGhpcy5saXN0ZW5lciA9IG51bGxcblx0fVxuXG5cdGFzeW5jIFswXSAobWVzc2FnZSkge1xuXHRcdGF3YWl0IHRoaXMubGlzdGVuZXIucGluZyh1KG1lc3NhZ2UpKVxuXHR9XG5cblx0YXN5bmMgWzFdIChtZXNzYWdlKSB7XG5cdFx0YXdhaXQgdGhpcy5saXN0ZW5lci5jb25maWd1cmUodShtZXNzYWdlKSwgaShtZXNzYWdlKSwgaShtZXNzYWdlKSlcblx0fVxuXG5cdGFzeW5jIFsyXSAobWVzc2FnZSkge1xuXHRcdGF3YWl0IHRoaXMubGlzdGVuZXIucG9wdXBEb25lKClcblx0fVxuXG59XG5XbFNoZWxsU3VyZmFjZVByb3h5LnByb3RvY29sTmFtZSA9ICd3bF9zaGVsbF9zdXJmYWNlJ1xuXG5XbFNoZWxsU3VyZmFjZVByb3h5LlJlc2l6ZSA9IHtcbiAgLyoqXG4gICAqIG5vIGVkZ2VcbiAgICovXG4gIG5vbmU6IDAsXG4gIC8qKlxuICAgKiB0b3AgZWRnZVxuICAgKi9cbiAgdG9wOiAxLFxuICAvKipcbiAgICogYm90dG9tIGVkZ2VcbiAgICovXG4gIGJvdHRvbTogMixcbiAgLyoqXG4gICAqIGxlZnQgZWRnZVxuICAgKi9cbiAgbGVmdDogNCxcbiAgLyoqXG4gICAqIHRvcCBhbmQgbGVmdCBlZGdlc1xuICAgKi9cbiAgdG9wTGVmdDogNSxcbiAgLyoqXG4gICAqIGJvdHRvbSBhbmQgbGVmdCBlZGdlc1xuICAgKi9cbiAgYm90dG9tTGVmdDogNixcbiAgLyoqXG4gICAqIHJpZ2h0IGVkZ2VcbiAgICovXG4gIHJpZ2h0OiA4LFxuICAvKipcbiAgICogdG9wIGFuZCByaWdodCBlZGdlc1xuICAgKi9cbiAgdG9wUmlnaHQ6IDksXG4gIC8qKlxuICAgKiBib3R0b20gYW5kIHJpZ2h0IGVkZ2VzXG4gICAqL1xuICBib3R0b21SaWdodDogMTBcbn1cblxuV2xTaGVsbFN1cmZhY2VQcm94eS5UcmFuc2llbnQgPSB7XG4gIC8qKlxuICAgKiBkbyBub3Qgc2V0IGtleWJvYXJkIGZvY3VzXG4gICAqL1xuICBpbmFjdGl2ZTogMHgxXG59XG5cbldsU2hlbGxTdXJmYWNlUHJveHkuRnVsbHNjcmVlbk1ldGhvZCA9IHtcbiAgLyoqXG4gICAqIG5vIHByZWZlcmVuY2UsIGFwcGx5IGRlZmF1bHQgcG9saWN5XG4gICAqL1xuICBkZWZhdWx0OiAwLFxuICAvKipcbiAgICogc2NhbGUsIHByZXNlcnZlIHRoZSBzdXJmYWNlJ3MgYXNwZWN0IHJhdGlvIGFuZCBjZW50ZXIgb24gb3V0cHV0XG4gICAqL1xuICBzY2FsZTogMSxcbiAgLyoqXG4gICAqIHN3aXRjaCBvdXRwdXQgbW9kZSB0byB0aGUgc21hbGxlc3QgbW9kZSB0aGF0IGNhbiBmaXQgdGhlIHN1cmZhY2UsIGFkZCBibGFjayBib3JkZXJzIHRvIGNvbXBlbnNhdGUgc2l6ZSBtaXNtYXRjaFxuICAgKi9cbiAgZHJpdmVyOiAyLFxuICAvKipcbiAgICogbm8gdXBzY2FsaW5nLCBjZW50ZXIgb24gb3V0cHV0IGFuZCBhZGQgYmxhY2sgYm9yZGVycyB0byBjb21wZW5zYXRlIHNpemUgbWlzbWF0Y2hcbiAgICovXG4gIGZpbGw6IDNcbn1cblxuZXhwb3J0IGRlZmF1bHQgV2xTaGVsbFN1cmZhY2VQcm94eVxuIiwiLypcbiAqXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAwOC0yMDExIEtyaXN0aWFuIEjDuGdzYmVyZ1xuICogICAgQ29weXJpZ2h0IMKpIDIwMTAtMjAxMSBJbnRlbCBDb3Jwb3JhdGlvblxuICogICAgQ29weXJpZ2h0IMKpIDIwMTItMjAxMyBDb2xsYWJvcmEsIEx0ZC5cbiAqXG4gKiAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAqICAgICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAqICAgIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gKiAgICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICogICAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAqICAgIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIChpbmNsdWRpbmcgdGhlXG4gKiAgICBuZXh0IHBhcmFncmFwaCkgc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbFxuICogICAgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAqICAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiAgICBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICogICAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gKiAgICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICogICAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogICAgU09GVFdBUkUuXG4gKiAgXG4gKi9cblxuaW1wb3J0IHsgQ29ubmVjdGlvbiB9IGZyb20gJ3dlc3RmaWVsZC1ydW50aW1lLWNvbW1vbidcbmNvbnN0IHsgdWludCwgdWludE9wdGlvbmFsLCBpbnQsIGludE9wdGlvbmFsLCBmaXhlZCwgXG5cdGZpeGVkT3B0aW9uYWwsIG9iamVjdCwgb2JqZWN0T3B0aW9uYWwsIG5ld09iamVjdCwgc3RyaW5nLCBcblx0c3RyaW5nT3B0aW9uYWwsIGFycmF5LCBhcnJheU9wdGlvbmFsLCBcblx0ZmlsZURlc2NyaXB0b3JPcHRpb25hbCwgZmlsZURlc2NyaXB0b3IsIFxuaCwgdSwgaSwgZiwgbywgbiwgcywgYSB9ID0gQ29ubmVjdGlvblxuaW1wb3J0IFByb3h5IGZyb20gJy4vUHJveHknXG5pbXBvcnQgV2xTdWJzdXJmYWNlUHJveHkgZnJvbSAnLi9XbFN1YnN1cmZhY2VQcm94eSdcblxuLyoqXG4gKlxuICogICAgICBUaGUgZ2xvYmFsIGludGVyZmFjZSBleHBvc2luZyBzdWItc3VyZmFjZSBjb21wb3NpdGluZyBjYXBhYmlsaXRpZXMuXG4gKiAgICAgIEEgd2xfc3VyZmFjZSwgdGhhdCBoYXMgc3ViLXN1cmZhY2VzIGFzc29jaWF0ZWQsIGlzIGNhbGxlZCB0aGVcbiAqICAgICAgcGFyZW50IHN1cmZhY2UuIFN1Yi1zdXJmYWNlcyBjYW4gYmUgYXJiaXRyYXJpbHkgbmVzdGVkIGFuZCBjcmVhdGVcbiAqICAgICAgYSB0cmVlIG9mIHN1Yi1zdXJmYWNlcy5cbiAqXG4gKiAgICAgIFRoZSByb290IHN1cmZhY2UgaW4gYSB0cmVlIG9mIHN1Yi1zdXJmYWNlcyBpcyB0aGUgbWFpblxuICogICAgICBzdXJmYWNlLiBUaGUgbWFpbiBzdXJmYWNlIGNhbm5vdCBiZSBhIHN1Yi1zdXJmYWNlLCBiZWNhdXNlXG4gKiAgICAgIHN1Yi1zdXJmYWNlcyBtdXN0IGFsd2F5cyBoYXZlIGEgcGFyZW50LlxuICpcbiAqICAgICAgQSBtYWluIHN1cmZhY2Ugd2l0aCBpdHMgc3ViLXN1cmZhY2VzIGZvcm1zIGEgKGNvbXBvdW5kKSB3aW5kb3cuXG4gKiAgICAgIEZvciB3aW5kb3cgbWFuYWdlbWVudCBwdXJwb3NlcywgdGhpcyBzZXQgb2Ygd2xfc3VyZmFjZSBvYmplY3RzIGlzXG4gKiAgICAgIHRvIGJlIGNvbnNpZGVyZWQgYXMgYSBzaW5nbGUgd2luZG93LCBhbmQgaXQgc2hvdWxkIGFsc28gYmVoYXZlIGFzXG4gKiAgICAgIHN1Y2guXG4gKlxuICogICAgICBUaGUgYWltIG9mIHN1Yi1zdXJmYWNlcyBpcyB0byBvZmZsb2FkIHNvbWUgb2YgdGhlIGNvbXBvc2l0aW5nIHdvcmtcbiAqICAgICAgd2l0aGluIGEgd2luZG93IGZyb20gY2xpZW50cyB0byB0aGUgY29tcG9zaXRvci4gQSBwcmltZSBleGFtcGxlIGlzXG4gKiAgICAgIGEgdmlkZW8gcGxheWVyIHdpdGggZGVjb3JhdGlvbnMgYW5kIHZpZGVvIGluIHNlcGFyYXRlIHdsX3N1cmZhY2VcbiAqICAgICAgb2JqZWN0cy4gVGhpcyBzaG91bGQgYWxsb3cgdGhlIGNvbXBvc2l0b3IgdG8gcGFzcyBZVVYgdmlkZW8gYnVmZmVyXG4gKiAgICAgIHByb2Nlc3NpbmcgdG8gZGVkaWNhdGVkIG92ZXJsYXkgaGFyZHdhcmUgd2hlbiBwb3NzaWJsZS5cbiAqICAgIFxuICovXG5jbGFzcyBXbFN1YmNvbXBvc2l0b3JQcm94eSBleHRlbmRzIFByb3h5IHtcblxuXHQvKipcblx0ICpcblx0ICpcdEluZm9ybXMgdGhlIHNlcnZlciB0aGF0IHRoZSBjbGllbnQgd2lsbCBub3QgYmUgdXNpbmcgdGhpc1xuXHQgKlx0cHJvdG9jb2wgb2JqZWN0IGFueW1vcmUuIFRoaXMgZG9lcyBub3QgYWZmZWN0IGFueSBvdGhlclxuXHQgKlx0b2JqZWN0cywgd2xfc3Vic3VyZmFjZSBvYmplY3RzIGluY2x1ZGVkLlxuXHQgKiAgICAgIFxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0ZGVzdHJveSAoKSB7XG5cdFx0c3VwZXIuZGVzdHJveSgpXG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgMCwgW10pXG5cdH1cblxuXHQvKipcblx0ICpcblx0ICpcdENyZWF0ZSBhIHN1Yi1zdXJmYWNlIGludGVyZmFjZSBmb3IgdGhlIGdpdmVuIHN1cmZhY2UsIGFuZFxuXHQgKlx0YXNzb2NpYXRlIGl0IHdpdGggdGhlIGdpdmVuIHBhcmVudCBzdXJmYWNlLiBUaGlzIHR1cm5zIGFcblx0ICpcdHBsYWluIHdsX3N1cmZhY2UgaW50byBhIHN1Yi1zdXJmYWNlLlxuXHQgKlxuXHQgKlx0VGhlIHRvLWJlIHN1Yi1zdXJmYWNlIG11c3Qgbm90IGFscmVhZHkgaGF2ZSBhbm90aGVyIHJvbGUsIGFuZCBpdFxuXHQgKlx0bXVzdCBub3QgaGF2ZSBhbiBleGlzdGluZyB3bF9zdWJzdXJmYWNlIG9iamVjdC4gT3RoZXJ3aXNlIGEgcHJvdG9jb2xcblx0ICpcdGVycm9yIGlzIHJhaXNlZC5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHsqfSBzdXJmYWNlIHRoZSBzdXJmYWNlIHRvIGJlIHR1cm5lZCBpbnRvIGEgc3ViLXN1cmZhY2UgXG5cdCAqIEBwYXJhbSB7Kn0gcGFyZW50IHRoZSBwYXJlbnQgc3VyZmFjZSBcblx0ICogQHJldHVybiB7V2xTdWJzdXJmYWNlUHJveHl9IHRoZSBuZXcgc3ViLXN1cmZhY2Ugb2JqZWN0IElEIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0Z2V0U3Vic3VyZmFjZSAoc3VyZmFjZSwgcGFyZW50KSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hcnNoYWxsQ29uc3RydWN0b3IodGhpcy5pZCwgMSwgV2xTdWJzdXJmYWNlUHJveHksIFtuZXdPYmplY3QoKSwgb2JqZWN0KHN1cmZhY2UpLCBvYmplY3QocGFyZW50KV0pXG5cdH1cblxuXHQvKipcblx0ICogRG8gbm90IGNvbnN0cnVjdCBwcm94aWVzIGRpcmVjdGx5LiBJbnN0ZWFkIHVzZSBvbmUgb2YgdGhlIGZhY3RvcnkgbWV0aG9kcyBmcm9tIG90aGVyIHByb3hpZXMuXG5cdCAqQHBhcmFtIHtEaXNwbGF5fWRpc3BsYXlcblx0ICpAcGFyYW0ge0Nvbm5lY3Rpb259Y29ubmVjdGlvblxuXHQgKkBwYXJhbSB7bnVtYmVyfWlkXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciAoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpIHtcblx0XHRzdXBlcihkaXNwbGF5LCBjb25uZWN0aW9uLCBpZClcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7V2xTdWJjb21wb3NpdG9yRXZlbnRzfG51bGx9XG5cdFx0ICovXG5cdFx0dGhpcy5saXN0ZW5lciA9IG51bGxcblx0fVxuXG59XG5XbFN1YmNvbXBvc2l0b3JQcm94eS5wcm90b2NvbE5hbWUgPSAnd2xfc3ViY29tcG9zaXRvcidcblxuV2xTdWJjb21wb3NpdG9yUHJveHkuRXJyb3IgPSB7XG4gIC8qKlxuICAgKiB0aGUgdG8tYmUgc3ViLXN1cmZhY2UgaXMgaW52YWxpZFxuICAgKi9cbiAgYmFkU3VyZmFjZTogMFxufVxuXG5leHBvcnQgZGVmYXVsdCBXbFN1YmNvbXBvc2l0b3JQcm94eVxuIiwiLypcbiAqXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAwOC0yMDExIEtyaXN0aWFuIEjDuGdzYmVyZ1xuICogICAgQ29weXJpZ2h0IMKpIDIwMTAtMjAxMSBJbnRlbCBDb3Jwb3JhdGlvblxuICogICAgQ29weXJpZ2h0IMKpIDIwMTItMjAxMyBDb2xsYWJvcmEsIEx0ZC5cbiAqXG4gKiAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAqICAgICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAqICAgIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gKiAgICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICogICAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAqICAgIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIChpbmNsdWRpbmcgdGhlXG4gKiAgICBuZXh0IHBhcmFncmFwaCkgc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbFxuICogICAgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAqICAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiAgICBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICogICAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gKiAgICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICogICAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogICAgU09GVFdBUkUuXG4gKiAgXG4gKi9cblxuaW1wb3J0IHsgQ29ubmVjdGlvbiB9IGZyb20gJ3dlc3RmaWVsZC1ydW50aW1lLWNvbW1vbidcbmNvbnN0IHsgdWludCwgdWludE9wdGlvbmFsLCBpbnQsIGludE9wdGlvbmFsLCBmaXhlZCwgXG5cdGZpeGVkT3B0aW9uYWwsIG9iamVjdCwgb2JqZWN0T3B0aW9uYWwsIG5ld09iamVjdCwgc3RyaW5nLCBcblx0c3RyaW5nT3B0aW9uYWwsIGFycmF5LCBhcnJheU9wdGlvbmFsLCBcblx0ZmlsZURlc2NyaXB0b3JPcHRpb25hbCwgZmlsZURlc2NyaXB0b3IsIFxuaCwgdSwgaSwgZiwgbywgbiwgcywgYSB9ID0gQ29ubmVjdGlvblxuaW1wb3J0IFByb3h5IGZyb20gJy4vUHJveHknXG5cbi8qKlxuICpcbiAqICAgICAgQW4gYWRkaXRpb25hbCBpbnRlcmZhY2UgdG8gYSB3bF9zdXJmYWNlIG9iamVjdCwgd2hpY2ggaGFzIGJlZW5cbiAqICAgICAgbWFkZSBhIHN1Yi1zdXJmYWNlLiBBIHN1Yi1zdXJmYWNlIGhhcyBvbmUgcGFyZW50IHN1cmZhY2UuIEFcbiAqICAgICAgc3ViLXN1cmZhY2UncyBzaXplIGFuZCBwb3NpdGlvbiBhcmUgbm90IGxpbWl0ZWQgdG8gdGhhdCBvZiB0aGUgcGFyZW50LlxuICogICAgICBQYXJ0aWN1bGFybHksIGEgc3ViLXN1cmZhY2UgaXMgbm90IGF1dG9tYXRpY2FsbHkgY2xpcHBlZCB0byBpdHNcbiAqICAgICAgcGFyZW50J3MgYXJlYS5cbiAqXG4gKiAgICAgIEEgc3ViLXN1cmZhY2UgYmVjb21lcyBtYXBwZWQsIHdoZW4gYSBub24tTlVMTCB3bF9idWZmZXIgaXMgYXBwbGllZFxuICogICAgICBhbmQgdGhlIHBhcmVudCBzdXJmYWNlIGlzIG1hcHBlZC4gVGhlIG9yZGVyIG9mIHdoaWNoIG9uZSBoYXBwZW5zXG4gKiAgICAgIGZpcnN0IGlzIGlycmVsZXZhbnQuIEEgc3ViLXN1cmZhY2UgaXMgaGlkZGVuIGlmIHRoZSBwYXJlbnQgYmVjb21lc1xuICogICAgICBoaWRkZW4sIG9yIGlmIGEgTlVMTCB3bF9idWZmZXIgaXMgYXBwbGllZC4gVGhlc2UgcnVsZXMgYXBwbHlcbiAqICAgICAgcmVjdXJzaXZlbHkgdGhyb3VnaCB0aGUgdHJlZSBvZiBzdXJmYWNlcy5cbiAqXG4gKiAgICAgIFRoZSBiZWhhdmlvdXIgb2YgYSB3bF9zdXJmYWNlLmNvbW1pdCByZXF1ZXN0IG9uIGEgc3ViLXN1cmZhY2VcbiAqICAgICAgZGVwZW5kcyBvbiB0aGUgc3ViLXN1cmZhY2UncyBtb2RlLiBUaGUgcG9zc2libGUgbW9kZXMgYXJlXG4gKiAgICAgIHN5bmNocm9uaXplZCBhbmQgZGVzeW5jaHJvbml6ZWQsIHNlZSBtZXRob2RzXG4gKiAgICAgIHdsX3N1YnN1cmZhY2Uuc2V0X3N5bmMgYW5kIHdsX3N1YnN1cmZhY2Uuc2V0X2Rlc3luYy4gU3luY2hyb25pemVkXG4gKiAgICAgIG1vZGUgY2FjaGVzIHRoZSB3bF9zdXJmYWNlIHN0YXRlIHRvIGJlIGFwcGxpZWQgd2hlbiB0aGUgcGFyZW50J3NcbiAqICAgICAgc3RhdGUgZ2V0cyBhcHBsaWVkLCBhbmQgZGVzeW5jaHJvbml6ZWQgbW9kZSBhcHBsaWVzIHRoZSBwZW5kaW5nXG4gKiAgICAgIHdsX3N1cmZhY2Ugc3RhdGUgZGlyZWN0bHkuIEEgc3ViLXN1cmZhY2UgaXMgaW5pdGlhbGx5IGluIHRoZVxuICogICAgICBzeW5jaHJvbml6ZWQgbW9kZS5cbiAqXG4gKiAgICAgIFN1Yi1zdXJmYWNlcyBoYXZlIGFsc28gb3RoZXIga2luZCBvZiBzdGF0ZSwgd2hpY2ggaXMgbWFuYWdlZCBieVxuICogICAgICB3bF9zdWJzdXJmYWNlIHJlcXVlc3RzLCBhcyBvcHBvc2VkIHRvIHdsX3N1cmZhY2UgcmVxdWVzdHMuIFRoaXNcbiAqICAgICAgc3RhdGUgaW5jbHVkZXMgdGhlIHN1Yi1zdXJmYWNlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnRcbiAqICAgICAgc3VyZmFjZSAod2xfc3Vic3VyZmFjZS5zZXRfcG9zaXRpb24pLCBhbmQgdGhlIHN0YWNraW5nIG9yZGVyIG9mXG4gKiAgICAgIHRoZSBwYXJlbnQgYW5kIGl0cyBzdWItc3VyZmFjZXMgKHdsX3N1YnN1cmZhY2UucGxhY2VfYWJvdmUgYW5kXG4gKiAgICAgIC5wbGFjZV9iZWxvdykuIFRoaXMgc3RhdGUgaXMgYXBwbGllZCB3aGVuIHRoZSBwYXJlbnQgc3VyZmFjZSdzXG4gKiAgICAgIHdsX3N1cmZhY2Ugc3RhdGUgaXMgYXBwbGllZCwgcmVnYXJkbGVzcyBvZiB0aGUgc3ViLXN1cmZhY2UncyBtb2RlLlxuICogICAgICBBcyB0aGUgZXhjZXB0aW9uLCBzZXRfc3luYyBhbmQgc2V0X2Rlc3luYyBhcmUgZWZmZWN0aXZlIGltbWVkaWF0ZWx5LlxuICpcbiAqICAgICAgVGhlIG1haW4gc3VyZmFjZSBjYW4gYmUgdGhvdWdodCB0byBiZSBhbHdheXMgaW4gZGVzeW5jaHJvbml6ZWQgbW9kZSxcbiAqICAgICAgc2luY2UgaXQgZG9lcyBub3QgaGF2ZSBhIHBhcmVudCBpbiB0aGUgc3ViLXN1cmZhY2VzIHNlbnNlLlxuICpcbiAqICAgICAgRXZlbiBpZiBhIHN1Yi1zdXJmYWNlIGlzIGluIGRlc3luY2hyb25pemVkIG1vZGUsIGl0IHdpbGwgYmVoYXZlIGFzXG4gKiAgICAgIGluIHN5bmNocm9uaXplZCBtb2RlLCBpZiBpdHMgcGFyZW50IHN1cmZhY2UgYmVoYXZlcyBhcyBpblxuICogICAgICBzeW5jaHJvbml6ZWQgbW9kZS4gVGhpcyBydWxlIGlzIGFwcGxpZWQgcmVjdXJzaXZlbHkgdGhyb3VnaG91dCB0aGVcbiAqICAgICAgdHJlZSBvZiBzdXJmYWNlcy4gVGhpcyBtZWFucywgdGhhdCBvbmUgY2FuIHNldCBhIHN1Yi1zdXJmYWNlIGludG9cbiAqICAgICAgc3luY2hyb25pemVkIG1vZGUsIGFuZCB0aGVuIGFzc3VtZSB0aGF0IGFsbCBpdHMgY2hpbGQgYW5kIGdyYW5kLWNoaWxkXG4gKiAgICAgIHN1Yi1zdXJmYWNlcyBhcmUgc3luY2hyb25pemVkLCB0b28sIHdpdGhvdXQgZXhwbGljaXRseSBzZXR0aW5nIHRoZW0uXG4gKlxuICogICAgICBJZiB0aGUgd2xfc3VyZmFjZSBhc3NvY2lhdGVkIHdpdGggdGhlIHdsX3N1YnN1cmZhY2UgaXMgZGVzdHJveWVkLCB0aGVcbiAqICAgICAgd2xfc3Vic3VyZmFjZSBvYmplY3QgYmVjb21lcyBpbmVydC4gTm90ZSwgdGhhdCBkZXN0cm95aW5nIGVpdGhlciBvYmplY3RcbiAqICAgICAgdGFrZXMgZWZmZWN0IGltbWVkaWF0ZWx5LiBJZiB5b3UgbmVlZCB0byBzeW5jaHJvbml6ZSB0aGUgcmVtb3ZhbFxuICogICAgICBvZiBhIHN1Yi1zdXJmYWNlIHRvIHRoZSBwYXJlbnQgc3VyZmFjZSB1cGRhdGUsIHVubWFwIHRoZSBzdWItc3VyZmFjZVxuICogICAgICBmaXJzdCBieSBhdHRhY2hpbmcgYSBOVUxMIHdsX2J1ZmZlciwgdXBkYXRlIHBhcmVudCwgYW5kIHRoZW4gZGVzdHJveVxuICogICAgICB0aGUgc3ViLXN1cmZhY2UuXG4gKlxuICogICAgICBJZiB0aGUgcGFyZW50IHdsX3N1cmZhY2Ugb2JqZWN0IGlzIGRlc3Ryb3llZCwgdGhlIHN1Yi1zdXJmYWNlIGlzXG4gKiAgICAgIHVubWFwcGVkLlxuICogICAgXG4gKi9cbmNsYXNzIFdsU3Vic3VyZmFjZVByb3h5IGV4dGVuZHMgUHJveHkge1xuXG5cdC8qKlxuXHQgKlxuXHQgKlx0VGhlIHN1Yi1zdXJmYWNlIGludGVyZmFjZSBpcyByZW1vdmVkIGZyb20gdGhlIHdsX3N1cmZhY2Ugb2JqZWN0XG5cdCAqXHR0aGF0IHdhcyB0dXJuZWQgaW50byBhIHN1Yi1zdXJmYWNlIHdpdGggYVxuXHQgKlx0d2xfc3ViY29tcG9zaXRvci5nZXRfc3Vic3VyZmFjZSByZXF1ZXN0LiBUaGUgd2xfc3VyZmFjZSdzIGFzc29jaWF0aW9uXG5cdCAqXHR0byB0aGUgcGFyZW50IGlzIGRlbGV0ZWQsIGFuZCB0aGUgd2xfc3VyZmFjZSBsb3NlcyBpdHMgcm9sZSBhc1xuXHQgKlx0YSBzdWItc3VyZmFjZS4gVGhlIHdsX3N1cmZhY2UgaXMgdW5tYXBwZWQuXG5cdCAqICAgICAgXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRkZXN0cm95ICgpIHtcblx0XHRzdXBlci5kZXN0cm95KClcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCAwLCBbXSlcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0VGhpcyBzY2hlZHVsZXMgYSBzdWItc3VyZmFjZSBwb3NpdGlvbiBjaGFuZ2UuXG5cdCAqXHRUaGUgc3ViLXN1cmZhY2Ugd2lsbCBiZSBtb3ZlZCBzbyB0aGF0IGl0cyBvcmlnaW4gKHRvcCBsZWZ0XG5cdCAqXHRjb3JuZXIgcGl4ZWwpIHdpbGwgYmUgYXQgdGhlIGxvY2F0aW9uIHgsIHkgb2YgdGhlIHBhcmVudCBzdXJmYWNlXG5cdCAqXHRjb29yZGluYXRlIHN5c3RlbS4gVGhlIGNvb3JkaW5hdGVzIGFyZSBub3QgcmVzdHJpY3RlZCB0byB0aGUgcGFyZW50XG5cdCAqXHRzdXJmYWNlIGFyZWEuIE5lZ2F0aXZlIHZhbHVlcyBhcmUgYWxsb3dlZC5cblx0ICpcblx0ICpcdFRoZSBzY2hlZHVsZWQgY29vcmRpbmF0ZXMgd2lsbCB0YWtlIGVmZmVjdCB3aGVuZXZlciB0aGUgc3RhdGUgb2YgdGhlXG5cdCAqXHRwYXJlbnQgc3VyZmFjZSBpcyBhcHBsaWVkLiBXaGVuIHRoaXMgaGFwcGVucyBkZXBlbmRzIG9uIHdoZXRoZXIgdGhlXG5cdCAqXHRwYXJlbnQgc3VyZmFjZSBpcyBpbiBzeW5jaHJvbml6ZWQgbW9kZSBvciBub3QuIFNlZVxuXHQgKlx0d2xfc3Vic3VyZmFjZS5zZXRfc3luYyBhbmQgd2xfc3Vic3VyZmFjZS5zZXRfZGVzeW5jIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKlx0SWYgbW9yZSB0aGFuIG9uZSBzZXRfcG9zaXRpb24gcmVxdWVzdCBpcyBpbnZva2VkIGJ5IHRoZSBjbGllbnQgYmVmb3JlXG5cdCAqXHR0aGUgY29tbWl0IG9mIHRoZSBwYXJlbnQgc3VyZmFjZSwgdGhlIHBvc2l0aW9uIG9mIGEgbmV3IHJlcXVlc3QgYWx3YXlzXG5cdCAqXHRyZXBsYWNlcyB0aGUgc2NoZWR1bGVkIHBvc2l0aW9uIGZyb20gYW55IHByZXZpb3VzIHJlcXVlc3QuXG5cdCAqXG5cdCAqXHRUaGUgaW5pdGlhbCBwb3NpdGlvbiBpcyAwLCAwLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCB4IGNvb3JkaW5hdGUgaW4gdGhlIHBhcmVudCBzdXJmYWNlIFxuXHQgKiBAcGFyYW0ge251bWJlcn0geSB5IGNvb3JkaW5hdGUgaW4gdGhlIHBhcmVudCBzdXJmYWNlIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0c2V0UG9zaXRpb24gKHgsIHkpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCAxLCBbaW50KHgpLCBpbnQoeSldKVxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRUaGlzIHN1Yi1zdXJmYWNlIGlzIHRha2VuIGZyb20gdGhlIHN0YWNrLCBhbmQgcHV0IGJhY2sganVzdFxuXHQgKlx0YWJvdmUgdGhlIHJlZmVyZW5jZSBzdXJmYWNlLCBjaGFuZ2luZyB0aGUgei1vcmRlciBvZiB0aGUgc3ViLXN1cmZhY2VzLlxuXHQgKlx0VGhlIHJlZmVyZW5jZSBzdXJmYWNlIG11c3QgYmUgb25lIG9mIHRoZSBzaWJsaW5nIHN1cmZhY2VzLCBvciB0aGVcblx0ICpcdHBhcmVudCBzdXJmYWNlLiBVc2luZyBhbnkgb3RoZXIgc3VyZmFjZSwgaW5jbHVkaW5nIHRoaXMgc3ViLXN1cmZhY2UsXG5cdCAqXHR3aWxsIGNhdXNlIGEgcHJvdG9jb2wgZXJyb3IuXG5cdCAqXG5cdCAqXHRUaGUgei1vcmRlciBpcyBkb3VibGUtYnVmZmVyZWQuIFJlcXVlc3RzIGFyZSBoYW5kbGVkIGluIG9yZGVyIGFuZFxuXHQgKlx0YXBwbGllZCBpbW1lZGlhdGVseSB0byBhIHBlbmRpbmcgc3RhdGUuIFRoZSBmaW5hbCBwZW5kaW5nIHN0YXRlIGlzXG5cdCAqXHRjb3BpZWQgdG8gdGhlIGFjdGl2ZSBzdGF0ZSB0aGUgbmV4dCB0aW1lIHRoZSBzdGF0ZSBvZiB0aGUgcGFyZW50XG5cdCAqXHRzdXJmYWNlIGlzIGFwcGxpZWQuIFdoZW4gdGhpcyBoYXBwZW5zIGRlcGVuZHMgb24gd2hldGhlciB0aGUgcGFyZW50XG5cdCAqXHRzdXJmYWNlIGlzIGluIHN5bmNocm9uaXplZCBtb2RlIG9yIG5vdC4gU2VlIHdsX3N1YnN1cmZhY2Uuc2V0X3N5bmMgYW5kXG5cdCAqXHR3bF9zdWJzdXJmYWNlLnNldF9kZXN5bmMgZm9yIGRldGFpbHMuXG5cdCAqXG5cdCAqXHRBIG5ldyBzdWItc3VyZmFjZSBpcyBpbml0aWFsbHkgYWRkZWQgYXMgdGhlIHRvcC1tb3N0IGluIHRoZSBzdGFja1xuXHQgKlx0b2YgaXRzIHNpYmxpbmdzIGFuZCBwYXJlbnQuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7Kn0gc2libGluZyB0aGUgcmVmZXJlbmNlIHN1cmZhY2UgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRwbGFjZUFib3ZlIChzaWJsaW5nKSB7XG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgMiwgW29iamVjdChzaWJsaW5nKV0pXG5cdH1cblxuXHQvKipcblx0ICpcblx0ICpcdFRoZSBzdWItc3VyZmFjZSBpcyBwbGFjZWQganVzdCBiZWxvdyB0aGUgcmVmZXJlbmNlIHN1cmZhY2UuXG5cdCAqXHRTZWUgd2xfc3Vic3VyZmFjZS5wbGFjZV9hYm92ZS5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHsqfSBzaWJsaW5nIHRoZSByZWZlcmVuY2Ugc3VyZmFjZSBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdHBsYWNlQmVsb3cgKHNpYmxpbmcpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCAzLCBbb2JqZWN0KHNpYmxpbmcpXSlcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0Q2hhbmdlIHRoZSBjb21taXQgYmVoYXZpb3VyIG9mIHRoZSBzdWItc3VyZmFjZSB0byBzeW5jaHJvbml6ZWRcblx0ICpcdG1vZGUsIGFsc28gZGVzY3JpYmVkIGFzIHRoZSBwYXJlbnQgZGVwZW5kZW50IG1vZGUuXG5cdCAqXG5cdCAqXHRJbiBzeW5jaHJvbml6ZWQgbW9kZSwgd2xfc3VyZmFjZS5jb21taXQgb24gYSBzdWItc3VyZmFjZSB3aWxsXG5cdCAqXHRhY2N1bXVsYXRlIHRoZSBjb21taXR0ZWQgc3RhdGUgaW4gYSBjYWNoZSwgYnV0IHRoZSBzdGF0ZSB3aWxsXG5cdCAqXHRub3QgYmUgYXBwbGllZCBhbmQgaGVuY2Ugd2lsbCBub3QgY2hhbmdlIHRoZSBjb21wb3NpdG9yIG91dHB1dC5cblx0ICpcdFRoZSBjYWNoZWQgc3RhdGUgaXMgYXBwbGllZCB0byB0aGUgc3ViLXN1cmZhY2UgaW1tZWRpYXRlbHkgYWZ0ZXJcblx0ICpcdHRoZSBwYXJlbnQgc3VyZmFjZSdzIHN0YXRlIGlzIGFwcGxpZWQuIFRoaXMgZW5zdXJlcyBhdG9taWNcblx0ICpcdHVwZGF0ZXMgb2YgdGhlIHBhcmVudCBhbmQgYWxsIGl0cyBzeW5jaHJvbml6ZWQgc3ViLXN1cmZhY2VzLlxuXHQgKlx0QXBwbHlpbmcgdGhlIGNhY2hlZCBzdGF0ZSB3aWxsIGludmFsaWRhdGUgdGhlIGNhY2hlLCBzbyBmdXJ0aGVyXG5cdCAqXHRwYXJlbnQgc3VyZmFjZSBjb21taXRzIGRvIG5vdCAocmUtKWFwcGx5IG9sZCBzdGF0ZS5cblx0ICpcblx0ICpcdFNlZSB3bF9zdWJzdXJmYWNlIGZvciB0aGUgcmVjdXJzaXZlIGVmZmVjdCBvZiB0aGlzIG1vZGUuXG5cdCAqICAgICAgXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRzZXRTeW5jICgpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCA0LCBbXSlcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0Q2hhbmdlIHRoZSBjb21taXQgYmVoYXZpb3VyIG9mIHRoZSBzdWItc3VyZmFjZSB0byBkZXN5bmNocm9uaXplZFxuXHQgKlx0bW9kZSwgYWxzbyBkZXNjcmliZWQgYXMgaW5kZXBlbmRlbnQgb3IgZnJlZWx5IHJ1bm5pbmcgbW9kZS5cblx0ICpcblx0ICpcdEluIGRlc3luY2hyb25pemVkIG1vZGUsIHdsX3N1cmZhY2UuY29tbWl0IG9uIGEgc3ViLXN1cmZhY2Ugd2lsbFxuXHQgKlx0YXBwbHkgdGhlIHBlbmRpbmcgc3RhdGUgZGlyZWN0bHksIHdpdGhvdXQgY2FjaGluZywgYXMgaGFwcGVuc1xuXHQgKlx0bm9ybWFsbHkgd2l0aCBhIHdsX3N1cmZhY2UuIENhbGxpbmcgd2xfc3VyZmFjZS5jb21taXQgb24gdGhlXG5cdCAqXHRwYXJlbnQgc3VyZmFjZSBoYXMgbm8gZWZmZWN0IG9uIHRoZSBzdWItc3VyZmFjZSdzIHdsX3N1cmZhY2Vcblx0ICpcdHN0YXRlLiBUaGlzIG1vZGUgYWxsb3dzIGEgc3ViLXN1cmZhY2UgdG8gYmUgdXBkYXRlZCBvbiBpdHMgb3duLlxuXHQgKlxuXHQgKlx0SWYgY2FjaGVkIHN0YXRlIGV4aXN0cyB3aGVuIHdsX3N1cmZhY2UuY29tbWl0IGlzIGNhbGxlZCBpblxuXHQgKlx0ZGVzeW5jaHJvbml6ZWQgbW9kZSwgdGhlIHBlbmRpbmcgc3RhdGUgaXMgYWRkZWQgdG8gdGhlIGNhY2hlZFxuXHQgKlx0c3RhdGUsIGFuZCBhcHBsaWVkIGFzIGEgd2hvbGUuIFRoaXMgaW52YWxpZGF0ZXMgdGhlIGNhY2hlLlxuXHQgKlxuXHQgKlx0Tm90ZTogZXZlbiBpZiBhIHN1Yi1zdXJmYWNlIGlzIHNldCB0byBkZXN5bmNocm9uaXplZCwgYSBwYXJlbnRcblx0ICpcdHN1Yi1zdXJmYWNlIG1heSBvdmVycmlkZSBpdCB0byBiZWhhdmUgYXMgc3luY2hyb25pemVkLiBGb3IgZGV0YWlscyxcblx0ICpcdHNlZSB3bF9zdWJzdXJmYWNlLlxuXHQgKlxuXHQgKlx0SWYgYSBzdXJmYWNlJ3MgcGFyZW50IHN1cmZhY2UgYmVoYXZlcyBhcyBkZXN5bmNocm9uaXplZCwgdGhlblxuXHQgKlx0dGhlIGNhY2hlZCBzdGF0ZSBpcyBhcHBsaWVkIG9uIHNldF9kZXN5bmMuXG5cdCAqICAgICAgXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRzZXREZXN5bmMgKCkge1xuXHRcdHRoaXMuX21hcnNoYWxsKHRoaXMuaWQsIDUsIFtdKVxuXHR9XG5cblx0LyoqXG5cdCAqIERvIG5vdCBjb25zdHJ1Y3QgcHJveGllcyBkaXJlY3RseS4gSW5zdGVhZCB1c2Ugb25lIG9mIHRoZSBmYWN0b3J5IG1ldGhvZHMgZnJvbSBvdGhlciBwcm94aWVzLlxuXHQgKkBwYXJhbSB7RGlzcGxheX1kaXNwbGF5XG5cdCAqQHBhcmFtIHtDb25uZWN0aW9ufWNvbm5lY3Rpb25cblx0ICpAcGFyYW0ge251bWJlcn1pZFxuXHQgKi9cblx0Y29uc3RydWN0b3IgKGRpc3BsYXksIGNvbm5lY3Rpb24sIGlkKSB7XG5cdFx0c3VwZXIoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge1dsU3Vic3VyZmFjZUV2ZW50c3xudWxsfVxuXHRcdCAqL1xuXHRcdHRoaXMubGlzdGVuZXIgPSBudWxsXG5cdH1cblxufVxuV2xTdWJzdXJmYWNlUHJveHkucHJvdG9jb2xOYW1lID0gJ3dsX3N1YnN1cmZhY2UnXG5cbldsU3Vic3VyZmFjZVByb3h5LkVycm9yID0ge1xuICAvKipcbiAgICogd2xfc3VyZmFjZSBpcyBub3QgYSBzaWJsaW5nIG9yIHRoZSBwYXJlbnRcbiAgICovXG4gIGJhZFN1cmZhY2U6IDBcbn1cblxuZXhwb3J0IGRlZmF1bHQgV2xTdWJzdXJmYWNlUHJveHlcbiIsIi8qXG4gKlxuICogICAgQ29weXJpZ2h0IMKpIDIwMDgtMjAxMSBLcmlzdGlhbiBIw7hnc2JlcmdcbiAqICAgIENvcHlyaWdodCDCqSAyMDEwLTIwMTEgSW50ZWwgQ29ycG9yYXRpb25cbiAqICAgIENvcHlyaWdodCDCqSAyMDEyLTIwMTMgQ29sbGFib3JhLCBMdGQuXG4gKlxuICogICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqICAgIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzXG4gKiAgICAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sXG4gKiAgICBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLFxuICogICAgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSxcbiAqICAgIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sXG4gKiAgICBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSAoaW5jbHVkaW5nIHRoZVxuICogICAgbmV4dCBwYXJhZ3JhcGgpIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWxcbiAqICAgIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiAgICBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogICAgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlNcbiAqICAgIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuICogICAgQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbiAqICAgIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqICAgIFNPRlRXQVJFLlxuICogIFxuICovXG5cbi8qKlxuICogQGludGVyZmFjZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXbFN1cmZhY2VFdmVudHMge1xuXG5cdC8qKlxuXHQgKlxuXHQgKlx0VGhpcyBpcyBlbWl0dGVkIHdoZW5ldmVyIGEgc3VyZmFjZSdzIGNyZWF0aW9uLCBtb3ZlbWVudCwgb3IgcmVzaXppbmdcblx0ICpcdHJlc3VsdHMgaW4gc29tZSBwYXJ0IG9mIGl0IGJlaW5nIHdpdGhpbiB0aGUgc2Nhbm91dCByZWdpb24gb2YgYW5cblx0ICpcdG91dHB1dC5cblx0ICpcblx0ICpcdE5vdGUgdGhhdCBhIHN1cmZhY2UgbWF5IGJlIG92ZXJsYXBwaW5nIHdpdGggemVybyBvciBtb3JlIG91dHB1dHMuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7Kn0gb3V0cHV0IG91dHB1dCBlbnRlcmVkIGJ5IHRoZSBzdXJmYWNlIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0ZW50ZXIob3V0cHV0KSB7fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0VGhpcyBpcyBlbWl0dGVkIHdoZW5ldmVyIGEgc3VyZmFjZSdzIGNyZWF0aW9uLCBtb3ZlbWVudCwgb3IgcmVzaXppbmdcblx0ICpcdHJlc3VsdHMgaW4gaXQgbm8gbG9uZ2VyIGhhdmluZyBhbnkgcGFydCBvZiBpdCB3aXRoaW4gdGhlIHNjYW5vdXQgcmVnaW9uXG5cdCAqXHRvZiBhbiBvdXRwdXQuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7Kn0gb3V0cHV0IG91dHB1dCBsZWZ0IGJ5IHRoZSBzdXJmYWNlIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0bGVhdmUob3V0cHV0KSB7fVxufVxuXG4iLCIvKlxuICpcbiAqICAgIENvcHlyaWdodCDCqSAyMDA4LTIwMTEgS3Jpc3RpYW4gSMO4Z3NiZXJnXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMC0yMDExIEludGVsIENvcnBvcmF0aW9uXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMi0yMDEzIENvbGxhYm9yYSwgTHRkLlxuICpcbiAqICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlc1xuICogICAgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLFxuICogICAgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSxcbiAqICAgIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsXG4gKiAgICBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLFxuICogICAgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgKGluY2x1ZGluZyB0aGVcbiAqICAgIG5leHQgcGFyYWdyYXBoKSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsXG4gKiAgICBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogICAgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqICAgIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTXG4gKiAgICBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU5cbiAqICAgIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOXG4gKiAgICBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiAgICBTT0ZUV0FSRS5cbiAqICBcbiAqL1xuXG5pbXBvcnQgeyBDb25uZWN0aW9uIH0gZnJvbSAnd2VzdGZpZWxkLXJ1bnRpbWUtY29tbW9uJ1xuY29uc3QgeyB1aW50LCB1aW50T3B0aW9uYWwsIGludCwgaW50T3B0aW9uYWwsIGZpeGVkLCBcblx0Zml4ZWRPcHRpb25hbCwgb2JqZWN0LCBvYmplY3RPcHRpb25hbCwgbmV3T2JqZWN0LCBzdHJpbmcsIFxuXHRzdHJpbmdPcHRpb25hbCwgYXJyYXksIGFycmF5T3B0aW9uYWwsIFxuXHRmaWxlRGVzY3JpcHRvck9wdGlvbmFsLCBmaWxlRGVzY3JpcHRvciwgXG5oLCB1LCBpLCBmLCBvLCBuLCBzLCBhIH0gPSBDb25uZWN0aW9uXG5pbXBvcnQgUHJveHkgZnJvbSAnLi9Qcm94eSdcbmltcG9ydCBXbENhbGxiYWNrUHJveHkgZnJvbSAnLi9XbENhbGxiYWNrUHJveHknXG5cbi8qKlxuICpcbiAqICAgICAgQSBzdXJmYWNlIGlzIGEgcmVjdGFuZ3VsYXIgYXJlYSB0aGF0IGlzIGRpc3BsYXllZCBvbiB0aGUgc2NyZWVuLlxuICogICAgICBJdCBoYXMgYSBsb2NhdGlvbiwgc2l6ZSBhbmQgcGl4ZWwgY29udGVudHMuXG4gKlxuICogICAgICBUaGUgc2l6ZSBvZiBhIHN1cmZhY2UgKGFuZCByZWxhdGl2ZSBwb3NpdGlvbnMgb24gaXQpIGlzIGRlc2NyaWJlZFxuICogICAgICBpbiBzdXJmYWNlLWxvY2FsIGNvb3JkaW5hdGVzLCB3aGljaCBtYXkgZGlmZmVyIGZyb20gdGhlIGJ1ZmZlclxuICogICAgICBjb29yZGluYXRlcyBvZiB0aGUgcGl4ZWwgY29udGVudCwgaW4gY2FzZSBhIGJ1ZmZlcl90cmFuc2Zvcm1cbiAqICAgICAgb3IgYSBidWZmZXJfc2NhbGUgaXMgdXNlZC5cbiAqXG4gKiAgICAgIEEgc3VyZmFjZSB3aXRob3V0IGEgXCJyb2xlXCIgaXMgZmFpcmx5IHVzZWxlc3M6IGEgY29tcG9zaXRvciBkb2VzXG4gKiAgICAgIG5vdCBrbm93IHdoZXJlLCB3aGVuIG9yIGhvdyB0byBwcmVzZW50IGl0LiBUaGUgcm9sZSBpcyB0aGVcbiAqICAgICAgcHVycG9zZSBvZiBhIHdsX3N1cmZhY2UuIEV4YW1wbGVzIG9mIHJvbGVzIGFyZSBhIGN1cnNvciBmb3IgYVxuICogICAgICBwb2ludGVyIChhcyBzZXQgYnkgd2xfcG9pbnRlci5zZXRfY3Vyc29yKSwgYSBkcmFnIGljb25cbiAqICAgICAgKHdsX2RhdGFfZGV2aWNlLnN0YXJ0X2RyYWcpLCBhIHN1Yi1zdXJmYWNlXG4gKiAgICAgICh3bF9zdWJjb21wb3NpdG9yLmdldF9zdWJzdXJmYWNlKSwgYW5kIGEgd2luZG93IGFzIGRlZmluZWQgYnkgYVxuICogICAgICBzaGVsbCBwcm90b2NvbCAoZS5nLiB3bF9zaGVsbC5nZXRfc2hlbGxfc3VyZmFjZSkuXG4gKlxuICogICAgICBBIHN1cmZhY2UgY2FuIGhhdmUgb25seSBvbmUgcm9sZSBhdCBhIHRpbWUuIEluaXRpYWxseSBhXG4gKiAgICAgIHdsX3N1cmZhY2UgZG9lcyBub3QgaGF2ZSBhIHJvbGUuIE9uY2UgYSB3bF9zdXJmYWNlIGlzIGdpdmVuIGFcbiAqICAgICAgcm9sZSwgaXQgaXMgc2V0IHBlcm1hbmVudGx5IGZvciB0aGUgd2hvbGUgbGlmZXRpbWUgb2YgdGhlXG4gKiAgICAgIHdsX3N1cmZhY2Ugb2JqZWN0LiBHaXZpbmcgdGhlIGN1cnJlbnQgcm9sZSBhZ2FpbiBpcyBhbGxvd2VkLFxuICogICAgICB1bmxlc3MgZXhwbGljaXRseSBmb3JiaWRkZW4gYnkgdGhlIHJlbGV2YW50IGludGVyZmFjZVxuICogICAgICBzcGVjaWZpY2F0aW9uLlxuICpcbiAqICAgICAgU3VyZmFjZSByb2xlcyBhcmUgZ2l2ZW4gYnkgcmVxdWVzdHMgaW4gb3RoZXIgaW50ZXJmYWNlcyBzdWNoIGFzXG4gKiAgICAgIHdsX3BvaW50ZXIuc2V0X2N1cnNvci4gVGhlIHJlcXVlc3Qgc2hvdWxkIGV4cGxpY2l0bHkgbWVudGlvblxuICogICAgICB0aGF0IHRoaXMgcmVxdWVzdCBnaXZlcyBhIHJvbGUgdG8gYSB3bF9zdXJmYWNlLiBPZnRlbiwgdGhpc1xuICogICAgICByZXF1ZXN0IGFsc28gY3JlYXRlcyBhIG5ldyBwcm90b2NvbCBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZVxuICogICAgICByb2xlIGFuZCBhZGRzIGFkZGl0aW9uYWwgZnVuY3Rpb25hbGl0eSB0byB3bF9zdXJmYWNlLiBXaGVuIGFcbiAqICAgICAgY2xpZW50IHdhbnRzIHRvIGRlc3Ryb3kgYSB3bF9zdXJmYWNlLCB0aGV5IG11c3QgZGVzdHJveSB0aGlzICdyb2xlXG4gKiAgICAgIG9iamVjdCcgYmVmb3JlIHRoZSB3bF9zdXJmYWNlLlxuICpcbiAqICAgICAgRGVzdHJveWluZyB0aGUgcm9sZSBvYmplY3QgZG9lcyBub3QgcmVtb3ZlIHRoZSByb2xlIGZyb20gdGhlXG4gKiAgICAgIHdsX3N1cmZhY2UsIGJ1dCBpdCBtYXkgc3RvcCB0aGUgd2xfc3VyZmFjZSBmcm9tIFwicGxheWluZyB0aGUgcm9sZVwiLlxuICogICAgICBGb3IgaW5zdGFuY2UsIGlmIGEgd2xfc3Vic3VyZmFjZSBvYmplY3QgaXMgZGVzdHJveWVkLCB0aGUgd2xfc3VyZmFjZVxuICogICAgICBpdCB3YXMgY3JlYXRlZCBmb3Igd2lsbCBiZSB1bm1hcHBlZCBhbmQgZm9yZ2V0IGl0cyBwb3NpdGlvbiBhbmRcbiAqICAgICAgei1vcmRlci4gSXQgaXMgYWxsb3dlZCB0byBjcmVhdGUgYSB3bF9zdWJzdXJmYWNlIGZvciB0aGUgc2FtZVxuICogICAgICB3bF9zdXJmYWNlIGFnYWluLCBidXQgaXQgaXMgbm90IGFsbG93ZWQgdG8gdXNlIHRoZSB3bF9zdXJmYWNlIGFzXG4gKiAgICAgIGEgY3Vyc29yIChjdXJzb3IgaXMgYSBkaWZmZXJlbnQgcm9sZSB0aGFuIHN1Yi1zdXJmYWNlLCBhbmQgcm9sZVxuICogICAgICBzd2l0Y2hpbmcgaXMgbm90IGFsbG93ZWQpLlxuICogICAgXG4gKi9cbmNsYXNzIFdsU3VyZmFjZVByb3h5IGV4dGVuZHMgUHJveHkge1xuXG5cdC8qKlxuXHQgKlxuXHQgKlx0RGVsZXRlcyB0aGUgc3VyZmFjZSBhbmQgaW52YWxpZGF0ZXMgaXRzIG9iamVjdCBJRC5cblx0ICogICAgICBcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdGRlc3Ryb3kgKCkge1xuXHRcdHN1cGVyLmRlc3Ryb3koKVxuXHRcdHRoaXMuX21hcnNoYWxsKHRoaXMuaWQsIDAsIFtdKVxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRTZXQgYSBidWZmZXIgYXMgdGhlIGNvbnRlbnQgb2YgdGhpcyBzdXJmYWNlLlxuXHQgKlxuXHQgKlx0VGhlIG5ldyBzaXplIG9mIHRoZSBzdXJmYWNlIGlzIGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIGJ1ZmZlclxuXHQgKlx0c2l6ZSB0cmFuc2Zvcm1lZCBieSB0aGUgaW52ZXJzZSBidWZmZXJfdHJhbnNmb3JtIGFuZCB0aGVcblx0ICpcdGludmVyc2UgYnVmZmVyX3NjYWxlLiBUaGlzIG1lYW5zIHRoYXQgdGhlIHN1cHBsaWVkIGJ1ZmZlclxuXHQgKlx0bXVzdCBiZSBhbiBpbnRlZ2VyIG11bHRpcGxlIG9mIHRoZSBidWZmZXJfc2NhbGUuXG5cdCAqXG5cdCAqXHRUaGUgeCBhbmQgeSBhcmd1bWVudHMgc3BlY2lmeSB0aGUgbG9jYXRpb24gb2YgdGhlIG5ldyBwZW5kaW5nXG5cdCAqXHRidWZmZXIncyB1cHBlciBsZWZ0IGNvcm5lciwgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgYnVmZmVyJ3MgdXBwZXJcblx0ICpcdGxlZnQgY29ybmVyLCBpbiBzdXJmYWNlLWxvY2FsIGNvb3JkaW5hdGVzLiBJbiBvdGhlciB3b3JkcywgdGhlXG5cdCAqXHR4IGFuZCB5LCBjb21iaW5lZCB3aXRoIHRoZSBuZXcgc3VyZmFjZSBzaXplIGRlZmluZSBpbiB3aGljaFxuXHQgKlx0ZGlyZWN0aW9ucyB0aGUgc3VyZmFjZSdzIHNpemUgY2hhbmdlcy5cblx0ICpcblx0ICpcdFN1cmZhY2UgY29udGVudHMgYXJlIGRvdWJsZS1idWZmZXJlZCBzdGF0ZSwgc2VlIHdsX3N1cmZhY2UuY29tbWl0LlxuXHQgKlxuXHQgKlx0VGhlIGluaXRpYWwgc3VyZmFjZSBjb250ZW50cyBhcmUgdm9pZDsgdGhlcmUgaXMgbm8gY29udGVudC5cblx0ICpcdHdsX3N1cmZhY2UuYXR0YWNoIGFzc2lnbnMgdGhlIGdpdmVuIHdsX2J1ZmZlciBhcyB0aGUgcGVuZGluZ1xuXHQgKlx0d2xfYnVmZmVyLiB3bF9zdXJmYWNlLmNvbW1pdCBtYWtlcyB0aGUgcGVuZGluZyB3bF9idWZmZXIgdGhlIG5ld1xuXHQgKlx0c3VyZmFjZSBjb250ZW50cywgYW5kIHRoZSBzaXplIG9mIHRoZSBzdXJmYWNlIGJlY29tZXMgdGhlIHNpemVcblx0ICpcdGNhbGN1bGF0ZWQgZnJvbSB0aGUgd2xfYnVmZmVyLCBhcyBkZXNjcmliZWQgYWJvdmUuIEFmdGVyIGNvbW1pdCxcblx0ICpcdHRoZXJlIGlzIG5vIHBlbmRpbmcgYnVmZmVyIHVudGlsIHRoZSBuZXh0IGF0dGFjaC5cblx0ICpcblx0ICpcdENvbW1pdHRpbmcgYSBwZW5kaW5nIHdsX2J1ZmZlciBhbGxvd3MgdGhlIGNvbXBvc2l0b3IgdG8gcmVhZCB0aGVcblx0ICpcdHBpeGVscyBpbiB0aGUgd2xfYnVmZmVyLiBUaGUgY29tcG9zaXRvciBtYXkgYWNjZXNzIHRoZSBwaXhlbHMgYXRcblx0ICpcdGFueSB0aW1lIGFmdGVyIHRoZSB3bF9zdXJmYWNlLmNvbW1pdCByZXF1ZXN0LiBXaGVuIHRoZSBjb21wb3NpdG9yXG5cdCAqXHR3aWxsIG5vdCBhY2Nlc3MgdGhlIHBpeGVscyBhbnltb3JlLCBpdCB3aWxsIHNlbmQgdGhlXG5cdCAqXHR3bF9idWZmZXIucmVsZWFzZSBldmVudC4gT25seSBhZnRlciByZWNlaXZpbmcgd2xfYnVmZmVyLnJlbGVhc2UsXG5cdCAqXHR0aGUgY2xpZW50IG1heSByZXVzZSB0aGUgd2xfYnVmZmVyLiBBIHdsX2J1ZmZlciB0aGF0IGhhcyBiZWVuXG5cdCAqXHRhdHRhY2hlZCBhbmQgdGhlbiByZXBsYWNlZCBieSBhbm90aGVyIGF0dGFjaCBpbnN0ZWFkIG9mIGNvbW1pdHRlZFxuXHQgKlx0d2lsbCBub3QgcmVjZWl2ZSBhIHJlbGVhc2UgZXZlbnQsIGFuZCBpcyBub3QgdXNlZCBieSB0aGVcblx0ICpcdGNvbXBvc2l0b3IuXG5cdCAqXG5cdCAqXHREZXN0cm95aW5nIHRoZSB3bF9idWZmZXIgYWZ0ZXIgd2xfYnVmZmVyLnJlbGVhc2UgZG9lcyBub3QgY2hhbmdlXG5cdCAqXHR0aGUgc3VyZmFjZSBjb250ZW50cy4gSG93ZXZlciwgaWYgdGhlIGNsaWVudCBkZXN0cm95cyB0aGVcblx0ICpcdHdsX2J1ZmZlciBiZWZvcmUgcmVjZWl2aW5nIHRoZSB3bF9idWZmZXIucmVsZWFzZSBldmVudCwgdGhlIHN1cmZhY2Vcblx0ICpcdGNvbnRlbnRzIGJlY29tZSB1bmRlZmluZWQgaW1tZWRpYXRlbHkuXG5cdCAqXG5cdCAqXHRJZiB3bF9zdXJmYWNlLmF0dGFjaCBpcyBzZW50IHdpdGggYSBOVUxMIHdsX2J1ZmZlciwgdGhlXG5cdCAqXHRmb2xsb3dpbmcgd2xfc3VyZmFjZS5jb21taXQgd2lsbCByZW1vdmUgdGhlIHN1cmZhY2UgY29udGVudC5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHs/Kn0gYnVmZmVyIGJ1ZmZlciBvZiBzdXJmYWNlIGNvbnRlbnRzIFxuXHQgKiBAcGFyYW0ge251bWJlcn0geCBzdXJmYWNlLWxvY2FsIHggY29vcmRpbmF0ZSBcblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgc3VyZmFjZS1sb2NhbCB5IGNvb3JkaW5hdGUgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRhdHRhY2ggKGJ1ZmZlciwgeCwgeSkge1xuXHRcdHRoaXMuX21hcnNoYWxsKHRoaXMuaWQsIDEsIFtvYmplY3RPcHRpb25hbChidWZmZXIpLCBpbnQoeCksIGludCh5KV0pXG5cdH1cblxuXHQvKipcblx0ICpcblx0ICpcdFRoaXMgcmVxdWVzdCBpcyB1c2VkIHRvIGRlc2NyaWJlIHRoZSByZWdpb25zIHdoZXJlIHRoZSBwZW5kaW5nXG5cdCAqXHRidWZmZXIgaXMgZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgc3VyZmFjZSBjb250ZW50cywgYW5kIHdoZXJlXG5cdCAqXHR0aGUgc3VyZmFjZSB0aGVyZWZvcmUgbmVlZHMgdG8gYmUgcmVwYWludGVkLiBUaGUgY29tcG9zaXRvclxuXHQgKlx0aWdub3JlcyB0aGUgcGFydHMgb2YgdGhlIGRhbWFnZSB0aGF0IGZhbGwgb3V0c2lkZSBvZiB0aGUgc3VyZmFjZS5cblx0ICpcblx0ICpcdERhbWFnZSBpcyBkb3VibGUtYnVmZmVyZWQgc3RhdGUsIHNlZSB3bF9zdXJmYWNlLmNvbW1pdC5cblx0ICpcblx0ICpcdFRoZSBkYW1hZ2UgcmVjdGFuZ2xlIGlzIHNwZWNpZmllZCBpbiBzdXJmYWNlLWxvY2FsIGNvb3JkaW5hdGVzLFxuXHQgKlx0d2hlcmUgeCBhbmQgeSBzcGVjaWZ5IHRoZSB1cHBlciBsZWZ0IGNvcm5lciBvZiB0aGUgZGFtYWdlIHJlY3RhbmdsZS5cblx0ICpcblx0ICpcdFRoZSBpbml0aWFsIHZhbHVlIGZvciBwZW5kaW5nIGRhbWFnZSBpcyBlbXB0eTogbm8gZGFtYWdlLlxuXHQgKlx0d2xfc3VyZmFjZS5kYW1hZ2UgYWRkcyBwZW5kaW5nIGRhbWFnZTogdGhlIG5ldyBwZW5kaW5nIGRhbWFnZVxuXHQgKlx0aXMgdGhlIHVuaW9uIG9mIG9sZCBwZW5kaW5nIGRhbWFnZSBhbmQgdGhlIGdpdmVuIHJlY3RhbmdsZS5cblx0ICpcblx0ICpcdHdsX3N1cmZhY2UuY29tbWl0IGFzc2lnbnMgcGVuZGluZyBkYW1hZ2UgYXMgdGhlIGN1cnJlbnQgZGFtYWdlLFxuXHQgKlx0YW5kIGNsZWFycyBwZW5kaW5nIGRhbWFnZS4gVGhlIHNlcnZlciB3aWxsIGNsZWFyIHRoZSBjdXJyZW50XG5cdCAqXHRkYW1hZ2UgYXMgaXQgcmVwYWludHMgdGhlIHN1cmZhY2UuXG5cdCAqXG5cdCAqXHRBbHRlcm5hdGl2ZWx5LCBkYW1hZ2UgY2FuIGJlIHBvc3RlZCB3aXRoIHdsX3N1cmZhY2UuZGFtYWdlX2J1ZmZlclxuXHQgKlx0d2hpY2ggdXNlcyBidWZmZXIgY29vcmRpbmF0ZXMgaW5zdGVhZCBvZiBzdXJmYWNlIGNvb3JkaW5hdGVzLFxuXHQgKlx0YW5kIGlzIHByb2JhYmx5IHRoZSBwcmVmZXJyZWQgYW5kIGludHVpdGl2ZSB3YXkgb2YgZG9pbmcgdGhpcy5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHggc3VyZmFjZS1sb2NhbCB4IGNvb3JkaW5hdGUgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IHN1cmZhY2UtbG9jYWwgeSBjb29yZGluYXRlIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggd2lkdGggb2YgZGFtYWdlIHJlY3RhbmdsZSBcblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBoZWlnaHQgb2YgZGFtYWdlIHJlY3RhbmdsZSBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdGRhbWFnZSAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXHRcdHRoaXMuX21hcnNoYWxsKHRoaXMuaWQsIDIsIFtpbnQoeCksIGludCh5KSwgaW50KHdpZHRoKSwgaW50KGhlaWdodCldKVxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRSZXF1ZXN0IGEgbm90aWZpY2F0aW9uIHdoZW4gaXQgaXMgYSBnb29kIHRpbWUgdG8gc3RhcnQgZHJhd2luZyBhIG5ld1xuXHQgKlx0ZnJhbWUsIGJ5IGNyZWF0aW5nIGEgZnJhbWUgY2FsbGJhY2suIFRoaXMgaXMgdXNlZnVsIGZvciB0aHJvdHRsaW5nXG5cdCAqXHRyZWRyYXdpbmcgb3BlcmF0aW9ucywgYW5kIGRyaXZpbmcgYW5pbWF0aW9ucy5cblx0ICpcblx0ICpcdFdoZW4gYSBjbGllbnQgaXMgYW5pbWF0aW5nIG9uIGEgd2xfc3VyZmFjZSwgaXQgY2FuIHVzZSB0aGUgJ2ZyYW1lJ1xuXHQgKlx0cmVxdWVzdCB0byBnZXQgbm90aWZpZWQgd2hlbiBpdCBpcyBhIGdvb2QgdGltZSB0byBkcmF3IGFuZCBjb21taXQgdGhlXG5cdCAqXHRuZXh0IGZyYW1lIG9mIGFuaW1hdGlvbi4gSWYgdGhlIGNsaWVudCBjb21taXRzIGFuIHVwZGF0ZSBlYXJsaWVyIHRoYW5cblx0ICpcdHRoYXQsIGl0IGlzIGxpa2VseSB0aGF0IHNvbWUgdXBkYXRlcyB3aWxsIG5vdCBtYWtlIGl0IHRvIHRoZSBkaXNwbGF5LFxuXHQgKlx0YW5kIHRoZSBjbGllbnQgaXMgd2FzdGluZyByZXNvdXJjZXMgYnkgZHJhd2luZyB0b28gb2Z0ZW4uXG5cdCAqXG5cdCAqXHRUaGUgZnJhbWUgcmVxdWVzdCB3aWxsIHRha2UgZWZmZWN0IG9uIHRoZSBuZXh0IHdsX3N1cmZhY2UuY29tbWl0LlxuXHQgKlx0VGhlIG5vdGlmaWNhdGlvbiB3aWxsIG9ubHkgYmUgcG9zdGVkIGZvciBvbmUgZnJhbWUgdW5sZXNzXG5cdCAqXHRyZXF1ZXN0ZWQgYWdhaW4uIEZvciBhIHdsX3N1cmZhY2UsIHRoZSBub3RpZmljYXRpb25zIGFyZSBwb3N0ZWQgaW5cblx0ICpcdHRoZSBvcmRlciB0aGUgZnJhbWUgcmVxdWVzdHMgd2VyZSBjb21taXR0ZWQuXG5cdCAqXG5cdCAqXHRUaGUgc2VydmVyIG11c3Qgc2VuZCB0aGUgbm90aWZpY2F0aW9ucyBzbyB0aGF0IGEgY2xpZW50XG5cdCAqXHR3aWxsIG5vdCBzZW5kIGV4Y2Vzc2l2ZSB1cGRhdGVzLCB3aGlsZSBzdGlsbCBhbGxvd2luZ1xuXHQgKlx0dGhlIGhpZ2hlc3QgcG9zc2libGUgdXBkYXRlIHJhdGUgZm9yIGNsaWVudHMgdGhhdCB3YWl0IGZvciB0aGUgcmVwbHlcblx0ICpcdGJlZm9yZSBkcmF3aW5nIGFnYWluLiBUaGUgc2VydmVyIHNob3VsZCBnaXZlIHNvbWUgdGltZSBmb3IgdGhlIGNsaWVudFxuXHQgKlx0dG8gZHJhdyBhbmQgY29tbWl0IGFmdGVyIHNlbmRpbmcgdGhlIGZyYW1lIGNhbGxiYWNrIGV2ZW50cyB0byBsZXQgaXRcblx0ICpcdGhpdCB0aGUgbmV4dCBvdXRwdXQgcmVmcmVzaC5cblx0ICpcblx0ICpcdEEgc2VydmVyIHNob3VsZCBhdm9pZCBzaWduYWxpbmcgdGhlIGZyYW1lIGNhbGxiYWNrcyBpZiB0aGVcblx0ICpcdHN1cmZhY2UgaXMgbm90IHZpc2libGUgaW4gYW55IHdheSwgZS5nLiB0aGUgc3VyZmFjZSBpcyBvZmYtc2NyZWVuLFxuXHQgKlx0b3IgY29tcGxldGVseSBvYnNjdXJlZCBieSBvdGhlciBvcGFxdWUgc3VyZmFjZXMuXG5cdCAqXG5cdCAqXHRUaGUgb2JqZWN0IHJldHVybmVkIGJ5IHRoaXMgcmVxdWVzdCB3aWxsIGJlIGRlc3Ryb3llZCBieSB0aGVcblx0ICpcdGNvbXBvc2l0b3IgYWZ0ZXIgdGhlIGNhbGxiYWNrIGlzIGZpcmVkIGFuZCBhcyBzdWNoIHRoZSBjbGllbnQgbXVzdCBub3Rcblx0ICpcdGF0dGVtcHQgdG8gdXNlIGl0IGFmdGVyIHRoYXQgcG9pbnQuXG5cdCAqXG5cdCAqXHRUaGUgY2FsbGJhY2tfZGF0YSBwYXNzZWQgaW4gdGhlIGNhbGxiYWNrIGlzIHRoZSBjdXJyZW50IHRpbWUsIGluXG5cdCAqXHRtaWxsaXNlY29uZHMsIHdpdGggYW4gdW5kZWZpbmVkIGJhc2UuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEByZXR1cm4ge1dsQ2FsbGJhY2tQcm94eX0gY2FsbGJhY2sgb2JqZWN0IGZvciB0aGUgZnJhbWUgcmVxdWVzdCBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdGZyYW1lICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFyc2hhbGxDb25zdHJ1Y3Rvcih0aGlzLmlkLCAzLCBXbENhbGxiYWNrUHJveHksIFtuZXdPYmplY3QoKV0pXG5cdH1cblxuXHQvKipcblx0ICpcblx0ICpcdFRoaXMgcmVxdWVzdCBzZXRzIHRoZSByZWdpb24gb2YgdGhlIHN1cmZhY2UgdGhhdCBjb250YWluc1xuXHQgKlx0b3BhcXVlIGNvbnRlbnQuXG5cdCAqXG5cdCAqXHRUaGUgb3BhcXVlIHJlZ2lvbiBpcyBhbiBvcHRpbWl6YXRpb24gaGludCBmb3IgdGhlIGNvbXBvc2l0b3Jcblx0ICpcdHRoYXQgbGV0cyBpdCBvcHRpbWl6ZSB0aGUgcmVkcmF3aW5nIG9mIGNvbnRlbnQgYmVoaW5kIG9wYXF1ZVxuXHQgKlx0cmVnaW9ucy4gIFNldHRpbmcgYW4gb3BhcXVlIHJlZ2lvbiBpcyBub3QgcmVxdWlyZWQgZm9yIGNvcnJlY3Rcblx0ICpcdGJlaGF2aW91ciwgYnV0IG1hcmtpbmcgdHJhbnNwYXJlbnQgY29udGVudCBhcyBvcGFxdWUgd2lsbCByZXN1bHRcblx0ICpcdGluIHJlcGFpbnQgYXJ0aWZhY3RzLlxuXHQgKlxuXHQgKlx0VGhlIG9wYXF1ZSByZWdpb24gaXMgc3BlY2lmaWVkIGluIHN1cmZhY2UtbG9jYWwgY29vcmRpbmF0ZXMuXG5cdCAqXG5cdCAqXHRUaGUgY29tcG9zaXRvciBpZ25vcmVzIHRoZSBwYXJ0cyBvZiB0aGUgb3BhcXVlIHJlZ2lvbiB0aGF0IGZhbGxcblx0ICpcdG91dHNpZGUgb2YgdGhlIHN1cmZhY2UuXG5cdCAqXG5cdCAqXHRPcGFxdWUgcmVnaW9uIGlzIGRvdWJsZS1idWZmZXJlZCBzdGF0ZSwgc2VlIHdsX3N1cmZhY2UuY29tbWl0LlxuXHQgKlxuXHQgKlx0d2xfc3VyZmFjZS5zZXRfb3BhcXVlX3JlZ2lvbiBjaGFuZ2VzIHRoZSBwZW5kaW5nIG9wYXF1ZSByZWdpb24uXG5cdCAqXHR3bF9zdXJmYWNlLmNvbW1pdCBjb3BpZXMgdGhlIHBlbmRpbmcgcmVnaW9uIHRvIHRoZSBjdXJyZW50IHJlZ2lvbi5cblx0ICpcdE90aGVyd2lzZSwgdGhlIHBlbmRpbmcgYW5kIGN1cnJlbnQgcmVnaW9ucyBhcmUgbmV2ZXIgY2hhbmdlZC5cblx0ICpcblx0ICpcdFRoZSBpbml0aWFsIHZhbHVlIGZvciBhbiBvcGFxdWUgcmVnaW9uIGlzIGVtcHR5LiBTZXR0aW5nIHRoZSBwZW5kaW5nXG5cdCAqXHRvcGFxdWUgcmVnaW9uIGhhcyBjb3B5IHNlbWFudGljcywgYW5kIHRoZSB3bF9yZWdpb24gb2JqZWN0IGNhbiBiZVxuXHQgKlx0ZGVzdHJveWVkIGltbWVkaWF0ZWx5LiBBIE5VTEwgd2xfcmVnaW9uIGNhdXNlcyB0aGUgcGVuZGluZyBvcGFxdWVcblx0ICpcdHJlZ2lvbiB0byBiZSBzZXQgdG8gZW1wdHkuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7Pyp9IHJlZ2lvbiBvcGFxdWUgcmVnaW9uIG9mIHRoZSBzdXJmYWNlIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0c2V0T3BhcXVlUmVnaW9uIChyZWdpb24pIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCA0LCBbb2JqZWN0T3B0aW9uYWwocmVnaW9uKV0pXG5cdH1cblxuXHQvKipcblx0ICpcblx0ICpcdFRoaXMgcmVxdWVzdCBzZXRzIHRoZSByZWdpb24gb2YgdGhlIHN1cmZhY2UgdGhhdCBjYW4gcmVjZWl2ZVxuXHQgKlx0cG9pbnRlciBhbmQgdG91Y2ggZXZlbnRzLlxuXHQgKlxuXHQgKlx0SW5wdXQgZXZlbnRzIGhhcHBlbmluZyBvdXRzaWRlIG9mIHRoaXMgcmVnaW9uIHdpbGwgdHJ5IHRoZSBuZXh0XG5cdCAqXHRzdXJmYWNlIGluIHRoZSBzZXJ2ZXIgc3VyZmFjZSBzdGFjay4gVGhlIGNvbXBvc2l0b3IgaWdub3JlcyB0aGVcblx0ICpcdHBhcnRzIG9mIHRoZSBpbnB1dCByZWdpb24gdGhhdCBmYWxsIG91dHNpZGUgb2YgdGhlIHN1cmZhY2UuXG5cdCAqXG5cdCAqXHRUaGUgaW5wdXQgcmVnaW9uIGlzIHNwZWNpZmllZCBpbiBzdXJmYWNlLWxvY2FsIGNvb3JkaW5hdGVzLlxuXHQgKlxuXHQgKlx0SW5wdXQgcmVnaW9uIGlzIGRvdWJsZS1idWZmZXJlZCBzdGF0ZSwgc2VlIHdsX3N1cmZhY2UuY29tbWl0LlxuXHQgKlxuXHQgKlx0d2xfc3VyZmFjZS5zZXRfaW5wdXRfcmVnaW9uIGNoYW5nZXMgdGhlIHBlbmRpbmcgaW5wdXQgcmVnaW9uLlxuXHQgKlx0d2xfc3VyZmFjZS5jb21taXQgY29waWVzIHRoZSBwZW5kaW5nIHJlZ2lvbiB0byB0aGUgY3VycmVudCByZWdpb24uXG5cdCAqXHRPdGhlcndpc2UgdGhlIHBlbmRpbmcgYW5kIGN1cnJlbnQgcmVnaW9ucyBhcmUgbmV2ZXIgY2hhbmdlZCxcblx0ICpcdGV4Y2VwdCBjdXJzb3IgYW5kIGljb24gc3VyZmFjZXMgYXJlIHNwZWNpYWwgY2FzZXMsIHNlZVxuXHQgKlx0d2xfcG9pbnRlci5zZXRfY3Vyc29yIGFuZCB3bF9kYXRhX2RldmljZS5zdGFydF9kcmFnLlxuXHQgKlxuXHQgKlx0VGhlIGluaXRpYWwgdmFsdWUgZm9yIGFuIGlucHV0IHJlZ2lvbiBpcyBpbmZpbml0ZS4gVGhhdCBtZWFucyB0aGVcblx0ICpcdHdob2xlIHN1cmZhY2Ugd2lsbCBhY2NlcHQgaW5wdXQuIFNldHRpbmcgdGhlIHBlbmRpbmcgaW5wdXQgcmVnaW9uXG5cdCAqXHRoYXMgY29weSBzZW1hbnRpY3MsIGFuZCB0aGUgd2xfcmVnaW9uIG9iamVjdCBjYW4gYmUgZGVzdHJveWVkXG5cdCAqXHRpbW1lZGlhdGVseS4gQSBOVUxMIHdsX3JlZ2lvbiBjYXVzZXMgdGhlIGlucHV0IHJlZ2lvbiB0byBiZSBzZXRcblx0ICpcdHRvIGluZmluaXRlLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0gez8qfSByZWdpb24gaW5wdXQgcmVnaW9uIG9mIHRoZSBzdXJmYWNlIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0c2V0SW5wdXRSZWdpb24gKHJlZ2lvbikge1xuXHRcdHRoaXMuX21hcnNoYWxsKHRoaXMuaWQsIDUsIFtvYmplY3RPcHRpb25hbChyZWdpb24pXSlcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0U3VyZmFjZSBzdGF0ZSAoaW5wdXQsIG9wYXF1ZSwgYW5kIGRhbWFnZSByZWdpb25zLCBhdHRhY2hlZCBidWZmZXJzLFxuXHQgKlx0ZXRjLikgaXMgZG91YmxlLWJ1ZmZlcmVkLiBQcm90b2NvbCByZXF1ZXN0cyBtb2RpZnkgdGhlIHBlbmRpbmcgc3RhdGUsXG5cdCAqXHRhcyBvcHBvc2VkIHRvIHRoZSBjdXJyZW50IHN0YXRlIGluIHVzZSBieSB0aGUgY29tcG9zaXRvci4gQSBjb21taXRcblx0ICpcdHJlcXVlc3QgYXRvbWljYWxseSBhcHBsaWVzIGFsbCBwZW5kaW5nIHN0YXRlLCByZXBsYWNpbmcgdGhlIGN1cnJlbnRcblx0ICpcdHN0YXRlLiBBZnRlciBjb21taXQsIHRoZSBuZXcgcGVuZGluZyBzdGF0ZSBpcyBhcyBkb2N1bWVudGVkIGZvciBlYWNoXG5cdCAqXHRyZWxhdGVkIHJlcXVlc3QuXG5cdCAqXG5cdCAqXHRPbiBjb21taXQsIGEgcGVuZGluZyB3bF9idWZmZXIgaXMgYXBwbGllZCBmaXJzdCwgYW5kIGFsbCBvdGhlciBzdGF0ZVxuXHQgKlx0c2Vjb25kLiBUaGlzIG1lYW5zIHRoYXQgYWxsIGNvb3JkaW5hdGVzIGluIGRvdWJsZS1idWZmZXJlZCBzdGF0ZSBhcmVcblx0ICpcdHJlbGF0aXZlIHRvIHRoZSBuZXcgd2xfYnVmZmVyIGNvbWluZyBpbnRvIHVzZSwgZXhjZXB0IGZvclxuXHQgKlx0d2xfc3VyZmFjZS5hdHRhY2ggaXRzZWxmLiBJZiB0aGVyZSBpcyBubyBwZW5kaW5nIHdsX2J1ZmZlciwgdGhlXG5cdCAqXHRjb29yZGluYXRlcyBhcmUgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgc3VyZmFjZSBjb250ZW50cy5cblx0ICpcblx0ICpcdEFsbCByZXF1ZXN0cyB0aGF0IG5lZWQgYSBjb21taXQgdG8gYmVjb21lIGVmZmVjdGl2ZSBhcmUgZG9jdW1lbnRlZFxuXHQgKlx0dG8gYWZmZWN0IGRvdWJsZS1idWZmZXJlZCBzdGF0ZS5cblx0ICpcblx0ICpcdE90aGVyIGludGVyZmFjZXMgbWF5IGFkZCBmdXJ0aGVyIGRvdWJsZS1idWZmZXJlZCBzdXJmYWNlIHN0YXRlLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2VyaWFsIHNlcmlhbCBudW1iZXIgb2YgdGhlIGNvbW1pdCBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdGNvbW1pdCAoc2VyaWFsKSB7XG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgNiwgW3VpbnQoc2VyaWFsKV0pXG5cdH1cblxuXHQvKipcblx0ICpcblx0ICpcdFRoaXMgcmVxdWVzdCBzZXRzIGFuIG9wdGlvbmFsIHRyYW5zZm9ybWF0aW9uIG9uIGhvdyB0aGUgY29tcG9zaXRvclxuXHQgKlx0aW50ZXJwcmV0cyB0aGUgY29udGVudHMgb2YgdGhlIGJ1ZmZlciBhdHRhY2hlZCB0byB0aGUgc3VyZmFjZS4gVGhlXG5cdCAqXHRhY2NlcHRlZCB2YWx1ZXMgZm9yIHRoZSB0cmFuc2Zvcm0gcGFyYW1ldGVyIGFyZSB0aGUgdmFsdWVzIGZvclxuXHQgKlx0d2xfb3V0cHV0LnRyYW5zZm9ybS5cblx0ICpcblx0ICpcdEJ1ZmZlciB0cmFuc2Zvcm0gaXMgZG91YmxlLWJ1ZmZlcmVkIHN0YXRlLCBzZWUgd2xfc3VyZmFjZS5jb21taXQuXG5cdCAqXG5cdCAqXHRBIG5ld2x5IGNyZWF0ZWQgc3VyZmFjZSBoYXMgaXRzIGJ1ZmZlciB0cmFuc2Zvcm1hdGlvbiBzZXQgdG8gbm9ybWFsLlxuXHQgKlxuXHQgKlx0d2xfc3VyZmFjZS5zZXRfYnVmZmVyX3RyYW5zZm9ybSBjaGFuZ2VzIHRoZSBwZW5kaW5nIGJ1ZmZlclxuXHQgKlx0dHJhbnNmb3JtYXRpb24uIHdsX3N1cmZhY2UuY29tbWl0IGNvcGllcyB0aGUgcGVuZGluZyBidWZmZXJcblx0ICpcdHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBjdXJyZW50IG9uZS4gT3RoZXJ3aXNlLCB0aGUgcGVuZGluZyBhbmQgY3VycmVudFxuXHQgKlx0dmFsdWVzIGFyZSBuZXZlciBjaGFuZ2VkLlxuXHQgKlxuXHQgKlx0VGhlIHB1cnBvc2Ugb2YgdGhpcyByZXF1ZXN0IGlzIHRvIGFsbG93IGNsaWVudHMgdG8gcmVuZGVyIGNvbnRlbnRcblx0ICpcdGFjY29yZGluZyB0byB0aGUgb3V0cHV0IHRyYW5zZm9ybSwgdGh1cyBwZXJtaXR0aW5nIHRoZSBjb21wb3NpdG9yIHRvXG5cdCAqXHR1c2UgY2VydGFpbiBvcHRpbWl6YXRpb25zIGV2ZW4gaWYgdGhlIGRpc3BsYXkgaXMgcm90YXRlZC4gVXNpbmdcblx0ICpcdGhhcmR3YXJlIG92ZXJsYXlzIGFuZCBzY2FubmluZyBvdXQgYSBjbGllbnQgYnVmZmVyIGZvciBmdWxsc2NyZWVuXG5cdCAqXHRzdXJmYWNlcyBhcmUgZXhhbXBsZXMgb2Ygc3VjaCBvcHRpbWl6YXRpb25zLiBUaG9zZSBvcHRpbWl6YXRpb25zIGFyZVxuXHQgKlx0aGlnaGx5IGRlcGVuZGVudCBvbiB0aGUgY29tcG9zaXRvciBpbXBsZW1lbnRhdGlvbiwgc28gdGhlIHVzZSBvZiB0aGlzXG5cdCAqXHRyZXF1ZXN0IHNob3VsZCBiZSBjb25zaWRlcmVkIG9uIGEgY2FzZS1ieS1jYXNlIGJhc2lzLlxuXHQgKlxuXHQgKlx0Tm90ZSB0aGF0IGlmIHRoZSB0cmFuc2Zvcm0gdmFsdWUgaW5jbHVkZXMgOTAgb3IgMjcwIGRlZ3JlZSByb3RhdGlvbixcblx0ICpcdHRoZSB3aWR0aCBvZiB0aGUgYnVmZmVyIHdpbGwgYmVjb21lIHRoZSBzdXJmYWNlIGhlaWdodCBhbmQgdGhlIGhlaWdodFxuXHQgKlx0b2YgdGhlIGJ1ZmZlciB3aWxsIGJlY29tZSB0aGUgc3VyZmFjZSB3aWR0aC5cblx0ICpcblx0ICpcdElmIHRyYW5zZm9ybSBpcyBub3Qgb25lIG9mIHRoZSB2YWx1ZXMgZnJvbSB0aGVcblx0ICpcdHdsX291dHB1dC50cmFuc2Zvcm0gZW51bSB0aGUgaW52YWxpZF90cmFuc2Zvcm0gcHJvdG9jb2wgZXJyb3Jcblx0ICpcdGlzIHJhaXNlZC5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRyYW5zZm9ybSB0cmFuc2Zvcm0gZm9yIGludGVycHJldGluZyBidWZmZXIgY29udGVudHMgXG5cdCAqXG5cdCAqIEBzaW5jZSAyXG5cdCAqXG5cdCAqL1xuXHRzZXRCdWZmZXJUcmFuc2Zvcm0gKHRyYW5zZm9ybSkge1xuXHRcdHRoaXMuX21hcnNoYWxsKHRoaXMuaWQsIDcsIFtpbnQodHJhbnNmb3JtKV0pXG5cdH1cblxuXHQvKipcblx0ICpcblx0ICpcdFRoaXMgcmVxdWVzdCBzZXRzIGFuIG9wdGlvbmFsIHNjYWxpbmcgZmFjdG9yIG9uIGhvdyB0aGUgY29tcG9zaXRvclxuXHQgKlx0aW50ZXJwcmV0cyB0aGUgY29udGVudHMgb2YgdGhlIGJ1ZmZlciBhdHRhY2hlZCB0byB0aGUgd2luZG93LlxuXHQgKlxuXHQgKlx0QnVmZmVyIHNjYWxlIGlzIGRvdWJsZS1idWZmZXJlZCBzdGF0ZSwgc2VlIHdsX3N1cmZhY2UuY29tbWl0LlxuXHQgKlxuXHQgKlx0QSBuZXdseSBjcmVhdGVkIHN1cmZhY2UgaGFzIGl0cyBidWZmZXIgc2NhbGUgc2V0IHRvIDEuXG5cdCAqXG5cdCAqXHR3bF9zdXJmYWNlLnNldF9idWZmZXJfc2NhbGUgY2hhbmdlcyB0aGUgcGVuZGluZyBidWZmZXIgc2NhbGUuXG5cdCAqXHR3bF9zdXJmYWNlLmNvbW1pdCBjb3BpZXMgdGhlIHBlbmRpbmcgYnVmZmVyIHNjYWxlIHRvIHRoZSBjdXJyZW50IG9uZS5cblx0ICpcdE90aGVyd2lzZSwgdGhlIHBlbmRpbmcgYW5kIGN1cnJlbnQgdmFsdWVzIGFyZSBuZXZlciBjaGFuZ2VkLlxuXHQgKlxuXHQgKlx0VGhlIHB1cnBvc2Ugb2YgdGhpcyByZXF1ZXN0IGlzIHRvIGFsbG93IGNsaWVudHMgdG8gc3VwcGx5IGhpZ2hlclxuXHQgKlx0cmVzb2x1dGlvbiBidWZmZXIgZGF0YSBmb3IgdXNlIG9uIGhpZ2ggcmVzb2x1dGlvbiBvdXRwdXRzLiBJdCBpc1xuXHQgKlx0aW50ZW5kZWQgdGhhdCB5b3UgcGljayB0aGUgc2FtZSBidWZmZXIgc2NhbGUgYXMgdGhlIHNjYWxlIG9mIHRoZVxuXHQgKlx0b3V0cHV0IHRoYXQgdGhlIHN1cmZhY2UgaXMgZGlzcGxheWVkIG9uLiBUaGlzIG1lYW5zIHRoZSBjb21wb3NpdG9yXG5cdCAqXHRjYW4gYXZvaWQgc2NhbGluZyB3aGVuIHJlbmRlcmluZyB0aGUgc3VyZmFjZSBvbiB0aGF0IG91dHB1dC5cblx0ICpcblx0ICpcdE5vdGUgdGhhdCBpZiB0aGUgc2NhbGUgaXMgbGFyZ2VyIHRoYW4gMSwgdGhlbiB5b3UgaGF2ZSB0byBhdHRhY2hcblx0ICpcdGEgYnVmZmVyIHRoYXQgaXMgbGFyZ2VyIChieSBhIGZhY3RvciBvZiBzY2FsZSBpbiBlYWNoIGRpbWVuc2lvbilcblx0ICpcdHRoYW4gdGhlIGRlc2lyZWQgc3VyZmFjZSBzaXplLlxuXHQgKlxuXHQgKlx0SWYgc2NhbGUgaXMgbm90IHBvc2l0aXZlIHRoZSBpbnZhbGlkX3NjYWxlIHByb3RvY29sIGVycm9yIGlzXG5cdCAqXHRyYWlzZWQuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSBwb3NpdGl2ZSBzY2FsZSBmb3IgaW50ZXJwcmV0aW5nIGJ1ZmZlciBjb250ZW50cyBcblx0ICpcblx0ICogQHNpbmNlIDNcblx0ICpcblx0ICovXG5cdHNldEJ1ZmZlclNjYWxlIChzY2FsZSkge1xuXHRcdHRoaXMuX21hcnNoYWxsKHRoaXMuaWQsIDgsIFtpbnQoc2NhbGUpXSlcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0VGhpcyByZXF1ZXN0IGlzIHVzZWQgdG8gZGVzY3JpYmUgdGhlIHJlZ2lvbnMgd2hlcmUgdGhlIHBlbmRpbmdcblx0ICpcdGJ1ZmZlciBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBzdXJmYWNlIGNvbnRlbnRzLCBhbmQgd2hlcmVcblx0ICpcdHRoZSBzdXJmYWNlIHRoZXJlZm9yZSBuZWVkcyB0byBiZSByZXBhaW50ZWQuIFRoZSBjb21wb3NpdG9yXG5cdCAqXHRpZ25vcmVzIHRoZSBwYXJ0cyBvZiB0aGUgZGFtYWdlIHRoYXQgZmFsbCBvdXRzaWRlIG9mIHRoZSBzdXJmYWNlLlxuXHQgKlxuXHQgKlx0RGFtYWdlIGlzIGRvdWJsZS1idWZmZXJlZCBzdGF0ZSwgc2VlIHdsX3N1cmZhY2UuY29tbWl0LlxuXHQgKlxuXHQgKlx0VGhlIGRhbWFnZSByZWN0YW5nbGUgaXMgc3BlY2lmaWVkIGluIGJ1ZmZlciBjb29yZGluYXRlcyxcblx0ICpcdHdoZXJlIHggYW5kIHkgc3BlY2lmeSB0aGUgdXBwZXIgbGVmdCBjb3JuZXIgb2YgdGhlIGRhbWFnZSByZWN0YW5nbGUuXG5cdCAqXG5cdCAqXHRUaGUgaW5pdGlhbCB2YWx1ZSBmb3IgcGVuZGluZyBkYW1hZ2UgaXMgZW1wdHk6IG5vIGRhbWFnZS5cblx0ICpcdHdsX3N1cmZhY2UuZGFtYWdlX2J1ZmZlciBhZGRzIHBlbmRpbmcgZGFtYWdlOiB0aGUgbmV3IHBlbmRpbmdcblx0ICpcdGRhbWFnZSBpcyB0aGUgdW5pb24gb2Ygb2xkIHBlbmRpbmcgZGFtYWdlIGFuZCB0aGUgZ2l2ZW4gcmVjdGFuZ2xlLlxuXHQgKlxuXHQgKlx0d2xfc3VyZmFjZS5jb21taXQgYXNzaWducyBwZW5kaW5nIGRhbWFnZSBhcyB0aGUgY3VycmVudCBkYW1hZ2UsXG5cdCAqXHRhbmQgY2xlYXJzIHBlbmRpbmcgZGFtYWdlLiBUaGUgc2VydmVyIHdpbGwgY2xlYXIgdGhlIGN1cnJlbnRcblx0ICpcdGRhbWFnZSBhcyBpdCByZXBhaW50cyB0aGUgc3VyZmFjZS5cblx0ICpcblx0ICpcdFRoaXMgcmVxdWVzdCBkaWZmZXJzIGZyb20gd2xfc3VyZmFjZS5kYW1hZ2UgaW4gb25seSBvbmUgd2F5IC0gaXRcblx0ICpcdHRha2VzIGRhbWFnZSBpbiBidWZmZXIgY29vcmRpbmF0ZXMgaW5zdGVhZCBvZiBzdXJmYWNlLWxvY2FsXG5cdCAqXHRjb29yZGluYXRlcy4gV2hpbGUgdGhpcyBnZW5lcmFsbHkgaXMgbW9yZSBpbnR1aXRpdmUgdGhhbiBzdXJmYWNlXG5cdCAqXHRjb29yZGluYXRlcywgaXQgaXMgZXNwZWNpYWxseSBkZXNpcmFibGUgd2hlbiB1c2luZyB3cF92aWV3cG9ydFxuXHQgKlx0b3Igd2hlbiBhIGRyYXdpbmcgbGlicmFyeSAobGlrZSBFR0wpIGlzIHVuYXdhcmUgb2YgYnVmZmVyIHNjYWxlXG5cdCAqXHRhbmQgYnVmZmVyIHRyYW5zZm9ybS5cblx0ICpcblx0ICpcdE5vdGU6IEJlY2F1c2UgYnVmZmVyIHRyYW5zZm9ybWF0aW9uIGNoYW5nZXMgYW5kIGRhbWFnZSByZXF1ZXN0cyBtYXlcblx0ICpcdGJlIGludGVybGVhdmVkIGluIHRoZSBwcm90b2NvbCBzdHJlYW0sIGl0IGlzIGltcG9zc2libGUgdG8gZGV0ZXJtaW5lXG5cdCAqXHR0aGUgYWN0dWFsIG1hcHBpbmcgYmV0d2VlbiBzdXJmYWNlIGFuZCBidWZmZXIgZGFtYWdlIHVudGlsXG5cdCAqXHR3bF9zdXJmYWNlLmNvbW1pdCB0aW1lLiBUaGVyZWZvcmUsIGNvbXBvc2l0b3JzIHdpc2hpbmcgdG8gdGFrZSBib3RoXG5cdCAqXHRraW5kcyBvZiBkYW1hZ2UgaW50byBhY2NvdW50IHdpbGwgaGF2ZSB0byBhY2N1bXVsYXRlIGRhbWFnZSBmcm9tIHRoZVxuXHQgKlx0dHdvIHJlcXVlc3RzIHNlcGFyYXRlbHkgYW5kIG9ubHkgdHJhbnNmb3JtIGZyb20gb25lIHRvIHRoZSBvdGhlclxuXHQgKlx0YWZ0ZXIgcmVjZWl2aW5nIHRoZSB3bF9zdXJmYWNlLmNvbW1pdC5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHggYnVmZmVyLWxvY2FsIHggY29vcmRpbmF0ZSBcblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgYnVmZmVyLWxvY2FsIHkgY29vcmRpbmF0ZSBcblx0ICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIHdpZHRoIG9mIGRhbWFnZSByZWN0YW5nbGUgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgaGVpZ2h0IG9mIGRhbWFnZSByZWN0YW5nbGUgXG5cdCAqXG5cdCAqIEBzaW5jZSA0XG5cdCAqXG5cdCAqL1xuXHRkYW1hZ2VCdWZmZXIgKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCA5LCBbaW50KHgpLCBpbnQoeSksIGludCh3aWR0aCksIGludChoZWlnaHQpXSlcblx0fVxuXG5cdC8qKlxuXHQgKiBEbyBub3QgY29uc3RydWN0IHByb3hpZXMgZGlyZWN0bHkuIEluc3RlYWQgdXNlIG9uZSBvZiB0aGUgZmFjdG9yeSBtZXRob2RzIGZyb20gb3RoZXIgcHJveGllcy5cblx0ICpAcGFyYW0ge0Rpc3BsYXl9ZGlzcGxheVxuXHQgKkBwYXJhbSB7Q29ubmVjdGlvbn1jb25uZWN0aW9uXG5cdCAqQHBhcmFtIHtudW1iZXJ9aWRcblx0ICovXG5cdGNvbnN0cnVjdG9yIChkaXNwbGF5LCBjb25uZWN0aW9uLCBpZCkge1xuXHRcdHN1cGVyKGRpc3BsYXksIGNvbm5lY3Rpb24sIGlkKVxuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtXbFN1cmZhY2VFdmVudHN8bnVsbH1cblx0XHQgKi9cblx0XHR0aGlzLmxpc3RlbmVyID0gbnVsbFxuXHR9XG5cblx0YXN5bmMgWzBdIChtZXNzYWdlKSB7XG5cdFx0YXdhaXQgdGhpcy5saXN0ZW5lci5lbnRlcihvKG1lc3NhZ2UsIGZhbHNlLCB0aGlzLl9jb25uZWN0aW9uKSlcblx0fVxuXG5cdGFzeW5jIFsxXSAobWVzc2FnZSkge1xuXHRcdGF3YWl0IHRoaXMubGlzdGVuZXIubGVhdmUobyhtZXNzYWdlLCBmYWxzZSwgdGhpcy5fY29ubmVjdGlvbikpXG5cdH1cblxufVxuV2xTdXJmYWNlUHJveHkucHJvdG9jb2xOYW1lID0gJ3dsX3N1cmZhY2UnXG5cbldsU3VyZmFjZVByb3h5LkVycm9yID0ge1xuICAvKipcbiAgICogYnVmZmVyIHNjYWxlIHZhbHVlIGlzIGludmFsaWRcbiAgICovXG4gIGludmFsaWRTY2FsZTogMCxcbiAgLyoqXG4gICAqIGJ1ZmZlciB0cmFuc2Zvcm0gdmFsdWUgaXMgaW52YWxpZFxuICAgKi9cbiAgaW52YWxpZFRyYW5zZm9ybTogMVxufVxuXG5leHBvcnQgZGVmYXVsdCBXbFN1cmZhY2VQcm94eVxuIiwiLypcbiAqXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAwOC0yMDExIEtyaXN0aWFuIEjDuGdzYmVyZ1xuICogICAgQ29weXJpZ2h0IMKpIDIwMTAtMjAxMSBJbnRlbCBDb3Jwb3JhdGlvblxuICogICAgQ29weXJpZ2h0IMKpIDIwMTItMjAxMyBDb2xsYWJvcmEsIEx0ZC5cbiAqXG4gKiAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAqICAgICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAqICAgIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gKiAgICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICogICAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAqICAgIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIChpbmNsdWRpbmcgdGhlXG4gKiAgICBuZXh0IHBhcmFncmFwaCkgc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbFxuICogICAgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAqICAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiAgICBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICogICAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gKiAgICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICogICAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogICAgU09GVFdBUkUuXG4gKiAgXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJmYWNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFdsVG91Y2hFdmVudHMge1xuXG5cdC8qKlxuXHQgKlxuXHQgKlx0QSBuZXcgdG91Y2ggcG9pbnQgaGFzIGFwcGVhcmVkIG9uIHRoZSBzdXJmYWNlLiBUaGlzIHRvdWNoIHBvaW50IGlzXG5cdCAqXHRhc3NpZ25lZCBhIHVuaXF1ZSBJRC4gRnV0dXJlIGV2ZW50cyBmcm9tIHRoaXMgdG91Y2ggcG9pbnQgcmVmZXJlbmNlXG5cdCAqXHR0aGlzIElELiBUaGUgSUQgY2Vhc2VzIHRvIGJlIHZhbGlkIGFmdGVyIGEgdG91Y2ggdXAgZXZlbnQgYW5kIG1heSBiZVxuXHQgKlx0cmV1c2VkIGluIHRoZSBmdXR1cmUuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzZXJpYWwgc2VyaWFsIG51bWJlciBvZiB0aGUgdG91Y2ggZG93biBldmVudCBcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgdGltZXN0YW1wIHdpdGggbWlsbGlzZWNvbmQgZ3JhbnVsYXJpdHkgXG5cdCAqIEBwYXJhbSB7Kn0gc3VyZmFjZSBzdXJmYWNlIHRvdWNoZWQgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpZCB0aGUgdW5pcXVlIElEIG9mIHRoaXMgdG91Y2ggcG9pbnQgXG5cdCAqIEBwYXJhbSB7Rml4ZWR9IHggc3VyZmFjZS1sb2NhbCB4IGNvb3JkaW5hdGUgXG5cdCAqIEBwYXJhbSB7Rml4ZWR9IHkgc3VyZmFjZS1sb2NhbCB5IGNvb3JkaW5hdGUgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRkb3duKHNlcmlhbCwgdGltZSwgc3VyZmFjZSwgaWQsIHgsIHkpIHt9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRUaGUgdG91Y2ggcG9pbnQgaGFzIGRpc2FwcGVhcmVkLiBObyBmdXJ0aGVyIGV2ZW50cyB3aWxsIGJlIHNlbnQgZm9yXG5cdCAqXHR0aGlzIHRvdWNoIHBvaW50IGFuZCB0aGUgdG91Y2ggcG9pbnQncyBJRCBpcyByZWxlYXNlZCBhbmQgbWF5IGJlXG5cdCAqXHRyZXVzZWQgaW4gYSBmdXR1cmUgdG91Y2ggZG93biBldmVudC5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHNlcmlhbCBzZXJpYWwgbnVtYmVyIG9mIHRoZSB0b3VjaCB1cCBldmVudCBcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgdGltZXN0YW1wIHdpdGggbWlsbGlzZWNvbmQgZ3JhbnVsYXJpdHkgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpZCB0aGUgdW5pcXVlIElEIG9mIHRoaXMgdG91Y2ggcG9pbnQgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHR1cChzZXJpYWwsIHRpbWUsIGlkKSB7fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0QSB0b3VjaCBwb2ludCBoYXMgY2hhbmdlZCBjb29yZGluYXRlcy5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgdGltZXN0YW1wIHdpdGggbWlsbGlzZWNvbmQgZ3JhbnVsYXJpdHkgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpZCB0aGUgdW5pcXVlIElEIG9mIHRoaXMgdG91Y2ggcG9pbnQgXG5cdCAqIEBwYXJhbSB7Rml4ZWR9IHggc3VyZmFjZS1sb2NhbCB4IGNvb3JkaW5hdGUgXG5cdCAqIEBwYXJhbSB7Rml4ZWR9IHkgc3VyZmFjZS1sb2NhbCB5IGNvb3JkaW5hdGUgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRtb3Rpb24odGltZSwgaWQsIHgsIHkpIHt9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRJbmRpY2F0ZXMgdGhlIGVuZCBvZiBhIHNldCBvZiBldmVudHMgdGhhdCBsb2dpY2FsbHkgYmVsb25nIHRvZ2V0aGVyLlxuXHQgKlx0QSBjbGllbnQgaXMgZXhwZWN0ZWQgdG8gYWNjdW11bGF0ZSB0aGUgZGF0YSBpbiBhbGwgZXZlbnRzIHdpdGhpbiB0aGVcblx0ICpcdGZyYW1lIGJlZm9yZSBwcm9jZWVkaW5nLlxuXHQgKlxuXHQgKlx0QSB3bF90b3VjaC5mcmFtZSB0ZXJtaW5hdGVzIGF0IGxlYXN0IG9uZSBldmVudCBidXQgb3RoZXJ3aXNlIG5vXG5cdCAqXHRndWFyYW50ZWUgaXMgcHJvdmlkZWQgYWJvdXQgdGhlIHNldCBvZiBldmVudHMgd2l0aGluIGEgZnJhbWUuIEEgY2xpZW50XG5cdCAqXHRtdXN0IGFzc3VtZSB0aGF0IGFueSBzdGF0ZSBub3QgdXBkYXRlZCBpbiBhIGZyYW1lIGlzIHVuY2hhbmdlZCBmcm9tIHRoZVxuXHQgKlx0cHJldmlvdXNseSBrbm93biBzdGF0ZS5cblx0ICogICAgICBcblx0ICpcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdGZyYW1lKCkge31cblxuXHQvKipcblx0ICpcblx0ICpcdFNlbnQgaWYgdGhlIGNvbXBvc2l0b3IgZGVjaWRlcyB0aGUgdG91Y2ggc3RyZWFtIGlzIGEgZ2xvYmFsXG5cdCAqXHRnZXN0dXJlLiBObyBmdXJ0aGVyIGV2ZW50cyBhcmUgc2VudCB0byB0aGUgY2xpZW50cyBmcm9tIHRoYXRcblx0ICpcdHBhcnRpY3VsYXIgZ2VzdHVyZS4gVG91Y2ggY2FuY2VsbGF0aW9uIGFwcGxpZXMgdG8gYWxsIHRvdWNoIHBvaW50c1xuXHQgKlx0Y3VycmVudGx5IGFjdGl2ZSBvbiB0aGlzIGNsaWVudCdzIHN1cmZhY2UuIFRoZSBjbGllbnQgaXNcblx0ICpcdHJlc3BvbnNpYmxlIGZvciBmaW5hbGl6aW5nIHRoZSB0b3VjaCBwb2ludHMsIGZ1dHVyZSB0b3VjaCBwb2ludHMgb25cblx0ICpcdHRoaXMgc3VyZmFjZSBtYXkgcmV1c2UgdGhlIHRvdWNoIHBvaW50IElELlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0Y2FuY2VsKCkge31cblxuXHQvKipcblx0ICpcblx0ICpcdFNlbnQgd2hlbiBhIHRvdWNocG9pbnQgaGFzIGNoYW5nZWQgaXRzIHNoYXBlLlxuXHQgKlxuXHQgKlx0VGhpcyBldmVudCBkb2VzIG5vdCBvY2N1ciBvbiBpdHMgb3duLiBJdCBpcyBzZW50IGJlZm9yZSBhXG5cdCAqXHR3bF90b3VjaC5mcmFtZSBldmVudCBhbmQgY2FycmllcyB0aGUgbmV3IHNoYXBlIGluZm9ybWF0aW9uIGZvclxuXHQgKlx0YW55IHByZXZpb3VzbHkgcmVwb3J0ZWQsIG9yIG5ldyB0b3VjaCBwb2ludHMgb2YgdGhhdCBmcmFtZS5cblx0ICpcblx0ICpcdE90aGVyIGV2ZW50cyBkZXNjcmliaW5nIHRoZSB0b3VjaCBwb2ludCBzdWNoIGFzIHdsX3RvdWNoLmRvd24sXG5cdCAqXHR3bF90b3VjaC5tb3Rpb24gb3Igd2xfdG91Y2gub3JpZW50YXRpb24gbWF5IGJlIHNlbnQgd2l0aGluIHRoZVxuXHQgKlx0c2FtZSB3bF90b3VjaC5mcmFtZS4gQSBjbGllbnQgc2hvdWxkIHRyZWF0IHRoZXNlIGV2ZW50cyBhcyBhIHNpbmdsZVxuXHQgKlx0bG9naWNhbCB0b3VjaCBwb2ludCB1cGRhdGUuIFRoZSBvcmRlciBvZiB3bF90b3VjaC5zaGFwZSxcblx0ICpcdHdsX3RvdWNoLm9yaWVudGF0aW9uIGFuZCB3bF90b3VjaC5tb3Rpb24gaXMgbm90IGd1YXJhbnRlZWQuXG5cdCAqXHRBIHdsX3RvdWNoLmRvd24gZXZlbnQgaXMgZ3VhcmFudGVlZCB0byBvY2N1ciBiZWZvcmUgdGhlIGZpcnN0XG5cdCAqXHR3bF90b3VjaC5zaGFwZSBldmVudCBmb3IgdGhpcyB0b3VjaCBJRCBidXQgYm90aCBldmVudHMgbWF5IG9jY3VyIHdpdGhpblxuXHQgKlx0dGhlIHNhbWUgd2xfdG91Y2guZnJhbWUuXG5cdCAqXG5cdCAqXHRBIHRvdWNocG9pbnQgc2hhcGUgaXMgYXBwcm94aW1hdGVkIGJ5IGFuIGVsbGlwc2UgdGhyb3VnaCB0aGUgbWFqb3IgYW5kXG5cdCAqXHRtaW5vciBheGlzIGxlbmd0aC4gVGhlIG1ham9yIGF4aXMgbGVuZ3RoIGRlc2NyaWJlcyB0aGUgbG9uZ2VyIGRpYW1ldGVyXG5cdCAqXHRvZiB0aGUgZWxsaXBzZSwgd2hpbGUgdGhlIG1pbm9yIGF4aXMgbGVuZ3RoIGRlc2NyaWJlcyB0aGUgc2hvcnRlclxuXHQgKlx0ZGlhbWV0ZXIuIE1ham9yIGFuZCBtaW5vciBhcmUgb3J0aG9nb25hbCBhbmQgYm90aCBhcmUgc3BlY2lmaWVkIGluXG5cdCAqXHRzdXJmYWNlLWxvY2FsIGNvb3JkaW5hdGVzLiBUaGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlIGlzIGFsd2F5cyBhdCB0aGVcblx0ICpcdHRvdWNocG9pbnQgbG9jYXRpb24gYXMgcmVwb3J0ZWQgYnkgd2xfdG91Y2guZG93biBvciB3bF90b3VjaC5tb3ZlLlxuXHQgKlxuXHQgKlx0VGhpcyBldmVudCBpcyBvbmx5IHNlbnQgYnkgdGhlIGNvbXBvc2l0b3IgaWYgdGhlIHRvdWNoIGRldmljZSBzdXBwb3J0c1xuXHQgKlx0c2hhcGUgcmVwb3J0cy4gVGhlIGNsaWVudCBoYXMgdG8gbWFrZSByZWFzb25hYmxlIGFzc3VtcHRpb25zIGFib3V0IHRoZVxuXHQgKlx0c2hhcGUgaWYgaXQgZGlkIG5vdCByZWNlaXZlIHRoaXMgZXZlbnQuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpZCB0aGUgdW5pcXVlIElEIG9mIHRoaXMgdG91Y2ggcG9pbnQgXG5cdCAqIEBwYXJhbSB7Rml4ZWR9IG1ham9yIGxlbmd0aCBvZiB0aGUgbWFqb3IgYXhpcyBpbiBzdXJmYWNlLWxvY2FsIGNvb3JkaW5hdGVzIFxuXHQgKiBAcGFyYW0ge0ZpeGVkfSBtaW5vciBsZW5ndGggb2YgdGhlIG1pbm9yIGF4aXMgaW4gc3VyZmFjZS1sb2NhbCBjb29yZGluYXRlcyBcblx0ICpcblx0ICogQHNpbmNlIDZcblx0ICpcblx0ICovXG5cdHNoYXBlKGlkLCBtYWpvciwgbWlub3IpIHt9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRTZW50IHdoZW4gYSB0b3VjaHBvaW50IGhhcyBjaGFuZ2VkIGl0cyBvcmllbnRhdGlvbi5cblx0ICpcblx0ICpcdFRoaXMgZXZlbnQgZG9lcyBub3Qgb2NjdXIgb24gaXRzIG93bi4gSXQgaXMgc2VudCBiZWZvcmUgYVxuXHQgKlx0d2xfdG91Y2guZnJhbWUgZXZlbnQgYW5kIGNhcnJpZXMgdGhlIG5ldyBzaGFwZSBpbmZvcm1hdGlvbiBmb3Jcblx0ICpcdGFueSBwcmV2aW91c2x5IHJlcG9ydGVkLCBvciBuZXcgdG91Y2ggcG9pbnRzIG9mIHRoYXQgZnJhbWUuXG5cdCAqXG5cdCAqXHRPdGhlciBldmVudHMgZGVzY3JpYmluZyB0aGUgdG91Y2ggcG9pbnQgc3VjaCBhcyB3bF90b3VjaC5kb3duLFxuXHQgKlx0d2xfdG91Y2gubW90aW9uIG9yIHdsX3RvdWNoLnNoYXBlIG1heSBiZSBzZW50IHdpdGhpbiB0aGVcblx0ICpcdHNhbWUgd2xfdG91Y2guZnJhbWUuIEEgY2xpZW50IHNob3VsZCB0cmVhdCB0aGVzZSBldmVudHMgYXMgYSBzaW5nbGVcblx0ICpcdGxvZ2ljYWwgdG91Y2ggcG9pbnQgdXBkYXRlLiBUaGUgb3JkZXIgb2Ygd2xfdG91Y2guc2hhcGUsXG5cdCAqXHR3bF90b3VjaC5vcmllbnRhdGlvbiBhbmQgd2xfdG91Y2gubW90aW9uIGlzIG5vdCBndWFyYW50ZWVkLlxuXHQgKlx0QSB3bF90b3VjaC5kb3duIGV2ZW50IGlzIGd1YXJhbnRlZWQgdG8gb2NjdXIgYmVmb3JlIHRoZSBmaXJzdFxuXHQgKlx0d2xfdG91Y2gub3JpZW50YXRpb24gZXZlbnQgZm9yIHRoaXMgdG91Y2ggSUQgYnV0IGJvdGggZXZlbnRzIG1heSBvY2N1clxuXHQgKlx0d2l0aGluIHRoZSBzYW1lIHdsX3RvdWNoLmZyYW1lLlxuXHQgKlxuXHQgKlx0VGhlIG9yaWVudGF0aW9uIGRlc2NyaWJlcyB0aGUgY2xvY2t3aXNlIGFuZ2xlIG9mIGEgdG91Y2hwb2ludCdzIG1ham9yXG5cdCAqXHRheGlzIHRvIHRoZSBwb3NpdGl2ZSBzdXJmYWNlIHktYXhpcyBhbmQgaXMgbm9ybWFsaXplZCB0byB0aGUgLTE4MCB0b1xuXHQgKlx0KzE4MCBkZWdyZWUgcmFuZ2UuIFRoZSBncmFudWxhcml0eSBvZiBvcmllbnRhdGlvbiBkZXBlbmRzIG9uIHRoZSB0b3VjaFxuXHQgKlx0ZGV2aWNlLCBzb21lIGRldmljZXMgb25seSBzdXBwb3J0IGJpbmFyeSByb3RhdGlvbiB2YWx1ZXMgYmV0d2VlbiAwIGFuZFxuXHQgKlx0OTAgZGVncmVlcy5cblx0ICpcblx0ICpcdFRoaXMgZXZlbnQgaXMgb25seSBzZW50IGJ5IHRoZSBjb21wb3NpdG9yIGlmIHRoZSB0b3VjaCBkZXZpY2Ugc3VwcG9ydHNcblx0ICpcdG9yaWVudGF0aW9uIHJlcG9ydHMuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpZCB0aGUgdW5pcXVlIElEIG9mIHRoaXMgdG91Y2ggcG9pbnQgXG5cdCAqIEBwYXJhbSB7Rml4ZWR9IG9yaWVudGF0aW9uIGFuZ2xlIGJldHdlZW4gbWFqb3IgYXhpcyBhbmQgcG9zaXRpdmUgc3VyZmFjZSB5LWF4aXMgaW4gZGVncmVlcyBcblx0ICpcblx0ICogQHNpbmNlIDZcblx0ICpcblx0ICovXG5cdG9yaWVudGF0aW9uKGlkLCBvcmllbnRhdGlvbikge31cbn1cblxuIiwiLypcbiAqXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAwOC0yMDExIEtyaXN0aWFuIEjDuGdzYmVyZ1xuICogICAgQ29weXJpZ2h0IMKpIDIwMTAtMjAxMSBJbnRlbCBDb3Jwb3JhdGlvblxuICogICAgQ29weXJpZ2h0IMKpIDIwMTItMjAxMyBDb2xsYWJvcmEsIEx0ZC5cbiAqXG4gKiAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXNcbiAqICAgICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbixcbiAqICAgIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsXG4gKiAgICBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLFxuICogICAgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbiAqICAgIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIChpbmNsdWRpbmcgdGhlXG4gKiAgICBuZXh0IHBhcmFncmFwaCkgc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbFxuICogICAgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gKiAgICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAqICAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gKiAgICBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSU1xuICogICAgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4gKiAgICBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTlxuICogICAgQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogICAgU09GVFdBUkUuXG4gKiAgXG4gKi9cblxuaW1wb3J0IHsgQ29ubmVjdGlvbiB9IGZyb20gJ3dlc3RmaWVsZC1ydW50aW1lLWNvbW1vbidcbmNvbnN0IHsgdWludCwgdWludE9wdGlvbmFsLCBpbnQsIGludE9wdGlvbmFsLCBmaXhlZCwgXG5cdGZpeGVkT3B0aW9uYWwsIG9iamVjdCwgb2JqZWN0T3B0aW9uYWwsIG5ld09iamVjdCwgc3RyaW5nLCBcblx0c3RyaW5nT3B0aW9uYWwsIGFycmF5LCBhcnJheU9wdGlvbmFsLCBcblx0ZmlsZURlc2NyaXB0b3JPcHRpb25hbCwgZmlsZURlc2NyaXB0b3IsIFxuaCwgdSwgaSwgZiwgbywgbiwgcywgYSB9ID0gQ29ubmVjdGlvblxuaW1wb3J0IFByb3h5IGZyb20gJy4vUHJveHknXG5cbi8qKlxuICpcbiAqICAgICAgVGhlIHdsX3RvdWNoIGludGVyZmFjZSByZXByZXNlbnRzIGEgdG91Y2hzY3JlZW5cbiAqICAgICAgYXNzb2NpYXRlZCB3aXRoIGEgc2VhdC5cbiAqXG4gKiAgICAgIFRvdWNoIGludGVyYWN0aW9ucyBjYW4gY29uc2lzdCBvZiBvbmUgb3IgbW9yZSBjb250YWN0cy5cbiAqICAgICAgRm9yIGVhY2ggY29udGFjdCwgYSBzZXJpZXMgb2YgZXZlbnRzIGlzIGdlbmVyYXRlZCwgc3RhcnRpbmdcbiAqICAgICAgd2l0aCBhIGRvd24gZXZlbnQsIGZvbGxvd2VkIGJ5IHplcm8gb3IgbW9yZSBtb3Rpb24gZXZlbnRzLFxuICogICAgICBhbmQgZW5kaW5nIHdpdGggYW4gdXAgZXZlbnQuIEV2ZW50cyByZWxhdGluZyB0byB0aGUgc2FtZVxuICogICAgICBjb250YWN0IHBvaW50IGNhbiBiZSBpZGVudGlmaWVkIGJ5IHRoZSBJRCBvZiB0aGUgc2VxdWVuY2UuXG4gKiAgICBcbiAqL1xuY2xhc3MgV2xUb3VjaFByb3h5IGV4dGVuZHMgUHJveHkge1xuXG5cdC8qKlxuXHQgKiBAc2luY2UgM1xuXHQgKlxuXHQgKi9cblx0cmVsZWFzZSAoKSB7XG5cdFx0c3VwZXIuZGVzdHJveSgpXG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgMCwgW10pXG5cdH1cblxuXHQvKipcblx0ICogRG8gbm90IGNvbnN0cnVjdCBwcm94aWVzIGRpcmVjdGx5LiBJbnN0ZWFkIHVzZSBvbmUgb2YgdGhlIGZhY3RvcnkgbWV0aG9kcyBmcm9tIG90aGVyIHByb3hpZXMuXG5cdCAqQHBhcmFtIHtEaXNwbGF5fWRpc3BsYXlcblx0ICpAcGFyYW0ge0Nvbm5lY3Rpb259Y29ubmVjdGlvblxuXHQgKkBwYXJhbSB7bnVtYmVyfWlkXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciAoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpIHtcblx0XHRzdXBlcihkaXNwbGF5LCBjb25uZWN0aW9uLCBpZClcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7V2xUb3VjaEV2ZW50c3xudWxsfVxuXHRcdCAqL1xuXHRcdHRoaXMubGlzdGVuZXIgPSBudWxsXG5cdH1cblxuXHRhc3luYyBbMF0gKG1lc3NhZ2UpIHtcblx0XHRhd2FpdCB0aGlzLmxpc3RlbmVyLmRvd24odShtZXNzYWdlKSwgdShtZXNzYWdlKSwgbyhtZXNzYWdlLCBmYWxzZSwgdGhpcy5fY29ubmVjdGlvbiksIGkobWVzc2FnZSksIGYobWVzc2FnZSksIGYobWVzc2FnZSkpXG5cdH1cblxuXHRhc3luYyBbMV0gKG1lc3NhZ2UpIHtcblx0XHRhd2FpdCB0aGlzLmxpc3RlbmVyLnVwKHUobWVzc2FnZSksIHUobWVzc2FnZSksIGkobWVzc2FnZSkpXG5cdH1cblxuXHRhc3luYyBbMl0gKG1lc3NhZ2UpIHtcblx0XHRhd2FpdCB0aGlzLmxpc3RlbmVyLm1vdGlvbih1KG1lc3NhZ2UpLCBpKG1lc3NhZ2UpLCBmKG1lc3NhZ2UpLCBmKG1lc3NhZ2UpKVxuXHR9XG5cblx0YXN5bmMgWzNdIChtZXNzYWdlKSB7XG5cdFx0YXdhaXQgdGhpcy5saXN0ZW5lci5mcmFtZSgpXG5cdH1cblxuXHRhc3luYyBbNF0gKG1lc3NhZ2UpIHtcblx0XHRhd2FpdCB0aGlzLmxpc3RlbmVyLmNhbmNlbCgpXG5cdH1cblxuXHRhc3luYyBbNV0gKG1lc3NhZ2UpIHtcblx0XHRhd2FpdCB0aGlzLmxpc3RlbmVyLnNoYXBlKGkobWVzc2FnZSksIGYobWVzc2FnZSksIGYobWVzc2FnZSkpXG5cdH1cblxuXHRhc3luYyBbNl0gKG1lc3NhZ2UpIHtcblx0XHRhd2FpdCB0aGlzLmxpc3RlbmVyLm9yaWVudGF0aW9uKGkobWVzc2FnZSksIGYobWVzc2FnZSkpXG5cdH1cblxufVxuV2xUb3VjaFByb3h5LnByb3RvY29sTmFtZSA9ICd3bF90b3VjaCdcblxuZXhwb3J0IGRlZmF1bHQgV2xUb3VjaFByb3h5XG4iLCIvKlxuICpcbiAqICAgIENvcHlyaWdodCDCqSAyMDA4LTIwMTMgS3Jpc3RpYW4gSMO4Z3NiZXJnXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMyAgICAgIFJhZmFlbCBBbnRvZ25vbGxpXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMyAgICAgIEphc3BlciBTdC4gUGllcnJlXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMC0yMDEzIEludGVsIENvcnBvcmF0aW9uXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxNS0yMDE3IFNhbXN1bmcgRWxlY3Ryb25pY3MgQ28uLCBMdGRcbiAqICAgIENvcHlyaWdodCDCqSAyMDE1LTIwMTcgUmVkIEhhdCBJbmMuXG4gKlxuICogICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqICAgIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqICAgIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqICAgIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogICAgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiAgICBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIChpbmNsdWRpbmcgdGhlIG5leHRcbiAqICAgIHBhcmFncmFwaCkgc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGVcbiAqICAgIFNvZnR3YXJlLlxuICpcbiAqICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqICAgIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogICAgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiAgICBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogICAgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqICAgIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqICAgIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqICBcbiAqL1xuXG4vKipcbiAqIEBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgWGRnUG9wdXBFdmVudHMge1xuXG5cdC8qKlxuXHQgKlxuXHQgKlx0VGhpcyBldmVudCBhc2tzIHRoZSBwb3B1cCBzdXJmYWNlIHRvIGNvbmZpZ3VyZSBpdHNlbGYgZ2l2ZW4gdGhlXG5cdCAqXHRjb25maWd1cmF0aW9uLiBUaGUgY29uZmlndXJlZCBzdGF0ZSBzaG91bGQgbm90IGJlIGFwcGxpZWQgaW1tZWRpYXRlbHkuXG5cdCAqXHRTZWUgeGRnX3N1cmZhY2UuY29uZmlndXJlIGZvciBkZXRhaWxzLlxuXHQgKlxuXHQgKlx0VGhlIHggYW5kIHkgYXJndW1lbnRzIHJlcHJlc2VudCB0aGUgcG9zaXRpb24gdGhlIHBvcHVwIHdhcyBwbGFjZWQgYXRcblx0ICpcdGdpdmVuIHRoZSB4ZGdfcG9zaXRpb25lciBydWxlLCByZWxhdGl2ZSB0byB0aGUgdXBwZXIgbGVmdCBjb3JuZXIgb2YgdGhlXG5cdCAqXHR3aW5kb3cgZ2VvbWV0cnkgb2YgdGhlIHBhcmVudCBzdXJmYWNlLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0geCB4IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHBhcmVudCBzdXJmYWNlIHdpbmRvdyBnZW9tZXRyeSBcblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgeSBwb3NpdGlvbiByZWxhdGl2ZSB0byBwYXJlbnQgc3VyZmFjZSB3aW5kb3cgZ2VvbWV0cnkgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCB3aW5kb3cgZ2VvbWV0cnkgd2lkdGggXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgd2luZG93IGdlb21ldHJ5IGhlaWdodCBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdGNvbmZpZ3VyZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0VGhlIHBvcHVwX2RvbmUgZXZlbnQgaXMgc2VudCBvdXQgd2hlbiBhIHBvcHVwIGlzIGRpc21pc3NlZCBieSB0aGVcblx0ICpcdGNvbXBvc2l0b3IuIFRoZSBjbGllbnQgc2hvdWxkIGRlc3Ryb3kgdGhlIHhkZ19wb3B1cCBvYmplY3QgYXQgdGhpc1xuXHQgKlx0cG9pbnQuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRwb3B1cERvbmUoKSB7fVxufVxuXG4iLCIvKlxuICpcbiAqICAgIENvcHlyaWdodCDCqSAyMDA4LTIwMTMgS3Jpc3RpYW4gSMO4Z3NiZXJnXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMyAgICAgIFJhZmFlbCBBbnRvZ25vbGxpXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMyAgICAgIEphc3BlciBTdC4gUGllcnJlXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMC0yMDEzIEludGVsIENvcnBvcmF0aW9uXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxNS0yMDE3IFNhbXN1bmcgRWxlY3Ryb25pY3MgQ28uLCBMdGRcbiAqICAgIENvcHlyaWdodCDCqSAyMDE1LTIwMTcgUmVkIEhhdCBJbmMuXG4gKlxuICogICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqICAgIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqICAgIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqICAgIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogICAgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiAgICBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIChpbmNsdWRpbmcgdGhlIG5leHRcbiAqICAgIHBhcmFncmFwaCkgc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGVcbiAqICAgIFNvZnR3YXJlLlxuICpcbiAqICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqICAgIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogICAgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiAgICBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogICAgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqICAgIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqICAgIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqICBcbiAqL1xuXG5pbXBvcnQgeyBDb25uZWN0aW9uIH0gZnJvbSAnd2VzdGZpZWxkLXJ1bnRpbWUtY29tbW9uJ1xuY29uc3QgeyB1aW50LCB1aW50T3B0aW9uYWwsIGludCwgaW50T3B0aW9uYWwsIGZpeGVkLCBcblx0Zml4ZWRPcHRpb25hbCwgb2JqZWN0LCBvYmplY3RPcHRpb25hbCwgbmV3T2JqZWN0LCBzdHJpbmcsIFxuXHRzdHJpbmdPcHRpb25hbCwgYXJyYXksIGFycmF5T3B0aW9uYWwsIFxuXHRmaWxlRGVzY3JpcHRvck9wdGlvbmFsLCBmaWxlRGVzY3JpcHRvciwgXG5oLCB1LCBpLCBmLCBvLCBuLCBzLCBhIH0gPSBDb25uZWN0aW9uXG5pbXBvcnQgUHJveHkgZnJvbSAnLi9Qcm94eSdcblxuLyoqXG4gKlxuICogICAgICBBIHBvcHVwIHN1cmZhY2UgaXMgYSBzaG9ydC1saXZlZCwgdGVtcG9yYXJ5IHN1cmZhY2UuIEl0IGNhbiBiZSB1c2VkIHRvXG4gKiAgICAgIGltcGxlbWVudCBmb3IgZXhhbXBsZSBtZW51cywgcG9wb3ZlcnMsIHRvb2x0aXBzIGFuZCBvdGhlciBzaW1pbGFyIHVzZXJcbiAqICAgICAgaW50ZXJmYWNlIGNvbmNlcHRzLlxuICpcbiAqICAgICAgQSBwb3B1cCBjYW4gYmUgbWFkZSB0byB0YWtlIGFuIGV4cGxpY2l0IGdyYWIuIFNlZSB4ZGdfcG9wdXAuZ3JhYiBmb3JcbiAqICAgICAgZGV0YWlscy5cbiAqXG4gKiAgICAgIFdoZW4gdGhlIHBvcHVwIGlzIGRpc21pc3NlZCwgYSBwb3B1cF9kb25lIGV2ZW50IHdpbGwgYmUgc2VudCBvdXQsIGFuZCBhdFxuICogICAgICB0aGUgc2FtZSB0aW1lIHRoZSBzdXJmYWNlIHdpbGwgYmUgdW5tYXBwZWQuIFNlZSB0aGUgeGRnX3BvcHVwLnBvcHVwX2RvbmVcbiAqICAgICAgZXZlbnQgZm9yIGRldGFpbHMuXG4gKlxuICogICAgICBFeHBsaWNpdGx5IGRlc3Ryb3lpbmcgdGhlIHhkZ19wb3B1cCBvYmplY3Qgd2lsbCBhbHNvIGRpc21pc3MgdGhlIHBvcHVwIGFuZFxuICogICAgICB1bm1hcCB0aGUgc3VyZmFjZS4gQ2xpZW50cyB0aGF0IHdhbnQgdG8gZGlzbWlzcyB0aGUgcG9wdXAgd2hlbiBhbm90aGVyXG4gKiAgICAgIHN1cmZhY2Ugb2YgdGhlaXIgb3duIGlzIGNsaWNrZWQgc2hvdWxkIGRpc21pc3MgdGhlIHBvcHVwIHVzaW5nIHRoZSBkZXN0cm95XG4gKiAgICAgIHJlcXVlc3QuXG4gKlxuICogICAgICBUaGUgcGFyZW50IHN1cmZhY2UgbXVzdCBoYXZlIGVpdGhlciB0aGUgeGRnX3RvcGxldmVsIG9yIHhkZ19wb3B1cCBzdXJmYWNlXG4gKiAgICAgIHJvbGUuXG4gKlxuICogICAgICBBIG5ld2x5IGNyZWF0ZWQgeGRnX3BvcHVwIHdpbGwgYmUgc3RhY2tlZCBvbiB0b3Agb2YgYWxsIHByZXZpb3VzbHkgY3JlYXRlZFxuICogICAgICB4ZGdfcG9wdXAgc3VyZmFjZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBzYW1lIHhkZ190b3BsZXZlbC5cbiAqXG4gKiAgICAgIFRoZSBwYXJlbnQgb2YgYW4geGRnX3BvcHVwIG11c3QgYmUgbWFwcGVkIChzZWUgdGhlIHhkZ19zdXJmYWNlXG4gKiAgICAgIGRlc2NyaXB0aW9uKSBiZWZvcmUgdGhlIHhkZ19wb3B1cCBpdHNlbGYuXG4gKlxuICogICAgICBUaGUgeCBhbmQgeSBhcmd1bWVudHMgcGFzc2VkIHdoZW4gY3JlYXRpbmcgdGhlIHBvcHVwIG9iamVjdCBzcGVjaWZ5XG4gKiAgICAgIHdoZXJlIHRoZSB0b3AgbGVmdCBvZiB0aGUgcG9wdXAgc2hvdWxkIGJlIHBsYWNlZCwgcmVsYXRpdmUgdG8gdGhlXG4gKiAgICAgIGxvY2FsIHN1cmZhY2UgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudCBzdXJmYWNlLiBTZWVcbiAqICAgICAgeGRnX3N1cmZhY2UuZ2V0X3BvcHVwLiBBbiB4ZGdfcG9wdXAgbXVzdCBpbnRlcnNlY3Qgd2l0aCBvciBiZSBhdCBsZWFzdFxuICogICAgICBwYXJ0aWFsbHkgYWRqYWNlbnQgdG8gaXRzIHBhcmVudCBzdXJmYWNlLlxuICpcbiAqICAgICAgVGhlIGNsaWVudCBtdXN0IGNhbGwgd2xfc3VyZmFjZS5jb21taXQgb24gdGhlIGNvcnJlc3BvbmRpbmcgd2xfc3VyZmFjZVxuICogICAgICBmb3IgdGhlIHhkZ19wb3B1cCBzdGF0ZSB0byB0YWtlIGVmZmVjdC5cbiAqICAgIFxuICovXG5jbGFzcyBYZGdQb3B1cFByb3h5IGV4dGVuZHMgUHJveHkge1xuXG5cdC8qKlxuXHQgKlxuXHQgKlx0VGhpcyBkZXN0cm95cyB0aGUgcG9wdXAuIEV4cGxpY2l0bHkgZGVzdHJveWluZyB0aGUgeGRnX3BvcHVwXG5cdCAqXHRvYmplY3Qgd2lsbCBhbHNvIGRpc21pc3MgdGhlIHBvcHVwLCBhbmQgdW5tYXAgdGhlIHN1cmZhY2UuXG5cdCAqXG5cdCAqXHRJZiB0aGlzIHhkZ19wb3B1cCBpcyBub3QgdGhlIFwidG9wbW9zdFwiIHBvcHVwLCBhIHByb3RvY29sIGVycm9yXG5cdCAqXHR3aWxsIGJlIHNlbnQuXG5cdCAqICAgICAgXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRkZXN0cm95ICgpIHtcblx0XHRzdXBlci5kZXN0cm95KClcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCAwLCBbXSlcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0VGhpcyByZXF1ZXN0IG1ha2VzIHRoZSBjcmVhdGVkIHBvcHVwIHRha2UgYW4gZXhwbGljaXQgZ3JhYi4gQW4gZXhwbGljaXRcblx0ICpcdGdyYWIgd2lsbCBiZSBkaXNtaXNzZWQgd2hlbiB0aGUgdXNlciBkaXNtaXNzZXMgdGhlIHBvcHVwLCBvciB3aGVuIHRoZVxuXHQgKlx0Y2xpZW50IGRlc3Ryb3lzIHRoZSB4ZGdfcG9wdXAuIFRoaXMgY2FuIGJlIGRvbmUgYnkgdGhlIHVzZXIgY2xpY2tpbmdcblx0ICpcdG91dHNpZGUgdGhlIHN1cmZhY2UsIHVzaW5nIHRoZSBrZXlib2FyZCwgb3IgZXZlbiBsb2NraW5nIHRoZSBzY3JlZW5cblx0ICpcdHRocm91Z2ggY2xvc2luZyB0aGUgbGlkIG9yIGEgdGltZW91dC5cblx0ICpcblx0ICpcdElmIHRoZSBjb21wb3NpdG9yIGRlbmllcyB0aGUgZ3JhYiwgdGhlIHBvcHVwIHdpbGwgYmUgaW1tZWRpYXRlbHlcblx0ICpcdGRpc21pc3NlZC5cblx0ICpcblx0ICpcdFRoaXMgcmVxdWVzdCBtdXN0IGJlIHVzZWQgaW4gcmVzcG9uc2UgdG8gc29tZSBzb3J0IG9mIHVzZXIgYWN0aW9uIGxpa2UgYVxuXHQgKlx0YnV0dG9uIHByZXNzLCBrZXkgcHJlc3MsIG9yIHRvdWNoIGRvd24gZXZlbnQuIFRoZSBzZXJpYWwgbnVtYmVyIG9mIHRoZVxuXHQgKlx0ZXZlbnQgc2hvdWxkIGJlIHBhc3NlZCBhcyAnc2VyaWFsJy5cblx0ICpcblx0ICpcdFRoZSBwYXJlbnQgb2YgYSBncmFiYmluZyBwb3B1cCBtdXN0IGVpdGhlciBiZSBhbiB4ZGdfdG9wbGV2ZWwgc3VyZmFjZSBvclxuXHQgKlx0YW5vdGhlciB4ZGdfcG9wdXAgd2l0aCBhbiBleHBsaWNpdCBncmFiLiBJZiB0aGUgcGFyZW50IGlzIGFub3RoZXJcblx0ICpcdHhkZ19wb3B1cCBpdCBtZWFucyB0aGF0IHRoZSBwb3B1cHMgYXJlIG5lc3RlZCwgd2l0aCB0aGlzIHBvcHVwIG5vdyBiZWluZ1xuXHQgKlx0dGhlIHRvcG1vc3QgcG9wdXAuXG5cdCAqXG5cdCAqXHROZXN0ZWQgcG9wdXBzIG11c3QgYmUgZGVzdHJveWVkIGluIHRoZSByZXZlcnNlIG9yZGVyIHRoZXkgd2VyZSBjcmVhdGVkXG5cdCAqXHRpbiwgZS5nLiB0aGUgb25seSBwb3B1cCB5b3UgYXJlIGFsbG93ZWQgdG8gZGVzdHJveSBhdCBhbGwgdGltZXMgaXMgdGhlXG5cdCAqXHR0b3Btb3N0IG9uZS5cblx0ICpcblx0ICpcdFdoZW4gY29tcG9zaXRvcnMgY2hvb3NlIHRvIGRpc21pc3MgYSBwb3B1cCwgdGhleSBtYXkgZGlzbWlzcyBldmVyeVxuXHQgKlx0bmVzdGVkIGdyYWJiaW5nIHBvcHVwIGFzIHdlbGwuIFdoZW4gYSBjb21wb3NpdG9yIGRpc21pc3NlcyBwb3B1cHMsIGl0XG5cdCAqXHR3aWxsIGZvbGxvdyB0aGUgc2FtZSBkaXNtaXNzaW5nIG9yZGVyIGFzIHJlcXVpcmVkIGZyb20gdGhlIGNsaWVudC5cblx0ICpcblx0ICpcdFRoZSBwYXJlbnQgb2YgYSBncmFiYmluZyBwb3B1cCBtdXN0IGVpdGhlciBiZSBhbm90aGVyIHhkZ19wb3B1cCB3aXRoIGFuXG5cdCAqXHRhY3RpdmUgZXhwbGljaXQgZ3JhYiwgb3IgYW4geGRnX3BvcHVwIG9yIHhkZ190b3BsZXZlbCwgaWYgdGhlcmUgYXJlIG5vXG5cdCAqXHRleHBsaWNpdCBncmFicyBhbHJlYWR5IHRha2VuLlxuXHQgKlxuXHQgKlx0SWYgdGhlIHRvcG1vc3QgZ3JhYmJpbmcgcG9wdXAgaXMgZGVzdHJveWVkLCB0aGUgZ3JhYiB3aWxsIGJlIHJldHVybmVkIHRvXG5cdCAqXHR0aGUgcGFyZW50IG9mIHRoZSBwb3B1cCwgaWYgdGhhdCBwYXJlbnQgcHJldmlvdXNseSBoYWQgYW4gZXhwbGljaXQgZ3JhYi5cblx0ICpcblx0ICpcdElmIHRoZSBwYXJlbnQgaXMgYSBncmFiYmluZyBwb3B1cCB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGRpc21pc3NlZCwgdGhpc1xuXHQgKlx0cG9wdXAgd2lsbCBiZSBpbW1lZGlhdGVseSBkaXNtaXNzZWQuIElmIHRoZSBwYXJlbnQgaXMgYSBwb3B1cCB0aGF0IGRpZFxuXHQgKlx0bm90IHRha2UgYW4gZXhwbGljaXQgZ3JhYiwgYW4gZXJyb3Igd2lsbCBiZSByYWlzZWQuXG5cdCAqXG5cdCAqXHREdXJpbmcgYSBwb3B1cCBncmFiLCB0aGUgY2xpZW50IG93bmluZyB0aGUgZ3JhYiB3aWxsIHJlY2VpdmUgcG9pbnRlclxuXHQgKlx0YW5kIHRvdWNoIGV2ZW50cyBmb3IgYWxsIHRoZWlyIHN1cmZhY2VzIGFzIG5vcm1hbCAoc2ltaWxhciB0byBhblxuXHQgKlx0XCJvd25lci1ldmVudHNcIiBncmFiIGluIFgxMSBwYXJsYW5jZSksIHdoaWxlIHRoZSB0b3AgbW9zdCBncmFiYmluZyBwb3B1cFxuXHQgKlx0d2lsbCBhbHdheXMgaGF2ZSBrZXlib2FyZCBmb2N1cy5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHsqfSBzZWF0IHRoZSB3bF9zZWF0IG9mIHRoZSB1c2VyIGV2ZW50IFxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2VyaWFsIHRoZSBzZXJpYWwgb2YgdGhlIHVzZXIgZXZlbnQgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRncmFiIChzZWF0LCBzZXJpYWwpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCAxLCBbb2JqZWN0KHNlYXQpLCB1aW50KHNlcmlhbCldKVxuXHR9XG5cblx0LyoqXG5cdCAqIERvIG5vdCBjb25zdHJ1Y3QgcHJveGllcyBkaXJlY3RseS4gSW5zdGVhZCB1c2Ugb25lIG9mIHRoZSBmYWN0b3J5IG1ldGhvZHMgZnJvbSBvdGhlciBwcm94aWVzLlxuXHQgKkBwYXJhbSB7RGlzcGxheX1kaXNwbGF5XG5cdCAqQHBhcmFtIHtDb25uZWN0aW9ufWNvbm5lY3Rpb25cblx0ICpAcGFyYW0ge251bWJlcn1pZFxuXHQgKi9cblx0Y29uc3RydWN0b3IgKGRpc3BsYXksIGNvbm5lY3Rpb24sIGlkKSB7XG5cdFx0c3VwZXIoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge1hkZ1BvcHVwRXZlbnRzfG51bGx9XG5cdFx0ICovXG5cdFx0dGhpcy5saXN0ZW5lciA9IG51bGxcblx0fVxuXG5cdGFzeW5jIFswXSAobWVzc2FnZSkge1xuXHRcdGF3YWl0IHRoaXMubGlzdGVuZXIuY29uZmlndXJlKGkobWVzc2FnZSksIGkobWVzc2FnZSksIGkobWVzc2FnZSksIGkobWVzc2FnZSkpXG5cdH1cblxuXHRhc3luYyBbMV0gKG1lc3NhZ2UpIHtcblx0XHRhd2FpdCB0aGlzLmxpc3RlbmVyLnBvcHVwRG9uZSgpXG5cdH1cblxufVxuWGRnUG9wdXBQcm94eS5wcm90b2NvbE5hbWUgPSAneGRnX3BvcHVwJ1xuXG5YZGdQb3B1cFByb3h5LkVycm9yID0ge1xuICAvKipcbiAgICogdHJpZWQgdG8gZ3JhYiBhZnRlciBiZWluZyBtYXBwZWRcbiAgICovXG4gIGludmFsaWRHcmFiOiAwXG59XG5cbmV4cG9ydCBkZWZhdWx0IFhkZ1BvcHVwUHJveHlcbiIsIi8qXG4gKlxuICogICAgQ29weXJpZ2h0IMKpIDIwMDgtMjAxMyBLcmlzdGlhbiBIw7hnc2JlcmdcbiAqICAgIENvcHlyaWdodCDCqSAyMDEzICAgICAgUmFmYWVsIEFudG9nbm9sbGlcbiAqICAgIENvcHlyaWdodCDCqSAyMDEzICAgICAgSmFzcGVyIFN0LiBQaWVycmVcbiAqICAgIENvcHlyaWdodCDCqSAyMDEwLTIwMTMgSW50ZWwgQ29ycG9yYXRpb25cbiAqICAgIENvcHlyaWdodCDCqSAyMDE1LTIwMTcgU2Ftc3VuZyBFbGVjdHJvbmljcyBDby4sIEx0ZFxuICogICAgQ29weXJpZ2h0IMKpIDIwMTUtMjAxNyBSZWQgSGF0IEluYy5cbiAqXG4gKiAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogICAgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogICAgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogICAgdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiAgICBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqICAgIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgKGluY2x1ZGluZyB0aGUgbmV4dFxuICogICAgcGFyYWdyYXBoKSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZVxuICogICAgU29mdHdhcmUuXG4gKlxuICogICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogICAgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiAgICBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTExcbiAqICAgIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiAgICBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogICAgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogICAgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICogIFxuICovXG5cbmltcG9ydCB7IENvbm5lY3Rpb24gfSBmcm9tICd3ZXN0ZmllbGQtcnVudGltZS1jb21tb24nXG5jb25zdCB7IHVpbnQsIHVpbnRPcHRpb25hbCwgaW50LCBpbnRPcHRpb25hbCwgZml4ZWQsIFxuXHRmaXhlZE9wdGlvbmFsLCBvYmplY3QsIG9iamVjdE9wdGlvbmFsLCBuZXdPYmplY3QsIHN0cmluZywgXG5cdHN0cmluZ09wdGlvbmFsLCBhcnJheSwgYXJyYXlPcHRpb25hbCwgXG5cdGZpbGVEZXNjcmlwdG9yT3B0aW9uYWwsIGZpbGVEZXNjcmlwdG9yLCBcbmgsIHUsIGksIGYsIG8sIG4sIHMsIGEgfSA9IENvbm5lY3Rpb25cbmltcG9ydCBQcm94eSBmcm9tICcuL1Byb3h5J1xuXG4vKipcbiAqXG4gKiAgICAgIFRoZSB4ZGdfcG9zaXRpb25lciBwcm92aWRlcyBhIGNvbGxlY3Rpb24gb2YgcnVsZXMgZm9yIHRoZSBwbGFjZW1lbnQgb2YgYVxuICogICAgICBjaGlsZCBzdXJmYWNlIHJlbGF0aXZlIHRvIGEgcGFyZW50IHN1cmZhY2UuIFJ1bGVzIGNhbiBiZSBkZWZpbmVkIHRvIGVuc3VyZVxuICogICAgICB0aGUgY2hpbGQgc3VyZmFjZSByZW1haW5zIHdpdGhpbiB0aGUgdmlzaWJsZSBhcmVhJ3MgYm9yZGVycywgYW5kIHRvXG4gKiAgICAgIHNwZWNpZnkgaG93IHRoZSBjaGlsZCBzdXJmYWNlIGNoYW5nZXMgaXRzIHBvc2l0aW9uLCBzdWNoIGFzIHNsaWRpbmcgYWxvbmdcbiAqICAgICAgYW4gYXhpcywgb3IgZmxpcHBpbmcgYXJvdW5kIGEgcmVjdGFuZ2xlLiBUaGVzZSBwb3NpdGlvbmVyLWNyZWF0ZWQgcnVsZXMgYXJlXG4gKiAgICAgIGNvbnN0cmFpbmVkIGJ5IHRoZSByZXF1aXJlbWVudCB0aGF0IGEgY2hpbGQgc3VyZmFjZSBtdXN0IGludGVyc2VjdCB3aXRoIG9yXG4gKiAgICAgIGJlIGF0IGxlYXN0IHBhcnRpYWxseSBhZGphY2VudCB0byBpdHMgcGFyZW50IHN1cmZhY2UuXG4gKlxuICogICAgICBTZWUgdGhlIHZhcmlvdXMgcmVxdWVzdHMgZm9yIGRldGFpbHMgYWJvdXQgcG9zc2libGUgcnVsZXMuXG4gKlxuICogICAgICBBdCB0aGUgdGltZSBvZiB0aGUgcmVxdWVzdCwgdGhlIGNvbXBvc2l0b3IgbWFrZXMgYSBjb3B5IG9mIHRoZSBydWxlc1xuICogICAgICBzcGVjaWZpZWQgYnkgdGhlIHhkZ19wb3NpdGlvbmVyLiBUaHVzLCBhZnRlciB0aGUgcmVxdWVzdCBpcyBjb21wbGV0ZSB0aGVcbiAqICAgICAgeGRnX3Bvc2l0aW9uZXIgb2JqZWN0IGNhbiBiZSBkZXN0cm95ZWQgb3IgcmV1c2VkOyBmdXJ0aGVyIGNoYW5nZXMgdG8gdGhlXG4gKiAgICAgIG9iamVjdCB3aWxsIGhhdmUgbm8gZWZmZWN0IG9uIHByZXZpb3VzIHVzYWdlcy5cbiAqXG4gKiAgICAgIEZvciBhbiB4ZGdfcG9zaXRpb25lciBvYmplY3QgdG8gYmUgY29uc2lkZXJlZCBjb21wbGV0ZSwgaXQgbXVzdCBoYXZlIGFcbiAqICAgICAgbm9uLXplcm8gc2l6ZSBzZXQgYnkgc2V0X3NpemUsIGFuZCBhIG5vbi16ZXJvIGFuY2hvciByZWN0YW5nbGUgc2V0IGJ5XG4gKiAgICAgIHNldF9hbmNob3JfcmVjdC4gUGFzc2luZyBhbiBpbmNvbXBsZXRlIHhkZ19wb3NpdGlvbmVyIG9iamVjdCB3aGVuXG4gKiAgICAgIHBvc2l0aW9uaW5nIGEgc3VyZmFjZSByYWlzZXMgYW4gZXJyb3IuXG4gKiAgICBcbiAqL1xuY2xhc3MgWGRnUG9zaXRpb25lclByb3h5IGV4dGVuZHMgUHJveHkge1xuXG5cdC8qKlxuXHQgKlxuXHQgKlx0Tm90aWZ5IHRoZSBjb21wb3NpdG9yIHRoYXQgdGhlIHhkZ19wb3NpdGlvbmVyIHdpbGwgbm8gbG9uZ2VyIGJlIHVzZWQuXG5cdCAqICAgICAgXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRkZXN0cm95ICgpIHtcblx0XHRzdXBlci5kZXN0cm95KClcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCAwLCBbXSlcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0U2V0IHRoZSBzaXplIG9mIHRoZSBzdXJmYWNlIHRoYXQgaXMgdG8gYmUgcG9zaXRpb25lZCB3aXRoIHRoZSBwb3NpdGlvbmVyXG5cdCAqXHRvYmplY3QuIFRoZSBzaXplIGlzIGluIHN1cmZhY2UtbG9jYWwgY29vcmRpbmF0ZXMgYW5kIGNvcnJlc3BvbmRzIHRvIHRoZVxuXHQgKlx0d2luZG93IGdlb21ldHJ5LiBTZWUgeGRnX3N1cmZhY2Uuc2V0X3dpbmRvd19nZW9tZXRyeS5cblx0ICpcblx0ICpcdElmIGEgemVybyBvciBuZWdhdGl2ZSBzaXplIGlzIHNldCB0aGUgaW52YWxpZF9pbnB1dCBlcnJvciBpcyByYWlzZWQuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCB3aWR0aCBvZiBwb3NpdGlvbmVkIHJlY3RhbmdsZSBcblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBoZWlnaHQgb2YgcG9zaXRpb25lZCByZWN0YW5nbGUgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRzZXRTaXplICh3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgMSwgW2ludCh3aWR0aCksIGludChoZWlnaHQpXSlcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0U3BlY2lmeSB0aGUgYW5jaG9yIHJlY3RhbmdsZSB3aXRoaW4gdGhlIHBhcmVudCBzdXJmYWNlIHRoYXQgdGhlIGNoaWxkXG5cdCAqXHRzdXJmYWNlIHdpbGwgYmUgcGxhY2VkIHJlbGF0aXZlIHRvLiBUaGUgcmVjdGFuZ2xlIGlzIHJlbGF0aXZlIHRvIHRoZVxuXHQgKlx0d2luZG93IGdlb21ldHJ5IGFzIGRlZmluZWQgYnkgeGRnX3N1cmZhY2Uuc2V0X3dpbmRvd19nZW9tZXRyeSBvZiB0aGVcblx0ICpcdHBhcmVudCBzdXJmYWNlLlxuXHQgKlxuXHQgKlx0V2hlbiB0aGUgeGRnX3Bvc2l0aW9uZXIgb2JqZWN0IGlzIHVzZWQgdG8gcG9zaXRpb24gYSBjaGlsZCBzdXJmYWNlLCB0aGVcblx0ICpcdGFuY2hvciByZWN0YW5nbGUgbWF5IG5vdCBleHRlbmQgb3V0c2lkZSB0aGUgd2luZG93IGdlb21ldHJ5IG9mIHRoZVxuXHQgKlx0cG9zaXRpb25lZCBjaGlsZCdzIHBhcmVudCBzdXJmYWNlLlxuXHQgKlxuXHQgKlx0SWYgYSBuZWdhdGl2ZSBzaXplIGlzIHNldCB0aGUgaW52YWxpZF9pbnB1dCBlcnJvciBpcyByYWlzZWQuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IHggcG9zaXRpb24gb2YgYW5jaG9yIHJlY3RhbmdsZSBcblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgeSBwb3NpdGlvbiBvZiBhbmNob3IgcmVjdGFuZ2xlIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggd2lkdGggb2YgYW5jaG9yIHJlY3RhbmdsZSBcblx0ICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBoZWlnaHQgb2YgYW5jaG9yIHJlY3RhbmdsZSBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdHNldEFuY2hvclJlY3QgKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCAyLCBbaW50KHgpLCBpbnQoeSksIGludCh3aWR0aCksIGludChoZWlnaHQpXSlcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0RGVmaW5lcyB0aGUgYW5jaG9yIHBvaW50IGZvciB0aGUgYW5jaG9yIHJlY3RhbmdsZS4gVGhlIHNwZWNpZmllZCBhbmNob3Jcblx0ICpcdGlzIHVzZWQgZGVyaXZlIGFuIGFuY2hvciBwb2ludCB0aGF0IHRoZSBjaGlsZCBzdXJmYWNlIHdpbGwgYmVcblx0ICpcdHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8uIElmIGEgY29ybmVyIGFuY2hvciBpcyBzZXQgKGUuZy4gJ3RvcF9sZWZ0JyBvclxuXHQgKlx0J2JvdHRvbV9yaWdodCcpLCB0aGUgYW5jaG9yIHBvaW50IHdpbGwgYmUgYXQgdGhlIHNwZWNpZmllZCBjb3JuZXI7XG5cdCAqXHRvdGhlcndpc2UsIHRoZSBkZXJpdmVkIGFuY2hvciBwb2ludCB3aWxsIGJlIGNlbnRlcmVkIG9uIHRoZSBzcGVjaWZpZWRcblx0ICpcdGVkZ2UsIG9yIGluIHRoZSBjZW50ZXIgb2YgdGhlIGFuY2hvciByZWN0YW5nbGUgaWYgbm8gZWRnZSBpcyBzcGVjaWZpZWQuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBhbmNob3IgYW5jaG9yIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0c2V0QW5jaG9yIChhbmNob3IpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCAzLCBbdWludChhbmNob3IpXSlcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0RGVmaW5lcyBpbiB3aGF0IGRpcmVjdGlvbiBhIHN1cmZhY2Ugc2hvdWxkIGJlIHBvc2l0aW9uZWQsIHJlbGF0aXZlIHRvXG5cdCAqXHR0aGUgYW5jaG9yIHBvaW50IG9mIHRoZSBwYXJlbnQgc3VyZmFjZS4gSWYgYSBjb3JuZXIgZ3Jhdml0eSBpc1xuXHQgKlx0c3BlY2lmaWVkIChlLmcuICdib3R0b21fcmlnaHQnIG9yICd0b3BfbGVmdCcpLCB0aGVuIHRoZSBjaGlsZCBzdXJmYWNlXG5cdCAqXHR3aWxsIGJlIHBsYWNlZCB0b3dhcmRzIHRoZSBzcGVjaWZpZWQgZ3Jhdml0eTsgb3RoZXJ3aXNlLCB0aGUgY2hpbGRcblx0ICpcdHN1cmZhY2Ugd2lsbCBiZSBjZW50ZXJlZCBvdmVyIHRoZSBhbmNob3IgcG9pbnQgb24gYW55IGF4aXMgdGhhdCBoYWQgbm9cblx0ICpcdGdyYXZpdHkgc3BlY2lmaWVkLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gZ3Jhdml0eSBncmF2aXR5IGRpcmVjdGlvbiBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdHNldEdyYXZpdHkgKGdyYXZpdHkpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCA0LCBbdWludChncmF2aXR5KV0pXG5cdH1cblxuXHQvKipcblx0ICpcblx0ICpcdFNwZWNpZnkgaG93IHRoZSB3aW5kb3cgc2hvdWxkIGJlIHBvc2l0aW9uZWQgaWYgdGhlIG9yaWdpbmFsbHkgaW50ZW5kZWRcblx0ICpcdHBvc2l0aW9uIGNhdXNlZCB0aGUgc3VyZmFjZSB0byBiZSBjb25zdHJhaW5lZCwgbWVhbmluZyBhdCBsZWFzdFxuXHQgKlx0cGFydGlhbGx5IG91dHNpZGUgcG9zaXRpb25pbmcgYm91bmRhcmllcyBzZXQgYnkgdGhlIGNvbXBvc2l0b3IuIFRoZVxuXHQgKlx0YWRqdXN0bWVudCBpcyBzZXQgYnkgY29uc3RydWN0aW5nIGEgYml0bWFzayBkZXNjcmliaW5nIHRoZSBhZGp1c3RtZW50IHRvXG5cdCAqXHRiZSBtYWRlIHdoZW4gdGhlIHN1cmZhY2UgaXMgY29uc3RyYWluZWQgb24gdGhhdCBheGlzLlxuXHQgKlxuXHQgKlx0SWYgbm8gYml0IGZvciBvbmUgYXhpcyBpcyBzZXQsIHRoZSBjb21wb3NpdG9yIHdpbGwgYXNzdW1lIHRoYXQgdGhlIGNoaWxkXG5cdCAqXHRzdXJmYWNlIHNob3VsZCBub3QgY2hhbmdlIGl0cyBwb3NpdGlvbiBvbiB0aGF0IGF4aXMgd2hlbiBjb25zdHJhaW5lZC5cblx0ICpcblx0ICpcdElmIG1vcmUgdGhhbiBvbmUgYml0IGZvciBvbmUgYXhpcyBpcyBzZXQsIHRoZSBvcmRlciBvZiBob3cgYWRqdXN0bWVudHNcblx0ICpcdGFyZSBhcHBsaWVkIGlzIHNwZWNpZmllZCBpbiB0aGUgY29ycmVzcG9uZGluZyBhZGp1c3RtZW50IGRlc2NyaXB0aW9ucy5cblx0ICpcblx0ICpcdFRoZSBkZWZhdWx0IGFkanVzdG1lbnQgaXMgbm9uZS5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IGNvbnN0cmFpbnRBZGp1c3RtZW50IGJpdCBtYXNrIG9mIGNvbnN0cmFpbnQgYWRqdXN0bWVudHMgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRzZXRDb25zdHJhaW50QWRqdXN0bWVudCAoY29uc3RyYWludEFkanVzdG1lbnQpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCA1LCBbdWludChjb25zdHJhaW50QWRqdXN0bWVudCldKVxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRTcGVjaWZ5IHRoZSBzdXJmYWNlIHBvc2l0aW9uIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgcG9zaXRpb24gb2YgdGhlXG5cdCAqXHRhbmNob3Igb24gdGhlIGFuY2hvciByZWN0YW5nbGUgYW5kIHRoZSBhbmNob3Igb24gdGhlIHN1cmZhY2UuIEZvclxuXHQgKlx0ZXhhbXBsZSBpZiB0aGUgYW5jaG9yIG9mIHRoZSBhbmNob3IgcmVjdGFuZ2xlIGlzIGF0ICh4LCB5KSwgdGhlIHN1cmZhY2Vcblx0ICpcdGhhcyB0aGUgZ3Jhdml0eSBib3R0b218cmlnaHQsIGFuZCB0aGUgb2Zmc2V0IGlzIChveCwgb3kpLCB0aGUgY2FsY3VsYXRlZFxuXHQgKlx0c3VyZmFjZSBwb3NpdGlvbiB3aWxsIGJlICh4ICsgb3gsIHkgKyBveSkuIFRoZSBvZmZzZXQgcG9zaXRpb24gb2YgdGhlXG5cdCAqXHRzdXJmYWNlIGlzIHRoZSBvbmUgdXNlZCBmb3IgY29uc3RyYWludCB0ZXN0aW5nLiBTZWVcblx0ICpcdHNldF9jb25zdHJhaW50X2FkanVzdG1lbnQuXG5cdCAqXG5cdCAqXHRBbiBleGFtcGxlIHVzZSBjYXNlIGlzIHBsYWNpbmcgYSBwb3B1cCBtZW51IG9uIHRvcCBvZiBhIHVzZXIgaW50ZXJmYWNlXG5cdCAqXHRlbGVtZW50LCB3aGlsZSBhbGlnbmluZyB0aGUgdXNlciBpbnRlcmZhY2UgZWxlbWVudCBvZiB0aGUgcGFyZW50IHN1cmZhY2Vcblx0ICpcdHdpdGggc29tZSB1c2VyIGludGVyZmFjZSBlbGVtZW50IHBsYWNlZCBzb21ld2hlcmUgaW4gdGhlIHBvcHVwIHN1cmZhY2UuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB4IHN1cmZhY2UgcG9zaXRpb24geCBvZmZzZXQgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB5IHN1cmZhY2UgcG9zaXRpb24geSBvZmZzZXQgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRzZXRPZmZzZXQgKHgsIHkpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCA2LCBbaW50KHgpLCBpbnQoeSldKVxuXHR9XG5cblx0LyoqXG5cdCAqIERvIG5vdCBjb25zdHJ1Y3QgcHJveGllcyBkaXJlY3RseS4gSW5zdGVhZCB1c2Ugb25lIG9mIHRoZSBmYWN0b3J5IG1ldGhvZHMgZnJvbSBvdGhlciBwcm94aWVzLlxuXHQgKkBwYXJhbSB7RGlzcGxheX1kaXNwbGF5XG5cdCAqQHBhcmFtIHtDb25uZWN0aW9ufWNvbm5lY3Rpb25cblx0ICpAcGFyYW0ge251bWJlcn1pZFxuXHQgKi9cblx0Y29uc3RydWN0b3IgKGRpc3BsYXksIGNvbm5lY3Rpb24sIGlkKSB7XG5cdFx0c3VwZXIoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge1hkZ1Bvc2l0aW9uZXJFdmVudHN8bnVsbH1cblx0XHQgKi9cblx0XHR0aGlzLmxpc3RlbmVyID0gbnVsbFxuXHR9XG5cbn1cblhkZ1Bvc2l0aW9uZXJQcm94eS5wcm90b2NvbE5hbWUgPSAneGRnX3Bvc2l0aW9uZXInXG5cblhkZ1Bvc2l0aW9uZXJQcm94eS5FcnJvciA9IHtcbiAgLyoqXG4gICAqIGludmFsaWQgaW5wdXQgcHJvdmlkZWRcbiAgICovXG4gIGludmFsaWRJbnB1dDogMFxufVxuXG5YZGdQb3NpdGlvbmVyUHJveHkuQW5jaG9yID0ge1xuICAvKipcbiAgICogXG4gICAqL1xuICBub25lOiAwLFxuICAvKipcbiAgICogXG4gICAqL1xuICB0b3A6IDEsXG4gIC8qKlxuICAgKiBcbiAgICovXG4gIGJvdHRvbTogMixcbiAgLyoqXG4gICAqIFxuICAgKi9cbiAgbGVmdDogMyxcbiAgLyoqXG4gICAqIFxuICAgKi9cbiAgcmlnaHQ6IDQsXG4gIC8qKlxuICAgKiBcbiAgICovXG4gIHRvcExlZnQ6IDUsXG4gIC8qKlxuICAgKiBcbiAgICovXG4gIGJvdHRvbUxlZnQ6IDYsXG4gIC8qKlxuICAgKiBcbiAgICovXG4gIHRvcFJpZ2h0OiA3LFxuICAvKipcbiAgICogXG4gICAqL1xuICBib3R0b21SaWdodDogOFxufVxuXG5YZGdQb3NpdGlvbmVyUHJveHkuR3Jhdml0eSA9IHtcbiAgLyoqXG4gICAqIFxuICAgKi9cbiAgbm9uZTogMCxcbiAgLyoqXG4gICAqIFxuICAgKi9cbiAgdG9wOiAxLFxuICAvKipcbiAgICogXG4gICAqL1xuICBib3R0b206IDIsXG4gIC8qKlxuICAgKiBcbiAgICovXG4gIGxlZnQ6IDMsXG4gIC8qKlxuICAgKiBcbiAgICovXG4gIHJpZ2h0OiA0LFxuICAvKipcbiAgICogXG4gICAqL1xuICB0b3BMZWZ0OiA1LFxuICAvKipcbiAgICogXG4gICAqL1xuICBib3R0b21MZWZ0OiA2LFxuICAvKipcbiAgICogXG4gICAqL1xuICB0b3BSaWdodDogNyxcbiAgLyoqXG4gICAqIFxuICAgKi9cbiAgYm90dG9tUmlnaHQ6IDhcbn1cblxuWGRnUG9zaXRpb25lclByb3h5LkNvbnN0cmFpbnRBZGp1c3RtZW50ID0ge1xuICAvKipcbiAgICogXG4gICAqL1xuICBub25lOiAwLFxuICAvKipcbiAgICogXG4gICAqL1xuICBzbGlkZVg6IDEsXG4gIC8qKlxuICAgKiBcbiAgICovXG4gIHNsaWRlWTogMixcbiAgLyoqXG4gICAqIFxuICAgKi9cbiAgZmxpcFg6IDQsXG4gIC8qKlxuICAgKiBcbiAgICovXG4gIGZsaXBZOiA4LFxuICAvKipcbiAgICogXG4gICAqL1xuICByZXNpemVYOiAxNixcbiAgLyoqXG4gICAqIFxuICAgKi9cbiAgcmVzaXplWTogMzJcbn1cblxuZXhwb3J0IGRlZmF1bHQgWGRnUG9zaXRpb25lclByb3h5XG4iLCIvKlxuICpcbiAqICAgIENvcHlyaWdodCDCqSAyMDA4LTIwMTMgS3Jpc3RpYW4gSMO4Z3NiZXJnXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMyAgICAgIFJhZmFlbCBBbnRvZ25vbGxpXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMyAgICAgIEphc3BlciBTdC4gUGllcnJlXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMC0yMDEzIEludGVsIENvcnBvcmF0aW9uXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxNS0yMDE3IFNhbXN1bmcgRWxlY3Ryb25pY3MgQ28uLCBMdGRcbiAqICAgIENvcHlyaWdodCDCqSAyMDE1LTIwMTcgUmVkIEhhdCBJbmMuXG4gKlxuICogICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqICAgIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqICAgIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqICAgIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogICAgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiAgICBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIChpbmNsdWRpbmcgdGhlIG5leHRcbiAqICAgIHBhcmFncmFwaCkgc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGVcbiAqICAgIFNvZnR3YXJlLlxuICpcbiAqICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqICAgIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogICAgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiAgICBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogICAgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqICAgIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqICAgIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqICBcbiAqL1xuXG4vKipcbiAqIEBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgWGRnU3VyZmFjZUV2ZW50cyB7XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRUaGUgY29uZmlndXJlIGV2ZW50IG1hcmtzIHRoZSBlbmQgb2YgYSBjb25maWd1cmUgc2VxdWVuY2UuIEEgY29uZmlndXJlXG5cdCAqXHRzZXF1ZW5jZSBpcyBhIHNldCBvZiBvbmUgb3IgbW9yZSBldmVudHMgY29uZmlndXJpbmcgdGhlIHN0YXRlIG9mIHRoZVxuXHQgKlx0eGRnX3N1cmZhY2UsIGluY2x1ZGluZyB0aGUgZmluYWwgeGRnX3N1cmZhY2UuY29uZmlndXJlIGV2ZW50LlxuXHQgKlxuXHQgKlx0V2hlcmUgYXBwbGljYWJsZSwgeGRnX3N1cmZhY2Ugc3VyZmFjZSByb2xlcyB3aWxsIGR1cmluZyBhIGNvbmZpZ3VyZVxuXHQgKlx0c2VxdWVuY2UgZXh0ZW5kIHRoaXMgZXZlbnQgYXMgYSBsYXRjaGVkIHN0YXRlIHNlbnQgYXMgZXZlbnRzIGJlZm9yZSB0aGVcblx0ICpcdHhkZ19zdXJmYWNlLmNvbmZpZ3VyZSBldmVudC4gU3VjaCBldmVudHMgc2hvdWxkIGJlIGNvbnNpZGVyZWQgdG8gbWFrZSB1cFxuXHQgKlx0YSBzZXQgb2YgYXRvbWljYWxseSBhcHBsaWVkIGNvbmZpZ3VyYXRpb24gc3RhdGVzLCB3aGVyZSB0aGVcblx0ICpcdHhkZ19zdXJmYWNlLmNvbmZpZ3VyZSBjb21taXRzIHRoZSBhY2N1bXVsYXRlZCBzdGF0ZS5cblx0ICpcblx0ICpcdENsaWVudHMgc2hvdWxkIGFycmFuZ2UgdGhlaXIgc3VyZmFjZSBmb3IgdGhlIG5ldyBzdGF0ZXMsIGFuZCB0aGVuIHNlbmRcblx0ICpcdGFuIGFja19jb25maWd1cmUgcmVxdWVzdCB3aXRoIHRoZSBzZXJpYWwgc2VudCBpbiB0aGlzIGNvbmZpZ3VyZSBldmVudCBhdFxuXHQgKlx0c29tZSBwb2ludCBiZWZvcmUgY29tbWl0dGluZyB0aGUgbmV3IHN1cmZhY2UuXG5cdCAqXG5cdCAqXHRJZiB0aGUgY2xpZW50IHJlY2VpdmVzIG11bHRpcGxlIGNvbmZpZ3VyZSBldmVudHMgYmVmb3JlIGl0IGNhbiByZXNwb25kXG5cdCAqXHR0byBvbmUsIGl0IGlzIGZyZWUgdG8gZGlzY2FyZCBhbGwgYnV0IHRoZSBsYXN0IGV2ZW50IGl0IHJlY2VpdmVkLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2VyaWFsIHNlcmlhbCBvZiB0aGUgY29uZmlndXJlIGV2ZW50IFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0Y29uZmlndXJlKHNlcmlhbCkge31cbn1cblxuIiwiLypcbiAqXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAwOC0yMDEzIEtyaXN0aWFuIEjDuGdzYmVyZ1xuICogICAgQ29weXJpZ2h0IMKpIDIwMTMgICAgICBSYWZhZWwgQW50b2dub2xsaVxuICogICAgQ29weXJpZ2h0IMKpIDIwMTMgICAgICBKYXNwZXIgU3QuIFBpZXJyZVxuICogICAgQ29weXJpZ2h0IMKpIDIwMTAtMjAxMyBJbnRlbCBDb3Jwb3JhdGlvblxuICogICAgQ29weXJpZ2h0IMKpIDIwMTUtMjAxNyBTYW1zdW5nIEVsZWN0cm9uaWNzIENvLiwgTHRkXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxNS0yMDE3IFJlZCBIYXQgSW5jLlxuICpcbiAqICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiAgICBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiAgICB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiAgICB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqICAgIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogICAgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSAoaW5jbHVkaW5nIHRoZSBuZXh0XG4gKiAgICBwYXJhZ3JhcGgpIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlXG4gKiAgICBTb2Z0d2FyZS5cbiAqXG4gKiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiAgICBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqICAgIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTFxuICogICAgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqICAgIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiAgICBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSXG4gKiAgICBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKiAgXG4gKi9cblxuaW1wb3J0IHsgQ29ubmVjdGlvbiB9IGZyb20gJ3dlc3RmaWVsZC1ydW50aW1lLWNvbW1vbidcbmNvbnN0IHsgdWludCwgdWludE9wdGlvbmFsLCBpbnQsIGludE9wdGlvbmFsLCBmaXhlZCwgXG5cdGZpeGVkT3B0aW9uYWwsIG9iamVjdCwgb2JqZWN0T3B0aW9uYWwsIG5ld09iamVjdCwgc3RyaW5nLCBcblx0c3RyaW5nT3B0aW9uYWwsIGFycmF5LCBhcnJheU9wdGlvbmFsLCBcblx0ZmlsZURlc2NyaXB0b3JPcHRpb25hbCwgZmlsZURlc2NyaXB0b3IsIFxuaCwgdSwgaSwgZiwgbywgbiwgcywgYSB9ID0gQ29ubmVjdGlvblxuaW1wb3J0IFByb3h5IGZyb20gJy4vUHJveHknXG5pbXBvcnQgWGRnVG9wbGV2ZWxQcm94eSBmcm9tICcuL1hkZ1RvcGxldmVsUHJveHknXG5pbXBvcnQgWGRnUG9wdXBQcm94eSBmcm9tICcuL1hkZ1BvcHVwUHJveHknXG5cbi8qKlxuICpcbiAqICAgICAgQW4gaW50ZXJmYWNlIHRoYXQgbWF5IGJlIGltcGxlbWVudGVkIGJ5IGEgd2xfc3VyZmFjZSwgZm9yXG4gKiAgICAgIGltcGxlbWVudGF0aW9ucyB0aGF0IHByb3ZpZGUgYSBkZXNrdG9wLXN0eWxlIHVzZXIgaW50ZXJmYWNlLlxuICpcbiAqICAgICAgSXQgcHJvdmlkZXMgYSBiYXNlIHNldCBvZiBmdW5jdGlvbmFsaXR5IHJlcXVpcmVkIHRvIGNvbnN0cnVjdCB1c2VyXG4gKiAgICAgIGludGVyZmFjZSBlbGVtZW50cyByZXF1aXJpbmcgbWFuYWdlbWVudCBieSB0aGUgY29tcG9zaXRvciwgc3VjaCBhc1xuICogICAgICB0b3BsZXZlbCB3aW5kb3dzLCBtZW51cywgZXRjLiBUaGUgdHlwZXMgb2YgZnVuY3Rpb25hbGl0eSBhcmUgc3BsaXQgaW50b1xuICogICAgICB4ZGdfc3VyZmFjZSByb2xlcy5cbiAqXG4gKiAgICAgIENyZWF0aW5nIGFuIHhkZ19zdXJmYWNlIGRvZXMgbm90IHNldCB0aGUgcm9sZSBmb3IgYSB3bF9zdXJmYWNlLiBJbiBvcmRlclxuICogICAgICB0byBtYXAgYW4geGRnX3N1cmZhY2UsIHRoZSBjbGllbnQgbXVzdCBjcmVhdGUgYSByb2xlLXNwZWNpZmljIG9iamVjdFxuICogICAgICB1c2luZywgZS5nLiwgZ2V0X3RvcGxldmVsLCBnZXRfcG9wdXAuIFRoZSB3bF9zdXJmYWNlIGZvciBhbnkgZ2l2ZW5cbiAqICAgICAgeGRnX3N1cmZhY2UgY2FuIGhhdmUgYXQgbW9zdCBvbmUgcm9sZSwgYW5kIG1heSBub3QgYmUgYXNzaWduZWQgYW55IHJvbGVcbiAqICAgICAgbm90IGJhc2VkIG9uIHhkZ19zdXJmYWNlLlxuICpcbiAqICAgICAgQSByb2xlIG11c3QgYmUgYXNzaWduZWQgYmVmb3JlIGFueSBvdGhlciByZXF1ZXN0cyBhcmUgbWFkZSB0byB0aGVcbiAqICAgICAgeGRnX3N1cmZhY2Ugb2JqZWN0LlxuICpcbiAqICAgICAgVGhlIGNsaWVudCBtdXN0IGNhbGwgd2xfc3VyZmFjZS5jb21taXQgb24gdGhlIGNvcnJlc3BvbmRpbmcgd2xfc3VyZmFjZVxuICogICAgICBmb3IgdGhlIHhkZ19zdXJmYWNlIHN0YXRlIHRvIHRha2UgZWZmZWN0LlxuICpcbiAqICAgICAgQ3JlYXRpbmcgYW4geGRnX3N1cmZhY2UgZnJvbSBhIHdsX3N1cmZhY2Ugd2hpY2ggaGFzIGEgYnVmZmVyIGF0dGFjaGVkIG9yXG4gKiAgICAgIGNvbW1pdHRlZCBpcyBhIGNsaWVudCBlcnJvciwgYW5kIGFueSBhdHRlbXB0cyBieSBhIGNsaWVudCB0byBhdHRhY2ggb3JcbiAqICAgICAgbWFuaXB1bGF0ZSBhIGJ1ZmZlciBwcmlvciB0byB0aGUgZmlyc3QgeGRnX3N1cmZhY2UuY29uZmlndXJlIGNhbGwgbXVzdFxuICogICAgICBhbHNvIGJlIHRyZWF0ZWQgYXMgZXJyb3JzLlxuICpcbiAqICAgICAgTWFwcGluZyBhbiB4ZGdfc3VyZmFjZS1iYXNlZCByb2xlIHN1cmZhY2UgaXMgZGVmaW5lZCBhcyBtYWtpbmcgaXRcbiAqICAgICAgcG9zc2libGUgZm9yIHRoZSBzdXJmYWNlIHRvIGJlIHNob3duIGJ5IHRoZSBjb21wb3NpdG9yLiBOb3RlIHRoYXRcbiAqICAgICAgYSBtYXBwZWQgc3VyZmFjZSBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSB2aXNpYmxlIG9uY2UgaXQgaXMgbWFwcGVkLlxuICpcbiAqICAgICAgRm9yIGFuIHhkZ19zdXJmYWNlIHRvIGJlIG1hcHBlZCBieSB0aGUgY29tcG9zaXRvciwgdGhlIGZvbGxvd2luZ1xuICogICAgICBjb25kaXRpb25zIG11c3QgYmUgbWV0OlxuICogICAgICAoMSkgdGhlIGNsaWVudCBoYXMgYXNzaWduZWQgYW4geGRnX3N1cmZhY2UtYmFzZWQgcm9sZSB0byB0aGUgc3VyZmFjZVxuICogICAgICAoMikgdGhlIGNsaWVudCBoYXMgc2V0IGFuZCBjb21taXR0ZWQgdGhlIHhkZ19zdXJmYWNlIHN0YXRlIGFuZCB0aGVcbiAqXHQgIHJvbGUtZGVwZW5kZW50IHN0YXRlIHRvIHRoZSBzdXJmYWNlXG4gKiAgICAgICgzKSB0aGUgY2xpZW50IGhhcyBjb21taXR0ZWQgYSBidWZmZXIgdG8gdGhlIHN1cmZhY2VcbiAqXG4gKiAgICAgIEEgbmV3bHktdW5tYXBwZWQgc3VyZmFjZSBpcyBjb25zaWRlcmVkIHRvIGhhdmUgbWV0IGNvbmRpdGlvbiAoMSkgb3V0XG4gKiAgICAgIG9mIHRoZSAzIHJlcXVpcmVkIGNvbmRpdGlvbnMgZm9yIG1hcHBpbmcgYSBzdXJmYWNlIGlmIGl0cyByb2xlIHN1cmZhY2VcbiAqICAgICAgaGFzIG5vdCBiZWVuIGRlc3Ryb3llZC5cbiAqICAgIFxuICovXG5jbGFzcyBYZGdTdXJmYWNlUHJveHkgZXh0ZW5kcyBQcm94eSB7XG5cblx0LyoqXG5cdCAqXG5cdCAqXHREZXN0cm95IHRoZSB4ZGdfc3VyZmFjZSBvYmplY3QuIEFuIHhkZ19zdXJmYWNlIG11c3Qgb25seSBiZSBkZXN0cm95ZWRcblx0ICpcdGFmdGVyIGl0cyByb2xlIG9iamVjdCBoYXMgYmVlbiBkZXN0cm95ZWQuXG5cdCAqICAgICAgXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRkZXN0cm95ICgpIHtcblx0XHRzdXBlci5kZXN0cm95KClcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCAwLCBbXSlcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0VGhpcyBjcmVhdGVzIGFuIHhkZ190b3BsZXZlbCBvYmplY3QgZm9yIHRoZSBnaXZlbiB4ZGdfc3VyZmFjZSBhbmQgZ2l2ZXNcblx0ICpcdHRoZSBhc3NvY2lhdGVkIHdsX3N1cmZhY2UgdGhlIHhkZ190b3BsZXZlbCByb2xlLlxuXHQgKlxuXHQgKlx0U2VlIHRoZSBkb2N1bWVudGF0aW9uIG9mIHhkZ190b3BsZXZlbCBmb3IgbW9yZSBkZXRhaWxzIGFib3V0IHdoYXQgYW5cblx0ICpcdHhkZ190b3BsZXZlbCBpcyBhbmQgaG93IGl0IGlzIHVzZWQuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEByZXR1cm4ge1hkZ1RvcGxldmVsUHJveHl9ICBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdGdldFRvcGxldmVsICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWFyc2hhbGxDb25zdHJ1Y3Rvcih0aGlzLmlkLCAxLCBYZGdUb3BsZXZlbFByb3h5LCBbbmV3T2JqZWN0KCldKVxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRUaGlzIGNyZWF0ZXMgYW4geGRnX3BvcHVwIG9iamVjdCBmb3IgdGhlIGdpdmVuIHhkZ19zdXJmYWNlIGFuZCBnaXZlc1xuXHQgKlx0dGhlIGFzc29jaWF0ZWQgd2xfc3VyZmFjZSB0aGUgeGRnX3BvcHVwIHJvbGUuXG5cdCAqXG5cdCAqXHRJZiBudWxsIGlzIHBhc3NlZCBhcyBhIHBhcmVudCwgYSBwYXJlbnQgc3VyZmFjZSBtdXN0IGJlIHNwZWNpZmllZCB1c2luZ1xuXHQgKlx0c29tZSBvdGhlciBwcm90b2NvbCwgYmVmb3JlIGNvbW1pdHRpbmcgdGhlIGluaXRpYWwgc3RhdGUuXG5cdCAqXG5cdCAqXHRTZWUgdGhlIGRvY3VtZW50YXRpb24gb2YgeGRnX3BvcHVwIGZvciBtb3JlIGRldGFpbHMgYWJvdXQgd2hhdCBhblxuXHQgKlx0eGRnX3BvcHVwIGlzIGFuZCBob3cgaXQgaXMgdXNlZC5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHs/Kn0gcGFyZW50ICBcblx0ICogQHBhcmFtIHsqfSBwb3NpdGlvbmVyICBcblx0ICogQHJldHVybiB7WGRnUG9wdXBQcm94eX0gIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0Z2V0UG9wdXAgKHBhcmVudCwgcG9zaXRpb25lcikge1xuXHRcdHJldHVybiB0aGlzLl9tYXJzaGFsbENvbnN0cnVjdG9yKHRoaXMuaWQsIDIsIFhkZ1BvcHVwUHJveHksIFtuZXdPYmplY3QoKSwgb2JqZWN0T3B0aW9uYWwocGFyZW50KSwgb2JqZWN0KHBvc2l0aW9uZXIpXSlcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0VGhlIHdpbmRvdyBnZW9tZXRyeSBvZiBhIHN1cmZhY2UgaXMgaXRzIFwidmlzaWJsZSBib3VuZHNcIiBmcm9tIHRoZVxuXHQgKlx0dXNlcidzIHBlcnNwZWN0aXZlLiBDbGllbnQtc2lkZSBkZWNvcmF0aW9ucyBvZnRlbiBoYXZlIGludmlzaWJsZVxuXHQgKlx0cG9ydGlvbnMgbGlrZSBkcm9wLXNoYWRvd3Mgd2hpY2ggc2hvdWxkIGJlIGlnbm9yZWQgZm9yIHRoZVxuXHQgKlx0cHVycG9zZXMgb2YgYWxpZ25pbmcsIHBsYWNpbmcgYW5kIGNvbnN0cmFpbmluZyB3aW5kb3dzLlxuXHQgKlxuXHQgKlx0VGhlIHdpbmRvdyBnZW9tZXRyeSBpcyBkb3VibGUgYnVmZmVyZWQsIGFuZCB3aWxsIGJlIGFwcGxpZWQgYXQgdGhlXG5cdCAqXHR0aW1lIHdsX3N1cmZhY2UuY29tbWl0IG9mIHRoZSBjb3JyZXNwb25kaW5nIHdsX3N1cmZhY2UgaXMgY2FsbGVkLlxuXHQgKlxuXHQgKlx0V2hlbiBtYWludGFpbmluZyBhIHBvc2l0aW9uLCB0aGUgY29tcG9zaXRvciBzaG91bGQgdHJlYXQgdGhlICh4LCB5KVxuXHQgKlx0Y29vcmRpbmF0ZSBvZiB0aGUgd2luZG93IGdlb21ldHJ5IGFzIHRoZSB0b3AgbGVmdCBjb3JuZXIgb2YgdGhlIHdpbmRvdy5cblx0ICpcdEEgY2xpZW50IGNoYW5naW5nIHRoZSAoeCwgeSkgd2luZG93IGdlb21ldHJ5IGNvb3JkaW5hdGUgc2hvdWxkIGluXG5cdCAqXHRnZW5lcmFsIG5vdCBhbHRlciB0aGUgcG9zaXRpb24gb2YgdGhlIHdpbmRvdy5cblx0ICpcblx0ICpcdE9uY2UgdGhlIHdpbmRvdyBnZW9tZXRyeSBvZiB0aGUgc3VyZmFjZSBpcyBzZXQsIGl0IGlzIG5vdCBwb3NzaWJsZSB0b1xuXHQgKlx0dW5zZXQgaXQsIGFuZCBpdCB3aWxsIHJlbWFpbiB0aGUgc2FtZSB1bnRpbCBzZXRfd2luZG93X2dlb21ldHJ5IGlzXG5cdCAqXHRjYWxsZWQgYWdhaW4sIGV2ZW4gaWYgYSBuZXcgc3Vic3VyZmFjZSBvciBidWZmZXIgaXMgYXR0YWNoZWQuXG5cdCAqXG5cdCAqXHRJZiBuZXZlciBzZXQsIHRoZSB2YWx1ZSBpcyB0aGUgZnVsbCBib3VuZHMgb2YgdGhlIHN1cmZhY2UsXG5cdCAqXHRpbmNsdWRpbmcgYW55IHN1YnN1cmZhY2VzLiBUaGlzIHVwZGF0ZXMgZHluYW1pY2FsbHkgb24gZXZlcnlcblx0ICpcdGNvbW1pdC4gVGhpcyB1bnNldCBpcyBtZWFudCBmb3IgZXh0cmVtZWx5IHNpbXBsZSBjbGllbnRzLlxuXHQgKlxuXHQgKlx0VGhlIGFyZ3VtZW50cyBhcmUgZ2l2ZW4gaW4gdGhlIHN1cmZhY2UtbG9jYWwgY29vcmRpbmF0ZSBzcGFjZSBvZlxuXHQgKlx0dGhlIHdsX3N1cmZhY2UgYXNzb2NpYXRlZCB3aXRoIHRoaXMgeGRnX3N1cmZhY2UuXG5cdCAqXG5cdCAqXHRUaGUgd2lkdGggYW5kIGhlaWdodCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvLiBTZXR0aW5nIGFuIGludmFsaWQgc2l6ZVxuXHQgKlx0d2lsbCByYWlzZSBhbiBlcnJvci4gV2hlbiBhcHBsaWVkLCB0aGUgZWZmZWN0aXZlIHdpbmRvdyBnZW9tZXRyeSB3aWxsIGJlXG5cdCAqXHR0aGUgc2V0IHdpbmRvdyBnZW9tZXRyeSBjbGFtcGVkIHRvIHRoZSBib3VuZGluZyByZWN0YW5nbGUgb2YgdGhlXG5cdCAqXHRjb21iaW5lZCBnZW9tZXRyeSBvZiB0aGUgc3VyZmFjZSBvZiB0aGUgeGRnX3N1cmZhY2UgYW5kIHRoZSBhc3NvY2lhdGVkXG5cdCAqXHRzdWJzdXJmYWNlcy5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHtudW1iZXJ9IHggIFxuXHQgKiBAcGFyYW0ge251bWJlcn0geSAgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0c2V0V2luZG93R2VvbWV0cnkgKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCAzLCBbaW50KHgpLCBpbnQoeSksIGludCh3aWR0aCksIGludChoZWlnaHQpXSlcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0V2hlbiBhIGNvbmZpZ3VyZSBldmVudCBpcyByZWNlaXZlZCwgaWYgYSBjbGllbnQgY29tbWl0cyB0aGVcblx0ICpcdHN1cmZhY2UgaW4gcmVzcG9uc2UgdG8gdGhlIGNvbmZpZ3VyZSBldmVudCwgdGhlbiB0aGUgY2xpZW50XG5cdCAqXHRtdXN0IG1ha2UgYW4gYWNrX2NvbmZpZ3VyZSByZXF1ZXN0IHNvbWV0aW1lIGJlZm9yZSB0aGUgY29tbWl0XG5cdCAqXHRyZXF1ZXN0LCBwYXNzaW5nIGFsb25nIHRoZSBzZXJpYWwgb2YgdGhlIGNvbmZpZ3VyZSBldmVudC5cblx0ICpcblx0ICpcdEZvciBpbnN0YW5jZSwgZm9yIHRvcGxldmVsIHN1cmZhY2VzIHRoZSBjb21wb3NpdG9yIG1pZ2h0IHVzZSB0aGlzXG5cdCAqXHRpbmZvcm1hdGlvbiB0byBtb3ZlIGEgc3VyZmFjZSB0byB0aGUgdG9wIGxlZnQgb25seSB3aGVuIHRoZSBjbGllbnQgaGFzXG5cdCAqXHRkcmF3biBpdHNlbGYgZm9yIHRoZSBtYXhpbWl6ZWQgb3IgZnVsbHNjcmVlbiBzdGF0ZS5cblx0ICpcblx0ICpcdElmIHRoZSBjbGllbnQgcmVjZWl2ZXMgbXVsdGlwbGUgY29uZmlndXJlIGV2ZW50cyBiZWZvcmUgaXRcblx0ICpcdGNhbiByZXNwb25kIHRvIG9uZSwgaXQgb25seSBoYXMgdG8gYWNrIHRoZSBsYXN0IGNvbmZpZ3VyZSBldmVudC5cblx0ICpcblx0ICpcdEEgY2xpZW50IGlzIG5vdCByZXF1aXJlZCB0byBjb21taXQgaW1tZWRpYXRlbHkgYWZ0ZXIgc2VuZGluZ1xuXHQgKlx0YW4gYWNrX2NvbmZpZ3VyZSByZXF1ZXN0IC0gaXQgbWF5IGV2ZW4gYWNrX2NvbmZpZ3VyZSBzZXZlcmFsIHRpbWVzXG5cdCAqXHRiZWZvcmUgaXRzIG5leHQgc3VyZmFjZSBjb21taXQuXG5cdCAqXG5cdCAqXHRBIGNsaWVudCBtYXkgc2VuZCBtdWx0aXBsZSBhY2tfY29uZmlndXJlIHJlcXVlc3RzIGJlZm9yZSBjb21taXR0aW5nLCBidXRcblx0ICpcdG9ubHkgdGhlIGxhc3QgcmVxdWVzdCBzZW50IGJlZm9yZSBhIGNvbW1pdCBpbmRpY2F0ZXMgd2hpY2ggY29uZmlndXJlXG5cdCAqXHRldmVudCB0aGUgY2xpZW50IHJlYWxseSBpcyByZXNwb25kaW5nIHRvLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2VyaWFsIHRoZSBzZXJpYWwgZnJvbSB0aGUgY29uZmlndXJlIGV2ZW50IFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0YWNrQ29uZmlndXJlIChzZXJpYWwpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCA0LCBbdWludChzZXJpYWwpXSlcblx0fVxuXG5cdC8qKlxuXHQgKiBEbyBub3QgY29uc3RydWN0IHByb3hpZXMgZGlyZWN0bHkuIEluc3RlYWQgdXNlIG9uZSBvZiB0aGUgZmFjdG9yeSBtZXRob2RzIGZyb20gb3RoZXIgcHJveGllcy5cblx0ICpAcGFyYW0ge0Rpc3BsYXl9ZGlzcGxheVxuXHQgKkBwYXJhbSB7Q29ubmVjdGlvbn1jb25uZWN0aW9uXG5cdCAqQHBhcmFtIHtudW1iZXJ9aWRcblx0ICovXG5cdGNvbnN0cnVjdG9yIChkaXNwbGF5LCBjb25uZWN0aW9uLCBpZCkge1xuXHRcdHN1cGVyKGRpc3BsYXksIGNvbm5lY3Rpb24sIGlkKVxuXHRcdC8qKlxuXHRcdCAqIEB0eXBlIHtYZGdTdXJmYWNlRXZlbnRzfG51bGx9XG5cdFx0ICovXG5cdFx0dGhpcy5saXN0ZW5lciA9IG51bGxcblx0fVxuXG5cdGFzeW5jIFswXSAobWVzc2FnZSkge1xuXHRcdGF3YWl0IHRoaXMubGlzdGVuZXIuY29uZmlndXJlKHUobWVzc2FnZSkpXG5cdH1cblxufVxuWGRnU3VyZmFjZVByb3h5LnByb3RvY29sTmFtZSA9ICd4ZGdfc3VyZmFjZSdcblxuWGRnU3VyZmFjZVByb3h5LkVycm9yID0ge1xuICAvKipcbiAgICogXG4gICAqL1xuICBub3RDb25zdHJ1Y3RlZDogMSxcbiAgLyoqXG4gICAqIFxuICAgKi9cbiAgYWxyZWFkeUNvbnN0cnVjdGVkOiAyLFxuICAvKipcbiAgICogXG4gICAqL1xuICB1bmNvbmZpZ3VyZWRCdWZmZXI6IDNcbn1cblxuZXhwb3J0IGRlZmF1bHQgWGRnU3VyZmFjZVByb3h5XG4iLCIvKlxuICpcbiAqICAgIENvcHlyaWdodCDCqSAyMDA4LTIwMTMgS3Jpc3RpYW4gSMO4Z3NiZXJnXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMyAgICAgIFJhZmFlbCBBbnRvZ25vbGxpXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMyAgICAgIEphc3BlciBTdC4gUGllcnJlXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMC0yMDEzIEludGVsIENvcnBvcmF0aW9uXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxNS0yMDE3IFNhbXN1bmcgRWxlY3Ryb25pY3MgQ28uLCBMdGRcbiAqICAgIENvcHlyaWdodCDCqSAyMDE1LTIwMTcgUmVkIEhhdCBJbmMuXG4gKlxuICogICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqICAgIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqICAgIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqICAgIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogICAgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiAgICBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIChpbmNsdWRpbmcgdGhlIG5leHRcbiAqICAgIHBhcmFncmFwaCkgc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGVcbiAqICAgIFNvZnR3YXJlLlxuICpcbiAqICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqICAgIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogICAgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiAgICBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogICAgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqICAgIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqICAgIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqICBcbiAqL1xuXG4vKipcbiAqIEBpbnRlcmZhY2VcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgWGRnVG9wbGV2ZWxFdmVudHMge1xuXG5cdC8qKlxuXHQgKlxuXHQgKlx0VGhpcyBjb25maWd1cmUgZXZlbnQgYXNrcyB0aGUgY2xpZW50IHRvIHJlc2l6ZSBpdHMgdG9wbGV2ZWwgc3VyZmFjZSBvclxuXHQgKlx0dG8gY2hhbmdlIGl0cyBzdGF0ZS4gVGhlIGNvbmZpZ3VyZWQgc3RhdGUgc2hvdWxkIG5vdCBiZSBhcHBsaWVkXG5cdCAqXHRpbW1lZGlhdGVseS4gU2VlIHhkZ19zdXJmYWNlLmNvbmZpZ3VyZSBmb3IgZGV0YWlscy5cblx0ICpcblx0ICpcdFRoZSB3aWR0aCBhbmQgaGVpZ2h0IGFyZ3VtZW50cyBzcGVjaWZ5IGEgaGludCB0byB0aGUgd2luZG93XG5cdCAqXHRhYm91dCBob3cgaXRzIHN1cmZhY2Ugc2hvdWxkIGJlIHJlc2l6ZWQgaW4gd2luZG93IGdlb21ldHJ5XG5cdCAqXHRjb29yZGluYXRlcy4gU2VlIHNldF93aW5kb3dfZ2VvbWV0cnkuXG5cdCAqXG5cdCAqXHRJZiB0aGUgd2lkdGggb3IgaGVpZ2h0IGFyZ3VtZW50cyBhcmUgemVybywgaXQgbWVhbnMgdGhlIGNsaWVudFxuXHQgKlx0c2hvdWxkIGRlY2lkZSBpdHMgb3duIHdpbmRvdyBkaW1lbnNpb24uIFRoaXMgbWF5IGhhcHBlbiB3aGVuIHRoZVxuXHQgKlx0Y29tcG9zaXRvciBuZWVkcyB0byBjb25maWd1cmUgdGhlIHN0YXRlIG9mIHRoZSBzdXJmYWNlIGJ1dCBkb2Vzbid0XG5cdCAqXHRoYXZlIGFueSBpbmZvcm1hdGlvbiBhYm91dCBhbnkgcHJldmlvdXMgb3IgZXhwZWN0ZWQgZGltZW5zaW9uLlxuXHQgKlxuXHQgKlx0VGhlIHN0YXRlcyBsaXN0ZWQgaW4gdGhlIGV2ZW50IHNwZWNpZnkgaG93IHRoZSB3aWR0aC9oZWlnaHRcblx0ICpcdGFyZ3VtZW50cyBzaG91bGQgYmUgaW50ZXJwcmV0ZWQsIGFuZCBwb3NzaWJseSBob3cgaXQgc2hvdWxkIGJlXG5cdCAqXHRkcmF3bi5cblx0ICpcblx0ICpcdENsaWVudHMgbXVzdCBzZW5kIGFuIGFja19jb25maWd1cmUgaW4gcmVzcG9uc2UgdG8gdGhpcyBldmVudC4gU2VlXG5cdCAqXHR4ZGdfc3VyZmFjZS5jb25maWd1cmUgYW5kIHhkZ19zdXJmYWNlLmFja19jb25maWd1cmUgZm9yIGRldGFpbHMuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgIFxuXHQgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBzdGF0ZXMgIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0Y29uZmlndXJlKHdpZHRoLCBoZWlnaHQsIHN0YXRlcykge31cblxuXHQvKipcblx0ICpcblx0ICpcdFRoZSBjbG9zZSBldmVudCBpcyBzZW50IGJ5IHRoZSBjb21wb3NpdG9yIHdoZW4gdGhlIHVzZXJcblx0ICpcdHdhbnRzIHRoZSBzdXJmYWNlIHRvIGJlIGNsb3NlZC4gVGhpcyBzaG91bGQgYmUgZXF1aXZhbGVudCB0b1xuXHQgKlx0dGhlIHVzZXIgY2xpY2tpbmcgdGhlIGNsb3NlIGJ1dHRvbiBpbiBjbGllbnQtc2lkZSBkZWNvcmF0aW9ucyxcblx0ICpcdGlmIHlvdXIgYXBwbGljYXRpb24gaGFzIGFueS5cblx0ICpcblx0ICpcdFRoaXMgaXMgb25seSBhIHJlcXVlc3QgdGhhdCB0aGUgdXNlciBpbnRlbmRzIHRvIGNsb3NlIHRoZVxuXHQgKlx0d2luZG93LiBUaGUgY2xpZW50IG1heSBjaG9vc2UgdG8gaWdub3JlIHRoaXMgcmVxdWVzdCwgb3Igc2hvd1xuXHQgKlx0YSBkaWFsb2cgdG8gYXNrIHRoZSB1c2VyIHRvIHNhdmUgdGhlaXIgZGF0YSwgZXRjLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0Y2xvc2UoKSB7fVxufVxuXG4iLCIvKlxuICpcbiAqICAgIENvcHlyaWdodCDCqSAyMDA4LTIwMTMgS3Jpc3RpYW4gSMO4Z3NiZXJnXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMyAgICAgIFJhZmFlbCBBbnRvZ25vbGxpXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMyAgICAgIEphc3BlciBTdC4gUGllcnJlXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxMC0yMDEzIEludGVsIENvcnBvcmF0aW9uXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxNS0yMDE3IFNhbXN1bmcgRWxlY3Ryb25pY3MgQ28uLCBMdGRcbiAqICAgIENvcHlyaWdodCDCqSAyMDE1LTIwMTcgUmVkIEhhdCBJbmMuXG4gKlxuICogICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqICAgIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSxcbiAqICAgIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb25cbiAqICAgIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuICogICAgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiAgICBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqICAgIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIChpbmNsdWRpbmcgdGhlIG5leHRcbiAqICAgIHBhcmFncmFwaCkgc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGVcbiAqICAgIFNvZnR3YXJlLlxuICpcbiAqICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqICAgIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogICAgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gIElOIE5PIEVWRU5UIFNIQUxMXG4gKiAgICBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogICAgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAqICAgIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVJcbiAqICAgIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqICBcbiAqL1xuXG5pbXBvcnQgeyBDb25uZWN0aW9uIH0gZnJvbSAnd2VzdGZpZWxkLXJ1bnRpbWUtY29tbW9uJ1xuY29uc3QgeyB1aW50LCB1aW50T3B0aW9uYWwsIGludCwgaW50T3B0aW9uYWwsIGZpeGVkLCBcblx0Zml4ZWRPcHRpb25hbCwgb2JqZWN0LCBvYmplY3RPcHRpb25hbCwgbmV3T2JqZWN0LCBzdHJpbmcsIFxuXHRzdHJpbmdPcHRpb25hbCwgYXJyYXksIGFycmF5T3B0aW9uYWwsIFxuXHRmaWxlRGVzY3JpcHRvck9wdGlvbmFsLCBmaWxlRGVzY3JpcHRvciwgXG5oLCB1LCBpLCBmLCBvLCBuLCBzLCBhIH0gPSBDb25uZWN0aW9uXG5pbXBvcnQgUHJveHkgZnJvbSAnLi9Qcm94eSdcblxuLyoqXG4gKlxuICogICAgICBUaGlzIGludGVyZmFjZSBkZWZpbmVzIGFuIHhkZ19zdXJmYWNlIHJvbGUgd2hpY2ggYWxsb3dzIGEgc3VyZmFjZSB0byxcbiAqICAgICAgYW1vbmcgb3RoZXIgdGhpbmdzLCBzZXQgd2luZG93LWxpa2UgcHJvcGVydGllcyBzdWNoIGFzIG1heGltaXplLFxuICogICAgICBmdWxsc2NyZWVuLCBhbmQgbWluaW1pemUsIHNldCBhcHBsaWNhdGlvbi1zcGVjaWZpYyBtZXRhZGF0YSBsaWtlIHRpdGxlIGFuZFxuICogICAgICBpZCwgYW5kIHdlbGwgYXMgdHJpZ2dlciB1c2VyIGludGVyYWN0aXZlIG9wZXJhdGlvbnMgc3VjaCBhcyBpbnRlcmFjdGl2ZVxuICogICAgICByZXNpemUgYW5kIG1vdmUuXG4gKlxuICogICAgICBVbm1hcHBpbmcgYW4geGRnX3RvcGxldmVsIG1lYW5zIHRoYXQgdGhlIHN1cmZhY2UgY2Fubm90IGJlIHNob3duXG4gKiAgICAgIGJ5IHRoZSBjb21wb3NpdG9yIHVudGlsIGl0IGlzIGV4cGxpY2l0bHkgbWFwcGVkIGFnYWluLlxuICogICAgICBBbGwgYWN0aXZlIG9wZXJhdGlvbnMgKGUuZy4sIG1vdmUsIHJlc2l6ZSkgYXJlIGNhbmNlbGVkIGFuZCBhbGxcbiAqICAgICAgYXR0cmlidXRlcyAoZS5nLiB0aXRsZSwgc3RhdGUsIHN0YWNraW5nLCAuLi4pIGFyZSBkaXNjYXJkZWQgZm9yXG4gKiAgICAgIGFuIHhkZ190b3BsZXZlbCBzdXJmYWNlIHdoZW4gaXQgaXMgdW5tYXBwZWQuXG4gKlxuICogICAgICBBdHRhY2hpbmcgYSBudWxsIGJ1ZmZlciB0byBhIHRvcGxldmVsIHVubWFwcyB0aGUgc3VyZmFjZS5cbiAqICAgIFxuICovXG5jbGFzcyBYZGdUb3BsZXZlbFByb3h5IGV4dGVuZHMgUHJveHkge1xuXG5cdC8qKlxuXHQgKlxuXHQgKlx0VGhpcyByZXF1ZXN0IGRlc3Ryb3lzIHRoZSByb2xlIHN1cmZhY2UgYW5kIHVubWFwcyB0aGUgc3VyZmFjZTtcblx0ICpcdHNlZSBcIlVubWFwcGluZ1wiIGJlaGF2aW9yIGluIGludGVyZmFjZSBzZWN0aW9uIGZvciBkZXRhaWxzLlxuXHQgKiAgICAgIFxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0ZGVzdHJveSAoKSB7XG5cdFx0c3VwZXIuZGVzdHJveSgpXG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgMCwgW10pXG5cdH1cblxuXHQvKipcblx0ICpcblx0ICpcdFNldCB0aGUgXCJwYXJlbnRcIiBvZiB0aGlzIHN1cmZhY2UuIFRoaXMgc3VyZmFjZSBzaG91bGQgYmUgc3RhY2tlZFxuXHQgKlx0YWJvdmUgdGhlIHBhcmVudCBzdXJmYWNlIGFuZCBhbGwgb3RoZXIgYW5jZXN0b3Igc3VyZmFjZXMuXG5cdCAqXG5cdCAqXHRQYXJlbnQgd2luZG93cyBzaG91bGQgYmUgc2V0IG9uIGRpYWxvZ3MsIHRvb2xib3hlcywgb3Igb3RoZXJcblx0ICpcdFwiYXV4aWxpYXJ5XCIgc3VyZmFjZXMsIHNvIHRoYXQgdGhlIHBhcmVudCBpcyByYWlzZWQgd2hlbiB0aGUgZGlhbG9nXG5cdCAqXHRpcyByYWlzZWQuXG5cdCAqXG5cdCAqXHRTZXR0aW5nIGEgbnVsbCBwYXJlbnQgZm9yIGEgY2hpbGQgd2luZG93IHJlbW92ZXMgYW55IHBhcmVudC1jaGlsZFxuXHQgKlx0cmVsYXRpb25zaGlwIGZvciB0aGUgY2hpbGQuIFNldHRpbmcgYSBudWxsIHBhcmVudCBmb3IgYSB3aW5kb3cgd2hpY2hcblx0ICpcdGN1cnJlbnRseSBoYXMgbm8gcGFyZW50IGlzIGEgbm8tb3AuXG5cdCAqXG5cdCAqXHRJZiB0aGUgcGFyZW50IGlzIHVubWFwcGVkIHRoZW4gaXRzIGNoaWxkcmVuIGFyZSBtYW5hZ2VkIGFzXG5cdCAqXHR0aG91Z2ggdGhlIHBhcmVudCBvZiB0aGUgbm93LXVubWFwcGVkIHBhcmVudCBoYXMgYmVjb21lIHRoZVxuXHQgKlx0cGFyZW50IG9mIHRoaXMgc3VyZmFjZS4gSWYgbm8gcGFyZW50IGV4aXN0cyBmb3IgdGhlIG5vdy11bm1hcHBlZFxuXHQgKlx0cGFyZW50IHRoZW4gdGhlIGNoaWxkcmVuIGFyZSBtYW5hZ2VkIGFzIHRob3VnaCB0aGV5IGhhdmUgbm9cblx0ICpcdHBhcmVudCBzdXJmYWNlLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0gez8qfSBwYXJlbnQgIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0c2V0UGFyZW50IChwYXJlbnQpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCAxLCBbb2JqZWN0T3B0aW9uYWwocGFyZW50KV0pXG5cdH1cblxuXHQvKipcblx0ICpcblx0ICpcdFNldCBhIHNob3J0IHRpdGxlIGZvciB0aGUgc3VyZmFjZS5cblx0ICpcblx0ICpcdFRoaXMgc3RyaW5nIG1heSBiZSB1c2VkIHRvIGlkZW50aWZ5IHRoZSBzdXJmYWNlIGluIGEgdGFzayBiYXIsXG5cdCAqXHR3aW5kb3cgbGlzdCwgb3Igb3RoZXIgdXNlciBpbnRlcmZhY2UgZWxlbWVudHMgcHJvdmlkZWQgYnkgdGhlXG5cdCAqXHRjb21wb3NpdG9yLlxuXHQgKlxuXHQgKlx0VGhlIHN0cmluZyBtdXN0IGJlIGVuY29kZWQgaW4gVVRGLTguXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZSAgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRzZXRUaXRsZSAodGl0bGUpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCAyLCBbc3RyaW5nKHRpdGxlKV0pXG5cdH1cblxuXHQvKipcblx0ICpcblx0ICpcdFNldCBhbiBhcHBsaWNhdGlvbiBpZGVudGlmaWVyIGZvciB0aGUgc3VyZmFjZS5cblx0ICpcblx0ICpcdFRoZSBhcHAgSUQgaWRlbnRpZmllcyB0aGUgZ2VuZXJhbCBjbGFzcyBvZiBhcHBsaWNhdGlvbnMgdG8gd2hpY2hcblx0ICpcdHRoZSBzdXJmYWNlIGJlbG9uZ3MuIFRoZSBjb21wb3NpdG9yIGNhbiB1c2UgdGhpcyB0byBncm91cCBtdWx0aXBsZVxuXHQgKlx0c3VyZmFjZXMgdG9nZXRoZXIsIG9yIHRvIGRldGVybWluZSBob3cgdG8gbGF1bmNoIGEgbmV3IGFwcGxpY2F0aW9uLlxuXHQgKlxuXHQgKlx0Rm9yIEQtQnVzIGFjdGl2YXRhYmxlIGFwcGxpY2F0aW9ucywgdGhlIGFwcCBJRCBpcyB1c2VkIGFzIHRoZSBELUJ1c1xuXHQgKlx0c2VydmljZSBuYW1lLlxuXHQgKlxuXHQgKlx0VGhlIGNvbXBvc2l0b3Igc2hlbGwgd2lsbCB0cnkgdG8gZ3JvdXAgYXBwbGljYXRpb24gc3VyZmFjZXMgdG9nZXRoZXJcblx0ICpcdGJ5IHRoZWlyIGFwcCBJRC4gQXMgYSBiZXN0IHByYWN0aWNlLCBpdCBpcyBzdWdnZXN0ZWQgdG8gc2VsZWN0IGFwcFxuXHQgKlx0SUQncyB0aGF0IG1hdGNoIHRoZSBiYXNlbmFtZSBvZiB0aGUgYXBwbGljYXRpb24ncyAuZGVza3RvcCBmaWxlLlxuXHQgKlx0Rm9yIGV4YW1wbGUsIFwib3JnLmZyZWVkZXNrdG9wLkZvb1ZpZXdlclwiIHdoZXJlIHRoZSAuZGVza3RvcCBmaWxlIGlzXG5cdCAqXHRcIm9yZy5mcmVlZGVza3RvcC5Gb29WaWV3ZXIuZGVza3RvcFwiLlxuXHQgKlxuXHQgKlx0U2VlIHRoZSBkZXNrdG9wLWVudHJ5IHNwZWNpZmljYXRpb24gWzBdIGZvciBtb3JlIGRldGFpbHMgb25cblx0ICpcdGFwcGxpY2F0aW9uIGlkZW50aWZpZXJzIGFuZCBob3cgdGhleSByZWxhdGUgdG8gd2VsbC1rbm93biBELUJ1c1xuXHQgKlx0bmFtZXMgYW5kIC5kZXNrdG9wIGZpbGVzLlxuXHQgKlxuXHQgKlx0WzBdIGh0dHA6Ly9zdGFuZGFyZHMuZnJlZWRlc2t0b3Aub3JnL2Rlc2t0b3AtZW50cnktc3BlYy9cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGFwcElkICBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdHNldEFwcElkIChhcHBJZCkge1xuXHRcdHRoaXMuX21hcnNoYWxsKHRoaXMuaWQsIDMsIFtzdHJpbmcoYXBwSWQpXSlcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0Q2xpZW50cyBpbXBsZW1lbnRpbmcgY2xpZW50LXNpZGUgZGVjb3JhdGlvbnMgbWlnaHQgd2FudCB0byBzaG93XG5cdCAqXHRhIGNvbnRleHQgbWVudSB3aGVuIHJpZ2h0LWNsaWNraW5nIG9uIHRoZSBkZWNvcmF0aW9ucywgZ2l2aW5nIHRoZVxuXHQgKlx0dXNlciBhIG1lbnUgdGhhdCB0aGV5IGNhbiB1c2UgdG8gbWF4aW1pemUgb3IgbWluaW1pemUgdGhlIHdpbmRvdy5cblx0ICpcblx0ICpcdFRoaXMgcmVxdWVzdCBhc2tzIHRoZSBjb21wb3NpdG9yIHRvIHBvcCB1cCBzdWNoIGEgd2luZG93IG1lbnUgYXRcblx0ICpcdHRoZSBnaXZlbiBwb3NpdGlvbiwgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIHN1cmZhY2UgY29vcmRpbmF0ZXMgb2Zcblx0ICpcdHRoZSBwYXJlbnQgc3VyZmFjZS4gVGhlcmUgYXJlIG5vIGd1YXJhbnRlZXMgYXMgdG8gd2hhdCBtZW51IGl0ZW1zXG5cdCAqXHR0aGUgd2luZG93IG1lbnUgY29udGFpbnMuXG5cdCAqXG5cdCAqXHRUaGlzIHJlcXVlc3QgbXVzdCBiZSB1c2VkIGluIHJlc3BvbnNlIHRvIHNvbWUgc29ydCBvZiB1c2VyIGFjdGlvblxuXHQgKlx0bGlrZSBhIGJ1dHRvbiBwcmVzcywga2V5IHByZXNzLCBvciB0b3VjaCBkb3duIGV2ZW50LlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0geyp9IHNlYXQgdGhlIHdsX3NlYXQgb2YgdGhlIHVzZXIgZXZlbnQgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzZXJpYWwgdGhlIHNlcmlhbCBvZiB0aGUgdXNlciBldmVudCBcblx0ICogQHBhcmFtIHtudW1iZXJ9IHggdGhlIHggcG9zaXRpb24gdG8gcG9wIHVwIHRoZSB3aW5kb3cgbWVudSBhdCBcblx0ICogQHBhcmFtIHtudW1iZXJ9IHkgdGhlIHkgcG9zaXRpb24gdG8gcG9wIHVwIHRoZSB3aW5kb3cgbWVudSBhdCBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdHNob3dXaW5kb3dNZW51IChzZWF0LCBzZXJpYWwsIHgsIHkpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCA0LCBbb2JqZWN0KHNlYXQpLCB1aW50KHNlcmlhbCksIGludCh4KSwgaW50KHkpXSlcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0U3RhcnQgYW4gaW50ZXJhY3RpdmUsIHVzZXItZHJpdmVuIG1vdmUgb2YgdGhlIHN1cmZhY2UuXG5cdCAqXG5cdCAqXHRUaGlzIHJlcXVlc3QgbXVzdCBiZSB1c2VkIGluIHJlc3BvbnNlIHRvIHNvbWUgc29ydCBvZiB1c2VyIGFjdGlvblxuXHQgKlx0bGlrZSBhIGJ1dHRvbiBwcmVzcywga2V5IHByZXNzLCBvciB0b3VjaCBkb3duIGV2ZW50LiBUaGUgcGFzc2VkXG5cdCAqXHRzZXJpYWwgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHR5cGUgb2YgaW50ZXJhY3RpdmUgbW92ZSAodG91Y2gsXG5cdCAqXHRwb2ludGVyLCBldGMpLlxuXHQgKlxuXHQgKlx0VGhlIHNlcnZlciBtYXkgaWdub3JlIG1vdmUgcmVxdWVzdHMgZGVwZW5kaW5nIG9uIHRoZSBzdGF0ZSBvZlxuXHQgKlx0dGhlIHN1cmZhY2UgKGUuZy4gZnVsbHNjcmVlbiBvciBtYXhpbWl6ZWQpLCBvciBpZiB0aGUgcGFzc2VkIHNlcmlhbFxuXHQgKlx0aXMgbm8gbG9uZ2VyIHZhbGlkLlxuXHQgKlxuXHQgKlx0SWYgdHJpZ2dlcmVkLCB0aGUgc3VyZmFjZSB3aWxsIGxvc2UgdGhlIGZvY3VzIG9mIHRoZSBkZXZpY2Vcblx0ICpcdCh3bF9wb2ludGVyLCB3bF90b3VjaCwgZXRjKSB1c2VkIGZvciB0aGUgbW92ZS4gSXQgaXMgdXAgdG8gdGhlXG5cdCAqXHRjb21wb3NpdG9yIHRvIHZpc3VhbGx5IGluZGljYXRlIHRoYXQgdGhlIG1vdmUgaXMgdGFraW5nIHBsYWNlLCBzdWNoIGFzXG5cdCAqXHR1cGRhdGluZyBhIHBvaW50ZXIgY3Vyc29yLCBkdXJpbmcgdGhlIG1vdmUuIFRoZXJlIGlzIG5vIGd1YXJhbnRlZVxuXHQgKlx0dGhhdCB0aGUgZGV2aWNlIGZvY3VzIHdpbGwgcmV0dXJuIHdoZW4gdGhlIG1vdmUgaXMgY29tcGxldGVkLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0geyp9IHNlYXQgdGhlIHdsX3NlYXQgb2YgdGhlIHVzZXIgZXZlbnQgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzZXJpYWwgdGhlIHNlcmlhbCBvZiB0aGUgdXNlciBldmVudCBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdG1vdmUgKHNlYXQsIHNlcmlhbCkge1xuXHRcdHRoaXMuX21hcnNoYWxsKHRoaXMuaWQsIDUsIFtvYmplY3Qoc2VhdCksIHVpbnQoc2VyaWFsKV0pXG5cdH1cblxuXHQvKipcblx0ICpcblx0ICpcdFN0YXJ0IGEgdXNlci1kcml2ZW4sIGludGVyYWN0aXZlIHJlc2l6ZSBvZiB0aGUgc3VyZmFjZS5cblx0ICpcblx0ICpcdFRoaXMgcmVxdWVzdCBtdXN0IGJlIHVzZWQgaW4gcmVzcG9uc2UgdG8gc29tZSBzb3J0IG9mIHVzZXIgYWN0aW9uXG5cdCAqXHRsaWtlIGEgYnV0dG9uIHByZXNzLCBrZXkgcHJlc3MsIG9yIHRvdWNoIGRvd24gZXZlbnQuIFRoZSBwYXNzZWRcblx0ICpcdHNlcmlhbCBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgdHlwZSBvZiBpbnRlcmFjdGl2ZSByZXNpemUgKHRvdWNoLFxuXHQgKlx0cG9pbnRlciwgZXRjKS5cblx0ICpcblx0ICpcdFRoZSBzZXJ2ZXIgbWF5IGlnbm9yZSByZXNpemUgcmVxdWVzdHMgZGVwZW5kaW5nIG9uIHRoZSBzdGF0ZSBvZlxuXHQgKlx0dGhlIHN1cmZhY2UgKGUuZy4gZnVsbHNjcmVlbiBvciBtYXhpbWl6ZWQpLlxuXHQgKlxuXHQgKlx0SWYgdHJpZ2dlcmVkLCB0aGUgY2xpZW50IHdpbGwgcmVjZWl2ZSBjb25maWd1cmUgZXZlbnRzIHdpdGggdGhlXG5cdCAqXHRcInJlc2l6ZVwiIHN0YXRlIGVudW0gdmFsdWUgYW5kIHRoZSBleHBlY3RlZCBzaXplcy4gU2VlIHRoZSBcInJlc2l6ZVwiXG5cdCAqXHRlbnVtIHZhbHVlIGZvciBtb3JlIGRldGFpbHMgYWJvdXQgd2hhdCBpcyByZXF1aXJlZC4gVGhlIGNsaWVudFxuXHQgKlx0bXVzdCBhbHNvIGFja25vd2xlZGdlIGNvbmZpZ3VyZSBldmVudHMgdXNpbmcgXCJhY2tfY29uZmlndXJlXCIuIEFmdGVyXG5cdCAqXHR0aGUgcmVzaXplIGlzIGNvbXBsZXRlZCwgdGhlIGNsaWVudCB3aWxsIHJlY2VpdmUgYW5vdGhlciBcImNvbmZpZ3VyZVwiXG5cdCAqXHRldmVudCB3aXRob3V0IHRoZSByZXNpemUgc3RhdGUuXG5cdCAqXG5cdCAqXHRJZiB0cmlnZ2VyZWQsIHRoZSBzdXJmYWNlIGFsc28gd2lsbCBsb3NlIHRoZSBmb2N1cyBvZiB0aGUgZGV2aWNlXG5cdCAqXHQod2xfcG9pbnRlciwgd2xfdG91Y2gsIGV0YykgdXNlZCBmb3IgdGhlIHJlc2l6ZS4gSXQgaXMgdXAgdG8gdGhlXG5cdCAqXHRjb21wb3NpdG9yIHRvIHZpc3VhbGx5IGluZGljYXRlIHRoYXQgdGhlIHJlc2l6ZSBpcyB0YWtpbmcgcGxhY2UsXG5cdCAqXHRzdWNoIGFzIHVwZGF0aW5nIGEgcG9pbnRlciBjdXJzb3IsIGR1cmluZyB0aGUgcmVzaXplLiBUaGVyZSBpcyBub1xuXHQgKlx0Z3VhcmFudGVlIHRoYXQgdGhlIGRldmljZSBmb2N1cyB3aWxsIHJldHVybiB3aGVuIHRoZSByZXNpemUgaXNcblx0ICpcdGNvbXBsZXRlZC5cblx0ICpcblx0ICpcdFRoZSBlZGdlcyBwYXJhbWV0ZXIgc3BlY2lmaWVzIGhvdyB0aGUgc3VyZmFjZSBzaG91bGQgYmUgcmVzaXplZCxcblx0ICpcdGFuZCBpcyBvbmUgb2YgdGhlIHZhbHVlcyBvZiB0aGUgcmVzaXplX2VkZ2UgZW51bS4gVGhlIGNvbXBvc2l0b3Jcblx0ICpcdG1heSB1c2UgdGhpcyBpbmZvcm1hdGlvbiB0byB1cGRhdGUgdGhlIHN1cmZhY2UgcG9zaXRpb24gZm9yXG5cdCAqXHRleGFtcGxlIHdoZW4gZHJhZ2dpbmcgdGhlIHRvcCBsZWZ0IGNvcm5lci4gVGhlIGNvbXBvc2l0b3IgbWF5IGFsc29cblx0ICpcdHVzZSB0aGlzIGluZm9ybWF0aW9uIHRvIGFkYXB0IGl0cyBiZWhhdmlvciwgZS5nLiBjaG9vc2UgYW5cblx0ICpcdGFwcHJvcHJpYXRlIGN1cnNvciBpbWFnZS5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHsqfSBzZWF0IHRoZSB3bF9zZWF0IG9mIHRoZSB1c2VyIGV2ZW50IFxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2VyaWFsIHRoZSBzZXJpYWwgb2YgdGhlIHVzZXIgZXZlbnQgXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBlZGdlcyB3aGljaCBlZGdlIG9yIGNvcm5lciBpcyBiZWluZyBkcmFnZ2VkIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0cmVzaXplIChzZWF0LCBzZXJpYWwsIGVkZ2VzKSB7XG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgNiwgW29iamVjdChzZWF0KSwgdWludChzZXJpYWwpLCB1aW50KGVkZ2VzKV0pXG5cdH1cblxuXHQvKipcblx0ICpcblx0ICpcdFNldCBhIG1heGltdW0gc2l6ZSBmb3IgdGhlIHdpbmRvdy5cblx0ICpcblx0ICpcdFRoZSBjbGllbnQgY2FuIHNwZWNpZnkgYSBtYXhpbXVtIHNpemUgc28gdGhhdCB0aGUgY29tcG9zaXRvciBkb2VzXG5cdCAqXHRub3QgdHJ5IHRvIGNvbmZpZ3VyZSB0aGUgd2luZG93IGJleW9uZCB0aGlzIHNpemUuXG5cdCAqXG5cdCAqXHRUaGUgd2lkdGggYW5kIGhlaWdodCBhcmd1bWVudHMgYXJlIGluIHdpbmRvdyBnZW9tZXRyeSBjb29yZGluYXRlcy5cblx0ICpcdFNlZSB4ZGdfc3VyZmFjZS5zZXRfd2luZG93X2dlb21ldHJ5LlxuXHQgKlxuXHQgKlx0VmFsdWVzIHNldCBpbiB0aGlzIHdheSBhcmUgZG91YmxlLWJ1ZmZlcmVkLiBUaGV5IHdpbGwgZ2V0IGFwcGxpZWRcblx0ICpcdG9uIHRoZSBuZXh0IGNvbW1pdC5cblx0ICpcblx0ICpcdFRoZSBjb21wb3NpdG9yIGNhbiB1c2UgdGhpcyBpbmZvcm1hdGlvbiB0byBhbGxvdyBvciBkaXNhbGxvd1xuXHQgKlx0ZGlmZmVyZW50IHN0YXRlcyBsaWtlIG1heGltaXplIG9yIGZ1bGxzY3JlZW4gYW5kIGRyYXcgYWNjdXJhdGVcblx0ICpcdGFuaW1hdGlvbnMuXG5cdCAqXG5cdCAqXHRTaW1pbGFybHksIGEgdGlsaW5nIHdpbmRvdyBtYW5hZ2VyIG1heSB1c2UgdGhpcyBpbmZvcm1hdGlvbiB0b1xuXHQgKlx0cGxhY2UgYW5kIHJlc2l6ZSBjbGllbnQgd2luZG93cyBpbiBhIG1vcmUgZWZmZWN0aXZlIHdheS5cblx0ICpcblx0ICpcdFRoZSBjbGllbnQgc2hvdWxkIG5vdCByZWx5IG9uIHRoZSBjb21wb3NpdG9yIHRvIG9iZXkgdGhlIG1heGltdW1cblx0ICpcdHNpemUuIFRoZSBjb21wb3NpdG9yIG1heSBkZWNpZGUgdG8gaWdub3JlIHRoZSB2YWx1ZXMgc2V0IGJ5IHRoZVxuXHQgKlx0Y2xpZW50IGFuZCByZXF1ZXN0IGEgbGFyZ2VyIHNpemUuXG5cdCAqXG5cdCAqXHRJZiBuZXZlciBzZXQsIG9yIGEgdmFsdWUgb2YgemVybyBpbiB0aGUgcmVxdWVzdCwgbWVhbnMgdGhhdCB0aGVcblx0ICpcdGNsaWVudCBoYXMgbm8gZXhwZWN0ZWQgbWF4aW11bSBzaXplIGluIHRoZSBnaXZlbiBkaW1lbnNpb24uXG5cdCAqXHRBcyBhIHJlc3VsdCwgYSBjbGllbnQgd2lzaGluZyB0byByZXNldCB0aGUgbWF4aW11bSBzaXplXG5cdCAqXHR0byBhbiB1bnNwZWNpZmllZCBzdGF0ZSBjYW4gdXNlIHplcm8gZm9yIHdpZHRoIGFuZCBoZWlnaHQgaW4gdGhlXG5cdCAqXHRyZXF1ZXN0LlxuXHQgKlxuXHQgKlx0UmVxdWVzdGluZyBhIG1heGltdW0gc2l6ZSB0byBiZSBzbWFsbGVyIHRoYW4gdGhlIG1pbmltdW0gc2l6ZSBvZlxuXHQgKlx0YSBzdXJmYWNlIGlzIGlsbGVnYWwgYW5kIHdpbGwgcmVzdWx0IGluIGEgcHJvdG9jb2wgZXJyb3IuXG5cdCAqXG5cdCAqXHRUaGUgd2lkdGggYW5kIGhlaWdodCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB6ZXJvLiBVc2luZ1xuXHQgKlx0c3RyaWN0bHkgbmVnYXRpdmUgdmFsdWVzIGZvciB3aWR0aCBhbmQgaGVpZ2h0IHdpbGwgcmVzdWx0IGluIGFcblx0ICpcdHByb3RvY29sIGVycm9yLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0ICBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdHNldE1heFNpemUgKHdpZHRoLCBoZWlnaHQpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCA3LCBbaW50KHdpZHRoKSwgaW50KGhlaWdodCldKVxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRTZXQgYSBtaW5pbXVtIHNpemUgZm9yIHRoZSB3aW5kb3cuXG5cdCAqXG5cdCAqXHRUaGUgY2xpZW50IGNhbiBzcGVjaWZ5IGEgbWluaW11bSBzaXplIHNvIHRoYXQgdGhlIGNvbXBvc2l0b3IgZG9lc1xuXHQgKlx0bm90IHRyeSB0byBjb25maWd1cmUgdGhlIHdpbmRvdyBiZWxvdyB0aGlzIHNpemUuXG5cdCAqXG5cdCAqXHRUaGUgd2lkdGggYW5kIGhlaWdodCBhcmd1bWVudHMgYXJlIGluIHdpbmRvdyBnZW9tZXRyeSBjb29yZGluYXRlcy5cblx0ICpcdFNlZSB4ZGdfc3VyZmFjZS5zZXRfd2luZG93X2dlb21ldHJ5LlxuXHQgKlxuXHQgKlx0VmFsdWVzIHNldCBpbiB0aGlzIHdheSBhcmUgZG91YmxlLWJ1ZmZlcmVkLiBUaGV5IHdpbGwgZ2V0IGFwcGxpZWRcblx0ICpcdG9uIHRoZSBuZXh0IGNvbW1pdC5cblx0ICpcblx0ICpcdFRoZSBjb21wb3NpdG9yIGNhbiB1c2UgdGhpcyBpbmZvcm1hdGlvbiB0byBhbGxvdyBvciBkaXNhbGxvd1xuXHQgKlx0ZGlmZmVyZW50IHN0YXRlcyBsaWtlIG1heGltaXplIG9yIGZ1bGxzY3JlZW4gYW5kIGRyYXcgYWNjdXJhdGVcblx0ICpcdGFuaW1hdGlvbnMuXG5cdCAqXG5cdCAqXHRTaW1pbGFybHksIGEgdGlsaW5nIHdpbmRvdyBtYW5hZ2VyIG1heSB1c2UgdGhpcyBpbmZvcm1hdGlvbiB0b1xuXHQgKlx0cGxhY2UgYW5kIHJlc2l6ZSBjbGllbnQgd2luZG93cyBpbiBhIG1vcmUgZWZmZWN0aXZlIHdheS5cblx0ICpcblx0ICpcdFRoZSBjbGllbnQgc2hvdWxkIG5vdCByZWx5IG9uIHRoZSBjb21wb3NpdG9yIHRvIG9iZXkgdGhlIG1pbmltdW1cblx0ICpcdHNpemUuIFRoZSBjb21wb3NpdG9yIG1heSBkZWNpZGUgdG8gaWdub3JlIHRoZSB2YWx1ZXMgc2V0IGJ5IHRoZVxuXHQgKlx0Y2xpZW50IGFuZCByZXF1ZXN0IGEgc21hbGxlciBzaXplLlxuXHQgKlxuXHQgKlx0SWYgbmV2ZXIgc2V0LCBvciBhIHZhbHVlIG9mIHplcm8gaW4gdGhlIHJlcXVlc3QsIG1lYW5zIHRoYXQgdGhlXG5cdCAqXHRjbGllbnQgaGFzIG5vIGV4cGVjdGVkIG1pbmltdW0gc2l6ZSBpbiB0aGUgZ2l2ZW4gZGltZW5zaW9uLlxuXHQgKlx0QXMgYSByZXN1bHQsIGEgY2xpZW50IHdpc2hpbmcgdG8gcmVzZXQgdGhlIG1pbmltdW0gc2l6ZVxuXHQgKlx0dG8gYW4gdW5zcGVjaWZpZWQgc3RhdGUgY2FuIHVzZSB6ZXJvIGZvciB3aWR0aCBhbmQgaGVpZ2h0IGluIHRoZVxuXHQgKlx0cmVxdWVzdC5cblx0ICpcblx0ICpcdFJlcXVlc3RpbmcgYSBtaW5pbXVtIHNpemUgdG8gYmUgbGFyZ2VyIHRoYW4gdGhlIG1heGltdW0gc2l6ZSBvZlxuXHQgKlx0YSBzdXJmYWNlIGlzIGlsbGVnYWwgYW5kIHdpbGwgcmVzdWx0IGluIGEgcHJvdG9jb2wgZXJyb3IuXG5cdCAqXG5cdCAqXHRUaGUgd2lkdGggYW5kIGhlaWdodCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB6ZXJvLiBVc2luZ1xuXHQgKlx0c3RyaWN0bHkgbmVnYXRpdmUgdmFsdWVzIGZvciB3aWR0aCBhbmQgaGVpZ2h0IHdpbGwgcmVzdWx0IGluIGFcblx0ICpcdHByb3RvY29sIGVycm9yLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggIFxuXHQgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0ICBcblx0ICpcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdHNldE1pblNpemUgKHdpZHRoLCBoZWlnaHQpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCA4LCBbaW50KHdpZHRoKSwgaW50KGhlaWdodCldKVxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRNYXhpbWl6ZSB0aGUgc3VyZmFjZS5cblx0ICpcblx0ICpcdEFmdGVyIHJlcXVlc3RpbmcgdGhhdCB0aGUgc3VyZmFjZSBzaG91bGQgYmUgbWF4aW1pemVkLCB0aGUgY29tcG9zaXRvclxuXHQgKlx0d2lsbCByZXNwb25kIGJ5IGVtaXR0aW5nIGEgY29uZmlndXJlIGV2ZW50IHdpdGggdGhlIFwibWF4aW1pemVkXCIgc3RhdGVcblx0ICpcdGFuZCB0aGUgcmVxdWlyZWQgd2luZG93IGdlb21ldHJ5LiBUaGUgY2xpZW50IHNob3VsZCB0aGVuIHVwZGF0ZSBpdHNcblx0ICpcdGNvbnRlbnQsIGRyYXdpbmcgaXQgaW4gYSBtYXhpbWl6ZWQgc3RhdGUsIGkuZS4gd2l0aG91dCBzaGFkb3cgb3Igb3RoZXJcblx0ICpcdGRlY29yYXRpb24gb3V0c2lkZSBvZiB0aGUgd2luZG93IGdlb21ldHJ5LiBUaGUgY2xpZW50IG11c3QgYWxzb1xuXHQgKlx0YWNrbm93bGVkZ2UgdGhlIGNvbmZpZ3VyZSB3aGVuIGNvbW1pdHRpbmcgdGhlIG5ldyBjb250ZW50IChzZWVcblx0ICpcdGFja19jb25maWd1cmUpLlxuXHQgKlxuXHQgKlx0SXQgaXMgdXAgdG8gdGhlIGNvbXBvc2l0b3IgdG8gZGVjaWRlIGhvdyBhbmQgd2hlcmUgdG8gbWF4aW1pemUgdGhlXG5cdCAqXHRzdXJmYWNlLCBmb3IgZXhhbXBsZSB3aGljaCBvdXRwdXQgYW5kIHdoYXQgcmVnaW9uIG9mIHRoZSBzY3JlZW4gc2hvdWxkXG5cdCAqXHRiZSB1c2VkLlxuXHQgKlxuXHQgKlx0SWYgdGhlIHN1cmZhY2Ugd2FzIGFscmVhZHkgbWF4aW1pemVkLCB0aGUgY29tcG9zaXRvciB3aWxsIHN0aWxsIGVtaXRcblx0ICpcdGEgY29uZmlndXJlIGV2ZW50IHdpdGggdGhlIFwibWF4aW1pemVkXCIgc3RhdGUuXG5cdCAqXG5cdCAqXHRJZiB0aGUgc3VyZmFjZSBpcyBpbiBhIGZ1bGxzY3JlZW4gc3RhdGUsIHRoaXMgcmVxdWVzdCBoYXMgbm8gZGlyZWN0XG5cdCAqXHRlZmZlY3QuIEl0IHdpbGwgYWx0ZXIgdGhlIHN0YXRlIHRoZSBzdXJmYWNlIGlzIHJldHVybmVkIHRvIHdoZW5cblx0ICpcdHVubWF4aW1pemVkIGlmIG5vdCBvdmVycmlkZGVuIGJ5IHRoZSBjb21wb3NpdG9yLlxuXHQgKiAgICAgIFxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0c2V0TWF4aW1pemVkICgpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCA5LCBbXSlcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0VW5tYXhpbWl6ZSB0aGUgc3VyZmFjZS5cblx0ICpcblx0ICpcdEFmdGVyIHJlcXVlc3RpbmcgdGhhdCB0aGUgc3VyZmFjZSBzaG91bGQgYmUgdW5tYXhpbWl6ZWQsIHRoZSBjb21wb3NpdG9yXG5cdCAqXHR3aWxsIHJlc3BvbmQgYnkgZW1pdHRpbmcgYSBjb25maWd1cmUgZXZlbnQgd2l0aG91dCB0aGUgXCJtYXhpbWl6ZWRcIlxuXHQgKlx0c3RhdGUuIElmIGF2YWlsYWJsZSwgdGhlIGNvbXBvc2l0b3Igd2lsbCBpbmNsdWRlIHRoZSB3aW5kb3cgZ2VvbWV0cnlcblx0ICpcdGRpbWVuc2lvbnMgdGhlIHdpbmRvdyBoYWQgcHJpb3IgdG8gYmVpbmcgbWF4aW1pemVkIGluIHRoZSBjb25maWd1cmVcblx0ICpcdGV2ZW50LiBUaGUgY2xpZW50IG11c3QgdGhlbiB1cGRhdGUgaXRzIGNvbnRlbnQsIGRyYXdpbmcgaXQgaW4gYVxuXHQgKlx0cmVndWxhciBzdGF0ZSwgaS5lLiBwb3RlbnRpYWxseSB3aXRoIHNoYWRvdywgZXRjLiBUaGUgY2xpZW50IG11c3QgYWxzb1xuXHQgKlx0YWNrbm93bGVkZ2UgdGhlIGNvbmZpZ3VyZSB3aGVuIGNvbW1pdHRpbmcgdGhlIG5ldyBjb250ZW50IChzZWVcblx0ICpcdGFja19jb25maWd1cmUpLlxuXHQgKlxuXHQgKlx0SXQgaXMgdXAgdG8gdGhlIGNvbXBvc2l0b3IgdG8gcG9zaXRpb24gdGhlIHN1cmZhY2UgYWZ0ZXIgaXQgd2FzXG5cdCAqXHR1bm1heGltaXplZDsgdXN1YWxseSB0aGUgcG9zaXRpb24gdGhlIHN1cmZhY2UgaGFkIGJlZm9yZSBtYXhpbWl6aW5nLCBpZlxuXHQgKlx0YXBwbGljYWJsZS5cblx0ICpcblx0ICpcdElmIHRoZSBzdXJmYWNlIHdhcyBhbHJlYWR5IG5vdCBtYXhpbWl6ZWQsIHRoZSBjb21wb3NpdG9yIHdpbGwgc3RpbGxcblx0ICpcdGVtaXQgYSBjb25maWd1cmUgZXZlbnQgd2l0aG91dCB0aGUgXCJtYXhpbWl6ZWRcIiBzdGF0ZS5cblx0ICpcblx0ICpcdElmIHRoZSBzdXJmYWNlIGlzIGluIGEgZnVsbHNjcmVlbiBzdGF0ZSwgdGhpcyByZXF1ZXN0IGhhcyBubyBkaXJlY3Rcblx0ICpcdGVmZmVjdC4gSXQgd2lsbCBhbHRlciB0aGUgc3RhdGUgdGhlIHN1cmZhY2UgaXMgcmV0dXJuZWQgdG8gd2hlblxuXHQgKlx0dW5tYXhpbWl6ZWQgaWYgbm90IG92ZXJyaWRkZW4gYnkgdGhlIGNvbXBvc2l0b3IuXG5cdCAqICAgICAgXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHR1bnNldE1heGltaXplZCAoKSB7XG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgMTAsIFtdKVxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRNYWtlIHRoZSBzdXJmYWNlIGZ1bGxzY3JlZW4uXG5cdCAqXG5cdCAqXHRBZnRlciByZXF1ZXN0aW5nIHRoYXQgdGhlIHN1cmZhY2Ugc2hvdWxkIGJlIGZ1bGxzY3JlZW5lZCwgdGhlXG5cdCAqXHRjb21wb3NpdG9yIHdpbGwgcmVzcG9uZCBieSBlbWl0dGluZyBhIGNvbmZpZ3VyZSBldmVudCB3aXRoIHRoZVxuXHQgKlx0XCJmdWxsc2NyZWVuXCIgc3RhdGUgYW5kIHRoZSBmdWxsc2NyZWVuIHdpbmRvdyBnZW9tZXRyeS4gVGhlIGNsaWVudCBtdXN0XG5cdCAqXHRhbHNvIGFja25vd2xlZGdlIHRoZSBjb25maWd1cmUgd2hlbiBjb21taXR0aW5nIHRoZSBuZXcgY29udGVudCAoc2VlXG5cdCAqXHRhY2tfY29uZmlndXJlKS5cblx0ICpcblx0ICpcdFRoZSBvdXRwdXQgcGFzc2VkIGJ5IHRoZSByZXF1ZXN0IGluZGljYXRlcyB0aGUgY2xpZW50J3MgcHJlZmVyZW5jZSBhc1xuXHQgKlx0dG8gd2hpY2ggZGlzcGxheSBpdCBzaG91bGQgYmUgc2V0IGZ1bGxzY3JlZW4gb24uIElmIHRoaXMgdmFsdWUgaXMgTlVMTCxcblx0ICpcdGl0J3MgdXAgdG8gdGhlIGNvbXBvc2l0b3IgdG8gY2hvb3NlIHdoaWNoIGRpc3BsYXkgd2lsbCBiZSB1c2VkIHRvIG1hcFxuXHQgKlx0dGhpcyBzdXJmYWNlLlxuXHQgKlxuXHQgKlx0SWYgdGhlIHN1cmZhY2UgZG9lc24ndCBjb3ZlciB0aGUgd2hvbGUgb3V0cHV0LCB0aGUgY29tcG9zaXRvciB3aWxsXG5cdCAqXHRwb3NpdGlvbiB0aGUgc3VyZmFjZSBpbiB0aGUgY2VudGVyIG9mIHRoZSBvdXRwdXQgYW5kIGNvbXBlbnNhdGUgd2l0aFxuXHQgKlx0d2l0aCBib3JkZXIgZmlsbCBjb3ZlcmluZyB0aGUgcmVzdCBvZiB0aGUgb3V0cHV0LiBUaGUgY29udGVudCBvZiB0aGVcblx0ICpcdGJvcmRlciBmaWxsIGlzIHVuZGVmaW5lZCwgYnV0IHNob3VsZCBiZSBhc3N1bWVkIHRvIGJlIGluIHNvbWUgd2F5IHRoYXRcblx0ICpcdGF0dGVtcHRzIHRvIGJsZW5kIGludG8gdGhlIHN1cnJvdW5kaW5nIGFyZWEgKGUuZy4gc29saWQgYmxhY2spLlxuXHQgKlxuXHQgKlx0SWYgdGhlIGZ1bGxzY3JlZW5lZCBzdXJmYWNlIGlzIG5vdCBvcGFxdWUsIHRoZSBjb21wb3NpdG9yIG11c3QgbWFrZVxuXHQgKlx0c3VyZSB0aGF0IG90aGVyIHNjcmVlbiBjb250ZW50IG5vdCBwYXJ0IG9mIHRoZSBzYW1lIHN1cmZhY2UgdHJlZSAobWFkZVxuXHQgKlx0dXAgb2Ygc3Vic3VyZmFjZXMsIHBvcHVwcyBvciBzaW1pbGFybHkgY291cGxlZCBzdXJmYWNlcykgYXJlIG5vdFxuXHQgKlx0dmlzaWJsZSBiZWxvdyB0aGUgZnVsbHNjcmVlbmVkIHN1cmZhY2UuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7Pyp9IG91dHB1dCAgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRzZXRGdWxsc2NyZWVuIChvdXRwdXQpIHtcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCAxMSwgW29iamVjdE9wdGlvbmFsKG91dHB1dCldKVxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRNYWtlIHRoZSBzdXJmYWNlIG5vIGxvbmdlciBmdWxsc2NyZWVuLlxuXHQgKlxuXHQgKlx0QWZ0ZXIgcmVxdWVzdGluZyB0aGF0IHRoZSBzdXJmYWNlIHNob3VsZCBiZSB1bmZ1bGxzY3JlZW5lZCwgdGhlXG5cdCAqXHRjb21wb3NpdG9yIHdpbGwgcmVzcG9uZCBieSBlbWl0dGluZyBhIGNvbmZpZ3VyZSBldmVudCB3aXRob3V0IHRoZVxuXHQgKlx0XCJmdWxsc2NyZWVuXCIgc3RhdGUuXG5cdCAqXG5cdCAqXHRNYWtpbmcgYSBzdXJmYWNlIHVuZnVsbHNjcmVlbiBzZXRzIHN0YXRlcyBmb3IgdGhlIHN1cmZhY2UgYmFzZWQgb24gdGhlIGZvbGxvd2luZzpcblx0ICpcdCogdGhlIHN0YXRlKHMpIGl0IG1heSBoYXZlIGhhZCBiZWZvcmUgYmVjb21pbmcgZnVsbHNjcmVlblxuXHQgKlx0KiBhbnkgc3RhdGUocykgZGVjaWRlZCBieSB0aGUgY29tcG9zaXRvclxuXHQgKlx0KiBhbnkgc3RhdGUocykgcmVxdWVzdGVkIGJ5IHRoZSBjbGllbnQgd2hpbGUgdGhlIHN1cmZhY2Ugd2FzIGZ1bGxzY3JlZW5cblx0ICpcblx0ICpcdFRoZSBjb21wb3NpdG9yIG1heSBpbmNsdWRlIHRoZSBwcmV2aW91cyB3aW5kb3cgZ2VvbWV0cnkgZGltZW5zaW9ucyBpblxuXHQgKlx0dGhlIGNvbmZpZ3VyZSBldmVudCwgaWYgYXBwbGljYWJsZS5cblx0ICpcblx0ICpcdFRoZSBjbGllbnQgbXVzdCBhbHNvIGFja25vd2xlZGdlIHRoZSBjb25maWd1cmUgd2hlbiBjb21taXR0aW5nIHRoZSBuZXdcblx0ICpcdGNvbnRlbnQgKHNlZSBhY2tfY29uZmlndXJlKS5cblx0ICogICAgICBcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdHVuc2V0RnVsbHNjcmVlbiAoKSB7XG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgMTIsIFtdKVxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRSZXF1ZXN0IHRoYXQgdGhlIGNvbXBvc2l0b3IgbWluaW1pemUgeW91ciBzdXJmYWNlLiBUaGVyZSBpcyBub1xuXHQgKlx0d2F5IHRvIGtub3cgaWYgdGhlIHN1cmZhY2UgaXMgY3VycmVudGx5IG1pbmltaXplZCwgbm9yIGlzIHRoZXJlXG5cdCAqXHRhbnkgd2F5IHRvIHVuc2V0IG1pbmltaXphdGlvbiBvbiB0aGlzIHN1cmZhY2UuXG5cdCAqXG5cdCAqXHRJZiB5b3UgYXJlIGxvb2tpbmcgdG8gdGhyb3R0bGUgcmVkcmF3aW5nIHdoZW4gbWluaW1pemVkLCBwbGVhc2Vcblx0ICpcdGluc3RlYWQgdXNlIHRoZSB3bF9zdXJmYWNlLmZyYW1lIGV2ZW50IGZvciB0aGlzLCBhcyB0aGlzIHdpbGxcblx0ICpcdGFsc28gd29yayB3aXRoIGxpdmUgcHJldmlld3Mgb24gd2luZG93cyBpbiBBbHQtVGFiLCBFeHBvc2Ugb3Jcblx0ICpcdHNpbWlsYXIgY29tcG9zaXRvciBmZWF0dXJlcy5cblx0ICogICAgICBcblx0ICogQHNpbmNlIDFcblx0ICpcblx0ICovXG5cdHNldE1pbmltaXplZCAoKSB7XG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgMTMsIFtdKVxuXHR9XG5cblx0LyoqXG5cdCAqIERvIG5vdCBjb25zdHJ1Y3QgcHJveGllcyBkaXJlY3RseS4gSW5zdGVhZCB1c2Ugb25lIG9mIHRoZSBmYWN0b3J5IG1ldGhvZHMgZnJvbSBvdGhlciBwcm94aWVzLlxuXHQgKkBwYXJhbSB7RGlzcGxheX1kaXNwbGF5XG5cdCAqQHBhcmFtIHtDb25uZWN0aW9ufWNvbm5lY3Rpb25cblx0ICpAcGFyYW0ge251bWJlcn1pZFxuXHQgKi9cblx0Y29uc3RydWN0b3IgKGRpc3BsYXksIGNvbm5lY3Rpb24sIGlkKSB7XG5cdFx0c3VwZXIoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge1hkZ1RvcGxldmVsRXZlbnRzfG51bGx9XG5cdFx0ICovXG5cdFx0dGhpcy5saXN0ZW5lciA9IG51bGxcblx0fVxuXG5cdGFzeW5jIFswXSAobWVzc2FnZSkge1xuXHRcdGF3YWl0IHRoaXMubGlzdGVuZXIuY29uZmlndXJlKGkobWVzc2FnZSksIGkobWVzc2FnZSksIGEobWVzc2FnZSwgZmFsc2UpKVxuXHR9XG5cblx0YXN5bmMgWzFdIChtZXNzYWdlKSB7XG5cdFx0YXdhaXQgdGhpcy5saXN0ZW5lci5jbG9zZSgpXG5cdH1cblxufVxuWGRnVG9wbGV2ZWxQcm94eS5wcm90b2NvbE5hbWUgPSAneGRnX3RvcGxldmVsJ1xuXG5YZGdUb3BsZXZlbFByb3h5LlJlc2l6ZUVkZ2UgPSB7XG4gIC8qKlxuICAgKiBcbiAgICovXG4gIG5vbmU6IDAsXG4gIC8qKlxuICAgKiBcbiAgICovXG4gIHRvcDogMSxcbiAgLyoqXG4gICAqIFxuICAgKi9cbiAgYm90dG9tOiAyLFxuICAvKipcbiAgICogXG4gICAqL1xuICBsZWZ0OiA0LFxuICAvKipcbiAgICogXG4gICAqL1xuICB0b3BMZWZ0OiA1LFxuICAvKipcbiAgICogXG4gICAqL1xuICBib3R0b21MZWZ0OiA2LFxuICAvKipcbiAgICogXG4gICAqL1xuICByaWdodDogOCxcbiAgLyoqXG4gICAqIFxuICAgKi9cbiAgdG9wUmlnaHQ6IDksXG4gIC8qKlxuICAgKiBcbiAgICovXG4gIGJvdHRvbVJpZ2h0OiAxMFxufVxuXG5YZGdUb3BsZXZlbFByb3h5LlN0YXRlID0ge1xuICAvKipcbiAgICogdGhlIHN1cmZhY2UgaXMgbWF4aW1pemVkXG4gICAqL1xuICBtYXhpbWl6ZWQ6IDEsXG4gIC8qKlxuICAgKiB0aGUgc3VyZmFjZSBpcyBmdWxsc2NyZWVuXG4gICAqL1xuICBmdWxsc2NyZWVuOiAyLFxuICAvKipcbiAgICogdGhlIHN1cmZhY2UgaXMgYmVpbmcgcmVzaXplZFxuICAgKi9cbiAgcmVzaXppbmc6IDMsXG4gIC8qKlxuICAgKiB0aGUgc3VyZmFjZSBpcyBub3cgYWN0aXZhdGVkXG4gICAqL1xuICBhY3RpdmF0ZWQ6IDRcbn1cblxuZXhwb3J0IGRlZmF1bHQgWGRnVG9wbGV2ZWxQcm94eVxuIiwiLypcbiAqXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAwOC0yMDEzIEtyaXN0aWFuIEjDuGdzYmVyZ1xuICogICAgQ29weXJpZ2h0IMKpIDIwMTMgICAgICBSYWZhZWwgQW50b2dub2xsaVxuICogICAgQ29weXJpZ2h0IMKpIDIwMTMgICAgICBKYXNwZXIgU3QuIFBpZXJyZVxuICogICAgQ29weXJpZ2h0IMKpIDIwMTAtMjAxMyBJbnRlbCBDb3Jwb3JhdGlvblxuICogICAgQ29weXJpZ2h0IMKpIDIwMTUtMjAxNyBTYW1zdW5nIEVsZWN0cm9uaWNzIENvLiwgTHRkXG4gKiAgICBDb3B5cmlnaHQgwqkgMjAxNS0yMDE3IFJlZCBIYXQgSW5jLlxuICpcbiAqICAgIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiAgICBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiAgICB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiAgICB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqICAgIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogICAgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiAgICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSAoaW5jbHVkaW5nIHRoZSBuZXh0XG4gKiAgICBwYXJhZ3JhcGgpIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlXG4gKiAgICBTb2Z0d2FyZS5cbiAqXG4gKiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiAgICBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqICAgIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuICBJTiBOTyBFVkVOVCBTSEFMTFxuICogICAgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqICAgIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4gKiAgICBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSXG4gKiAgICBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKiAgXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJmYWNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFhkZ1dtQmFzZUV2ZW50cyB7XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRUaGUgcGluZyBldmVudCBhc2tzIHRoZSBjbGllbnQgaWYgaXQncyBzdGlsbCBhbGl2ZS4gUGFzcyB0aGVcblx0ICpcdHNlcmlhbCBzcGVjaWZpZWQgaW4gdGhlIGV2ZW50IGJhY2sgdG8gdGhlIGNvbXBvc2l0b3IgYnkgc2VuZGluZ1xuXHQgKlx0YSBcInBvbmdcIiByZXF1ZXN0IGJhY2sgd2l0aCB0aGUgc3BlY2lmaWVkIHNlcmlhbC4gU2VlIHhkZ193bV9iYXNlLnBpbmcuXG5cdCAqXG5cdCAqXHRDb21wb3NpdG9ycyBjYW4gdXNlIHRoaXMgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjbGllbnQgaXMgc3RpbGxcblx0ICpcdGFsaXZlLiBJdCdzIHVuc3BlY2lmaWVkIHdoYXQgd2lsbCBoYXBwZW4gaWYgdGhlIGNsaWVudCBkb2Vzbid0XG5cdCAqXHRyZXNwb25kIHRvIHRoZSBwaW5nIHJlcXVlc3QsIG9yIGluIHdoYXQgdGltZWZyYW1lLiBDbGllbnRzIHNob3VsZFxuXHQgKlx0dHJ5IHRvIHJlc3BvbmQgaW4gYSByZWFzb25hYmxlIGFtb3VudCBvZiB0aW1lLlxuXHQgKlxuXHQgKlx0QSBjb21wb3NpdG9yIGlzIGZyZWUgdG8gcGluZyBpbiBhbnkgd2F5IGl0IHdhbnRzLCBidXQgYSBjbGllbnQgbXVzdFxuXHQgKlx0YWx3YXlzIHJlc3BvbmQgdG8gYW55IHhkZ193bV9iYXNlIG9iamVjdCBpdCBjcmVhdGVkLlxuXHQgKiAgICAgIFxuXHQgKlxuXHQgKiBAcGFyYW0ge251bWJlcn0gc2VyaWFsIHBhc3MgdGhpcyB0byB0aGUgcG9uZyByZXF1ZXN0IFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0cGluZyhzZXJpYWwpIHt9XG59XG5cbiIsIi8qXG4gKlxuICogICAgQ29weXJpZ2h0IMKpIDIwMDgtMjAxMyBLcmlzdGlhbiBIw7hnc2JlcmdcbiAqICAgIENvcHlyaWdodCDCqSAyMDEzICAgICAgUmFmYWVsIEFudG9nbm9sbGlcbiAqICAgIENvcHlyaWdodCDCqSAyMDEzICAgICAgSmFzcGVyIFN0LiBQaWVycmVcbiAqICAgIENvcHlyaWdodCDCqSAyMDEwLTIwMTMgSW50ZWwgQ29ycG9yYXRpb25cbiAqICAgIENvcHlyaWdodCDCqSAyMDE1LTIwMTcgU2Ftc3VuZyBFbGVjdHJvbmljcyBDby4sIEx0ZFxuICogICAgQ29weXJpZ2h0IMKpIDIwMTUtMjAxNyBSZWQgSGF0IEluYy5cbiAqXG4gKiAgICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuICogICAgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuICogICAgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvblxuICogICAgdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsXG4gKiAgICBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAqICAgIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgKGluY2x1ZGluZyB0aGUgbmV4dFxuICogICAgcGFyYWdyYXBoKSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZVxuICogICAgU29mdHdhcmUuXG4gKlxuICogICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogICAgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiAgICBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiAgSU4gTk8gRVZFTlQgU0hBTExcbiAqICAgIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiAgICBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogICAgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUlxuICogICAgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICogIFxuICovXG5cbmltcG9ydCB7IENvbm5lY3Rpb24gfSBmcm9tICd3ZXN0ZmllbGQtcnVudGltZS1jb21tb24nXG5jb25zdCB7IHVpbnQsIHVpbnRPcHRpb25hbCwgaW50LCBpbnRPcHRpb25hbCwgZml4ZWQsIFxuXHRmaXhlZE9wdGlvbmFsLCBvYmplY3QsIG9iamVjdE9wdGlvbmFsLCBuZXdPYmplY3QsIHN0cmluZywgXG5cdHN0cmluZ09wdGlvbmFsLCBhcnJheSwgYXJyYXlPcHRpb25hbCwgXG5cdGZpbGVEZXNjcmlwdG9yT3B0aW9uYWwsIGZpbGVEZXNjcmlwdG9yLCBcbmgsIHUsIGksIGYsIG8sIG4sIHMsIGEgfSA9IENvbm5lY3Rpb25cbmltcG9ydCBQcm94eSBmcm9tICcuL1Byb3h5J1xuaW1wb3J0IFhkZ1Bvc2l0aW9uZXJQcm94eSBmcm9tICcuL1hkZ1Bvc2l0aW9uZXJQcm94eSdcbmltcG9ydCBYZGdTdXJmYWNlUHJveHkgZnJvbSAnLi9YZGdTdXJmYWNlUHJveHknXG5cbi8qKlxuICpcbiAqICAgICAgVGhlIHhkZ193bV9iYXNlIGludGVyZmFjZSBpcyBleHBvc2VkIGFzIGEgZ2xvYmFsIG9iamVjdCBlbmFibGluZyBjbGllbnRzXG4gKiAgICAgIHRvIHR1cm4gdGhlaXIgd2xfc3VyZmFjZXMgaW50byB3aW5kb3dzIGluIGEgZGVza3RvcCBlbnZpcm9ubWVudC4gSXRcbiAqICAgICAgZGVmaW5lcyB0aGUgYmFzaWMgZnVuY3Rpb25hbGl0eSBuZWVkZWQgZm9yIGNsaWVudHMgYW5kIHRoZSBjb21wb3NpdG9yIHRvXG4gKiAgICAgIGNyZWF0ZSB3aW5kb3dzIHRoYXQgY2FuIGJlIGRyYWdnZWQsIHJlc2l6ZWQsIG1heGltaXplZCwgZXRjLCBhcyB3ZWxsIGFzXG4gKiAgICAgIGNyZWF0aW5nIHRyYW5zaWVudCB3aW5kb3dzIHN1Y2ggYXMgcG9wdXAgbWVudXMuXG4gKiAgICBcbiAqL1xuY2xhc3MgWGRnV21CYXNlUHJveHkgZXh0ZW5kcyBQcm94eSB7XG5cblx0LyoqXG5cdCAqXG5cdCAqXHREZXN0cm95IHRoaXMgeGRnX3dtX2Jhc2Ugb2JqZWN0LlxuXHQgKlxuXHQgKlx0RGVzdHJveWluZyBhIGJvdW5kIHhkZ193bV9iYXNlIG9iamVjdCB3aGlsZSB0aGVyZSBhcmUgc3VyZmFjZXNcblx0ICpcdHN0aWxsIGFsaXZlIGNyZWF0ZWQgYnkgdGhpcyB4ZGdfd21fYmFzZSBvYmplY3QgaW5zdGFuY2UgaXMgaWxsZWdhbFxuXHQgKlx0YW5kIHdpbGwgcmVzdWx0IGluIGEgcHJvdG9jb2wgZXJyb3IuXG5cdCAqICAgICAgXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRkZXN0cm95ICgpIHtcblx0XHRzdXBlci5kZXN0cm95KClcblx0XHR0aGlzLl9tYXJzaGFsbCh0aGlzLmlkLCAwLCBbXSlcblx0fVxuXG5cdC8qKlxuXHQgKlxuXHQgKlx0Q3JlYXRlIGEgcG9zaXRpb25lciBvYmplY3QuIEEgcG9zaXRpb25lciBvYmplY3QgaXMgdXNlZCB0byBwb3NpdGlvblxuXHQgKlx0c3VyZmFjZXMgcmVsYXRpdmUgdG8gc29tZSBwYXJlbnQgc3VyZmFjZS4gU2VlIHRoZSBpbnRlcmZhY2UgZGVzY3JpcHRpb25cblx0ICpcdGFuZCB4ZGdfc3VyZmFjZS5nZXRfcG9wdXAgZm9yIGRldGFpbHMuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEByZXR1cm4ge1hkZ1Bvc2l0aW9uZXJQcm94eX0gIFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0Y3JlYXRlUG9zaXRpb25lciAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hcnNoYWxsQ29uc3RydWN0b3IodGhpcy5pZCwgMSwgWGRnUG9zaXRpb25lclByb3h5LCBbbmV3T2JqZWN0KCldKVxuXHR9XG5cblx0LyoqXG5cdCAqXG5cdCAqXHRUaGlzIGNyZWF0ZXMgYW4geGRnX3N1cmZhY2UgZm9yIHRoZSBnaXZlbiBzdXJmYWNlLiBXaGlsZSB4ZGdfc3VyZmFjZVxuXHQgKlx0aXRzZWxmIGlzIG5vdCBhIHJvbGUsIHRoZSBjb3JyZXNwb25kaW5nIHN1cmZhY2UgbWF5IG9ubHkgYmUgYXNzaWduZWRcblx0ICpcdGEgcm9sZSBleHRlbmRpbmcgeGRnX3N1cmZhY2UsIHN1Y2ggYXMgeGRnX3RvcGxldmVsIG9yIHhkZ19wb3B1cC5cblx0ICpcblx0ICpcdFRoaXMgY3JlYXRlcyBhbiB4ZGdfc3VyZmFjZSBmb3IgdGhlIGdpdmVuIHN1cmZhY2UuIEFuIHhkZ19zdXJmYWNlIGlzXG5cdCAqXHR1c2VkIGFzIGJhc2lzIHRvIGRlZmluZSBhIHJvbGUgdG8gYSBnaXZlbiBzdXJmYWNlLCBzdWNoIGFzIHhkZ190b3BsZXZlbFxuXHQgKlx0b3IgeGRnX3BvcHVwLiBJdCBhbHNvIG1hbmFnZXMgZnVuY3Rpb25hbGl0eSBzaGFyZWQgYmV0d2VlbiB4ZGdfc3VyZmFjZVxuXHQgKlx0YmFzZWQgc3VyZmFjZSByb2xlcy5cblx0ICpcblx0ICpcdFNlZSB0aGUgZG9jdW1lbnRhdGlvbiBvZiB4ZGdfc3VyZmFjZSBmb3IgbW9yZSBkZXRhaWxzIGFib3V0IHdoYXQgYW5cblx0ICpcdHhkZ19zdXJmYWNlIGlzIGFuZCBob3cgaXQgaXMgdXNlZC5cblx0ICogICAgICBcblx0ICpcblx0ICogQHBhcmFtIHsqfSBzdXJmYWNlICBcblx0ICogQHJldHVybiB7WGRnU3VyZmFjZVByb3h5fSAgXG5cdCAqXG5cdCAqIEBzaW5jZSAxXG5cdCAqXG5cdCAqL1xuXHRnZXRYZGdTdXJmYWNlIChzdXJmYWNlKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hcnNoYWxsQ29uc3RydWN0b3IodGhpcy5pZCwgMiwgWGRnU3VyZmFjZVByb3h5LCBbbmV3T2JqZWN0KCksIG9iamVjdChzdXJmYWNlKV0pXG5cdH1cblxuXHQvKipcblx0ICpcblx0ICpcdEEgY2xpZW50IG11c3QgcmVzcG9uZCB0byBhIHBpbmcgZXZlbnQgd2l0aCBhIHBvbmcgcmVxdWVzdCBvclxuXHQgKlx0dGhlIGNsaWVudCBtYXkgYmUgZGVlbWVkIHVucmVzcG9uc2l2ZS4gU2VlIHhkZ193bV9iYXNlLnBpbmcuXG5cdCAqICAgICAgXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBzZXJpYWwgc2VyaWFsIG9mIHRoZSBwaW5nIGV2ZW50IFxuXHQgKlxuXHQgKiBAc2luY2UgMVxuXHQgKlxuXHQgKi9cblx0cG9uZyAoc2VyaWFsKSB7XG5cdFx0dGhpcy5fbWFyc2hhbGwodGhpcy5pZCwgMywgW3VpbnQoc2VyaWFsKV0pXG5cdH1cblxuXHQvKipcblx0ICogRG8gbm90IGNvbnN0cnVjdCBwcm94aWVzIGRpcmVjdGx5LiBJbnN0ZWFkIHVzZSBvbmUgb2YgdGhlIGZhY3RvcnkgbWV0aG9kcyBmcm9tIG90aGVyIHByb3hpZXMuXG5cdCAqQHBhcmFtIHtEaXNwbGF5fWRpc3BsYXlcblx0ICpAcGFyYW0ge0Nvbm5lY3Rpb259Y29ubmVjdGlvblxuXHQgKkBwYXJhbSB7bnVtYmVyfWlkXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciAoZGlzcGxheSwgY29ubmVjdGlvbiwgaWQpIHtcblx0XHRzdXBlcihkaXNwbGF5LCBjb25uZWN0aW9uLCBpZClcblx0XHQvKipcblx0XHQgKiBAdHlwZSB7WGRnV21CYXNlRXZlbnRzfG51bGx9XG5cdFx0ICovXG5cdFx0dGhpcy5saXN0ZW5lciA9IG51bGxcblx0fVxuXG5cdGFzeW5jIFswXSAobWVzc2FnZSkge1xuXHRcdGF3YWl0IHRoaXMubGlzdGVuZXIucGluZyh1KG1lc3NhZ2UpKVxuXHR9XG5cbn1cblhkZ1dtQmFzZVByb3h5LnByb3RvY29sTmFtZSA9ICd4ZGdfd21fYmFzZSdcblxuWGRnV21CYXNlUHJveHkuRXJyb3IgPSB7XG4gIC8qKlxuICAgKiBnaXZlbiB3bF9zdXJmYWNlIGhhcyBhbm90aGVyIHJvbGVcbiAgICovXG4gIHJvbGU6IDAsXG4gIC8qKlxuICAgKiB4ZGdfd21fYmFzZSB3YXMgZGVzdHJveWVkIGJlZm9yZSBjaGlsZHJlblxuICAgKi9cbiAgZGVmdW5jdFN1cmZhY2VzOiAxLFxuICAvKipcbiAgICogdGhlIGNsaWVudCB0cmllZCB0byBtYXAgb3IgZGVzdHJveSBhIG5vbi10b3Btb3N0IHBvcHVwXG4gICAqL1xuICBub3RUaGVUb3Btb3N0UG9wdXA6IDIsXG4gIC8qKlxuICAgKiB0aGUgY2xpZW50IHNwZWNpZmllZCBhbiBpbnZhbGlkIHBvcHVwIHBhcmVudCBzdXJmYWNlXG4gICAqL1xuICBpbnZhbGlkUG9wdXBQYXJlbnQ6IDMsXG4gIC8qKlxuICAgKiB0aGUgY2xpZW50IHByb3ZpZGVkIGFuIGludmFsaWQgc3VyZmFjZSBzdGF0ZVxuICAgKi9cbiAgaW52YWxpZFN1cmZhY2VTdGF0ZTogNCxcbiAgLyoqXG4gICAqIHRoZSBjbGllbnQgcHJvdmlkZWQgYW4gaW52YWxpZCBwb3NpdGlvbmVyXG4gICAqL1xuICBpbnZhbGlkUG9zaXRpb25lcjogNVxufVxuXG5leHBvcnQgZGVmYXVsdCBYZGdXbUJhc2VQcm94eVxuIiwiaW1wb3J0IENvbm5lY3Rpb24gZnJvbSAnLi9zcmMvQ29ubmVjdGlvbidcbmltcG9ydCBGaXhlZCBmcm9tICcuL3NyYy9GaXhlZCdcbmltcG9ydCBXZWJGRCBmcm9tICcuL3NyYy9XZWJGRCdcbmltcG9ydCBXbE9iamVjdCBmcm9tICcuL3NyYy9XbE9iamVjdCdcblxuZXhwb3J0IHtcbiAgQ29ubmVjdGlvbixcbiAgRml4ZWQsXG4gIFdlYkZELFxuICBXbE9iamVjdFxufSIsIi8qXG5NSVQgTGljZW5zZVxuXG5Db3B5cmlnaHQgKGMpIDIwMTcgRXJpayBEZSBSaWpja2VcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuU09GVFdBUkUuXG4qL1xuXG4ndXNlIHN0cmljdCdcblxuaW1wb3J0IEZpeGVkIGZyb20gJy4vRml4ZWQnXG5cbmNsYXNzIENvbm5lY3Rpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFyZ1xuICAgKiBAcmV0dXJucyB7e3ZhbHVlOiBudW1iZXIsIHR5cGU6ICd1Jywgc2l6ZTogbnVtYmVyLCBvcHRpb25hbDogYm9vbGVhbiwgX21hcnNoYWxsQXJnOiBmdW5jdGlvbih7YnVmZmVyOiBBcnJheUJ1ZmZlciwgZmRzOiBBcnJheTxXZWJGRD4sIGJ1ZmZlck9mZnNldDogbnVtYmVyfSk6dm9pZH19XG4gICAqL1xuICBzdGF0aWMgdWludCAoYXJnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBhcmcsXG4gICAgICB0eXBlOiAndScsXG4gICAgICBzaXplOiA0LFxuICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHt7YnVmZmVyOiBBcnJheUJ1ZmZlciwgZmRzOiBBcnJheTxXZWJGRD4sIGJ1ZmZlck9mZnNldDogbnVtYmVyfX0gd2lyZU1zZ1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgX21hcnNoYWxsQXJnOiBmdW5jdGlvbiAod2lyZU1zZykge1xuICAgICAgICBuZXcgVWludDMyQXJyYXkod2lyZU1zZy5idWZmZXIsIHdpcmVNc2cuYnVmZmVyT2Zmc2V0LCAxKVswXSA9IHRoaXMudmFsdWVcbiAgICAgICAgd2lyZU1zZy5idWZmZXJPZmZzZXQgKz0gdGhpcy5zaXplXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhcmdcbiAgICogQHJldHVybnMge3t2YWx1ZTogbnVtYmVyLCB0eXBlOiAndScsIHNpemU6IG51bWJlciwgb3B0aW9uYWw6IGJvb2xlYW4sIF9tYXJzaGFsbEFyZzogZnVuY3Rpb24oe2J1ZmZlcjogQXJyYXlCdWZmZXIsIGZkczogQXJyYXk8V2ViRkQ+LCBidWZmZXJPZmZzZXQ6IG51bWJlcn0pOnZvaWR9fVxuICAgKlxuICAgKi9cbiAgc3RhdGljIHVpbnRPcHRpb25hbCAoYXJnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBhcmcsXG4gICAgICB0eXBlOiAndScsXG4gICAgICBzaXplOiA0LFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAvKipcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3tidWZmZXI6IEFycmF5QnVmZmVyLCBmZHM6IEFycmF5PFdlYkZEPiwgYnVmZmVyT2Zmc2V0OiBudW1iZXJ9fSB3aXJlTXNnXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICBfbWFyc2hhbGxBcmc6IGZ1bmN0aW9uICh3aXJlTXNnKSB7XG4gICAgICAgIG5ldyBVaW50MzJBcnJheSh3aXJlTXNnLmJ1ZmZlciwgd2lyZU1zZy5idWZmZXJPZmZzZXQsIDEpWzBdID0gKGFyZyA9PT0gbnVsbCA/IDAgOiB0aGlzLnZhbHVlKVxuICAgICAgICB3aXJlTXNnLmJ1ZmZlck9mZnNldCArPSB0aGlzLnNpemVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtXZWJGRH0gYXJnXG4gICAqIEByZXR1cm5zIHt7dmFsdWU6IG51bWJlciwgdHlwZTogJ2gnLCBzaXplOiBudW1iZXIsIG9wdGlvbmFsOiBib29sZWFuLCBfbWFyc2hhbGxBcmc6IGZ1bmN0aW9uKHtidWZmZXI6IEFycmF5QnVmZmVyLCBmZHM6IEFycmF5PFdlYkZEPiwgYnVmZmVyT2Zmc2V0OiBudW1iZXJ9KTp2b2lkfX1cbiAgICpcbiAgICovXG4gIHN0YXRpYyBmaWxlRGVzY3JpcHRvciAoYXJnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBhcmcsXG4gICAgICB0eXBlOiAnaCcsXG4gICAgICBzaXplOiAwLCAvLyBmaWxlIGRlc2NyaXB0b3JzIGFyZSBub3QgYWRkZWQgdG8gdGhlIG1lc3NhZ2Ugc2l6ZSBiZWNhdXNlIHRoZXkgYXJlIHNvbWV3aGF0IGNvbnNpZGVyZWQgbWV0YSBkYXRhLlxuICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHt7YnVmZmVyOiBBcnJheUJ1ZmZlciwgZmRzOiBBcnJheTxXZWJGRD4sIGJ1ZmZlck9mZnNldDogbnVtYmVyfX0gd2lyZU1zZ1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgX21hcnNoYWxsQXJnOiBmdW5jdGlvbiAod2lyZU1zZykge1xuICAgICAgICB3aXJlTXNnLmZkcy5wdXNoKHRoaXMudmFsdWUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhcmdcbiAgICogQHJldHVybnMge3t2YWx1ZTogbnVtYmVyLCB0eXBlOiAnaCcsIHNpemU6IG51bWJlciwgb3B0aW9uYWw6IGJvb2xlYW4sIF9tYXJzaGFsbEFyZzogZnVuY3Rpb24oe2J1ZmZlcjogQXJyYXlCdWZmZXIsIGZkczogQXJyYXk8V2ViRkQ+LCBidWZmZXJPZmZzZXQ6IG51bWJlcn0pOnZvaWR9fVxuICAgKlxuICAgKi9cbiAgc3RhdGljIGZpbGVEZXNjcmlwdG9yT3B0aW9uYWwgKGFyZykge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogYXJnLFxuICAgICAgdHlwZTogJ2gnLFxuICAgICAgc2l6ZTogMCwgLy8gZmlsZSBkZXNjcmlwdG9ycyBhcmUgbm90IGFkZGVkIHRvIHRoZSBtZXNzYWdlIHNpemUgYmVjYXVzZSB0aGV5IGFyZSBub3QgcGFydCBvZiB0aGUgdW5peCBzb2NrZXQgbWVzc2FnZSBidWZmZXIuXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7e2J1ZmZlcjogQXJyYXlCdWZmZXIsIGZkczogQXJyYXk8V2ViRkQ+LCBidWZmZXJPZmZzZXQ6IG51bWJlcn19IHdpcmVNc2dcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cbiAgICAgIF9tYXJzaGFsbEFyZzogZnVuY3Rpb24gKHdpcmVNc2cpIHtcbiAgICAgICAgd2lyZU1zZy5mZHMucHVzaCh0aGlzLnZhbHVlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gYXJnXG4gICAqIEByZXR1cm5zIHt7dmFsdWU6IG51bWJlciwgdHlwZTogJ2knLCBzaXplOiBudW1iZXIsIG9wdGlvbmFsOiBib29sZWFuLCBfbWFyc2hhbGxBcmc6IGZ1bmN0aW9uKHtidWZmZXI6IEFycmF5QnVmZmVyLCBmZHM6IEFycmF5PFdlYkZEPiwgYnVmZmVyT2Zmc2V0OiBudW1iZXJ9KTp2b2lkfX1cbiAgICpcbiAgICovXG4gIHN0YXRpYyBpbnQgKGFyZykge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogYXJnLFxuICAgICAgdHlwZTogJ2knLFxuICAgICAgc2l6ZTogNCxcbiAgICAgIG9wdGlvbmFsOiBmYWxzZSxcbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7e2J1ZmZlcjogQXJyYXlCdWZmZXIsIGZkczogQXJyYXk8V2ViRkQ+LCBidWZmZXJPZmZzZXQ6IG51bWJlcn19IHdpcmVNc2dcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cbiAgICAgIF9tYXJzaGFsbEFyZzogZnVuY3Rpb24gKHdpcmVNc2cpIHtcbiAgICAgICAgbmV3IEludDMyQXJyYXkod2lyZU1zZy5idWZmZXIsIHdpcmVNc2cuYnVmZmVyT2Zmc2V0LCAxKVswXSA9IHRoaXMudmFsdWVcbiAgICAgICAgd2lyZU1zZy5idWZmZXJPZmZzZXQgKz0gdGhpcy5zaXplXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhcmdcbiAgICogQHJldHVybnMge3t2YWx1ZTogbnVtYmVyLCB0eXBlOiAnaScsIHNpemU6IG51bWJlciwgb3B0aW9uYWw6IGJvb2xlYW4sIF9tYXJzaGFsbEFyZzogZnVuY3Rpb24oe2J1ZmZlcjogQXJyYXlCdWZmZXIsIGZkczogQXJyYXk8V2ViRkQ+LCBidWZmZXJPZmZzZXQ6IG51bWJlcn0pOnZvaWR9fVxuICAgKlxuICAgKi9cbiAgc3RhdGljIGludE9wdGlvbmFsIChhcmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGFyZyxcbiAgICAgIHR5cGU6ICdpJyxcbiAgICAgIHNpemU6IDQsXG4gICAgICBvcHRpb25hbDogdHJ1ZSxcbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7e2J1ZmZlcjogQXJyYXlCdWZmZXIsIGZkczogQXJyYXk8V2ViRkQ+LCBidWZmZXJPZmZzZXQ6IG51bWJlcn19IHdpcmVNc2dcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cbiAgICAgIF9tYXJzaGFsbEFyZzogZnVuY3Rpb24gKHdpcmVNc2cpIHtcbiAgICAgICAgbmV3IEludDMyQXJyYXkod2lyZU1zZy5idWZmZXIsIHdpcmVNc2cuYnVmZmVyT2Zmc2V0LCAxKVswXSA9IChhcmcgPT09IG51bGwgPyAwIDogdGhpcy52YWx1ZSlcbiAgICAgICAgd2lyZU1zZy5idWZmZXJPZmZzZXQgKz0gdGhpcy5zaXplXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7Rml4ZWR9IGFyZ1xuICAgKiBAcmV0dXJucyB7e3ZhbHVlOiBGaXhlZCwgdHlwZTogJ2YnLCBzaXplOiBudW1iZXIsIG9wdGlvbmFsOiBib29sZWFuLCBfbWFyc2hhbGxBcmc6IGZ1bmN0aW9uKHtidWZmZXI6IEFycmF5QnVmZmVyLCBmZHM6IEFycmF5PFdlYkZEPiwgYnVmZmVyT2Zmc2V0OiBudW1iZXJ9KTp2b2lkfX1cbiAgICovXG4gIHN0YXRpYyBmaXhlZCAoYXJnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBhcmcsXG4gICAgICB0eXBlOiAnZicsXG4gICAgICBzaXplOiA0LFxuICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHt7YnVmZmVyOiBBcnJheUJ1ZmZlciwgZmRzOiBBcnJheTxXZWJGRD4sIGJ1ZmZlck9mZnNldDogbnVtYmVyfX0gd2lyZU1zZ1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgX21hcnNoYWxsQXJnOiBmdW5jdGlvbiAod2lyZU1zZykge1xuICAgICAgICBuZXcgSW50MzJBcnJheSh3aXJlTXNnLmJ1ZmZlciwgd2lyZU1zZy5idWZmZXJPZmZzZXQsIDEpWzBdID0gdGhpcy52YWx1ZS5fcmF3XG4gICAgICAgIHdpcmVNc2cuYnVmZmVyT2Zmc2V0ICs9IHRoaXMuc2l6ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge0ZpeGVkfSBhcmdcbiAgICogQHJldHVybnMge3t2YWx1ZTogRml4ZWQsIHR5cGU6ICdmJywgc2l6ZTogbnVtYmVyLCBvcHRpb25hbDogYm9vbGVhbiwgX21hcnNoYWxsQXJnOiBmdW5jdGlvbih7YnVmZmVyOiBBcnJheUJ1ZmZlciwgZmRzOiBBcnJheTxXZWJGRD4sIGJ1ZmZlck9mZnNldDogbnVtYmVyfSk6dm9pZH19XG4gICAqL1xuICBzdGF0aWMgZml4ZWRPcHRpb25hbCAoYXJnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBhcmcsXG4gICAgICB0eXBlOiAnZicsXG4gICAgICBzaXplOiA0LFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICAvKipcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3tidWZmZXI6IEFycmF5QnVmZmVyLCBmZHM6IEFycmF5PFdlYkZEPiwgYnVmZmVyT2Zmc2V0OiBudW1iZXJ9fSB3aXJlTXNnXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICBfbWFyc2hhbGxBcmc6IGZ1bmN0aW9uICh3aXJlTXNnKSB7XG4gICAgICAgIG5ldyBJbnQzMkFycmF5KHdpcmVNc2cuYnVmZmVyLCB3aXJlTXNnLmJ1ZmZlck9mZnNldCwgMSlbMF0gPSAoYXJnID09PSBudWxsID8gMCA6IHRoaXMudmFsdWUuX3JhdylcbiAgICAgICAgd2lyZU1zZy5idWZmZXJPZmZzZXQgKz0gdGhpcy5zaXplXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7UmVzb3VyY2V9IGFyZ1xuICAgKiBAcmV0dXJucyB7e3ZhbHVlOiBSZXNvdXJjZSwgdHlwZTogJ28nLCBzaXplOiBudW1iZXIsIG9wdGlvbmFsOiBib29sZWFuLCBfbWFyc2hhbGxBcmc6IGZ1bmN0aW9uKHtidWZmZXI6IEFycmF5QnVmZmVyLCBmZHM6IEFycmF5PFdlYkZEPiwgYnVmZmVyT2Zmc2V0OiBudW1iZXJ9KTp2b2lkfX1cbiAgICpcbiAgICovXG4gIHN0YXRpYyBvYmplY3QgKGFyZykge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogYXJnLFxuICAgICAgdHlwZTogJ28nLFxuICAgICAgc2l6ZTogNCxcbiAgICAgIG9wdGlvbmFsOiBmYWxzZSxcbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7e2J1ZmZlcjogQXJyYXlCdWZmZXIsIGZkczogQXJyYXk8V2ViRkQ+LCBidWZmZXJPZmZzZXQ6IG51bWJlcn19IHdpcmVNc2dcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cbiAgICAgIF9tYXJzaGFsbEFyZzogZnVuY3Rpb24gKHdpcmVNc2cpIHtcbiAgICAgICAgbmV3IFVpbnQzMkFycmF5KHdpcmVNc2cuYnVmZmVyLCB3aXJlTXNnLmJ1ZmZlck9mZnNldCwgMSlbMF0gPSB0aGlzLnZhbHVlLmlkXG4gICAgICAgIHdpcmVNc2cuYnVmZmVyT2Zmc2V0ICs9IHRoaXMuc2l6ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge1Jlc291cmNlfSBhcmdcbiAgICogQHJldHVybnMge3t2YWx1ZTogUmVzb3VyY2UsIHR5cGU6ICdvJywgc2l6ZTogbnVtYmVyLCBvcHRpb25hbDogYm9vbGVhbiwgX21hcnNoYWxsQXJnOiBmdW5jdGlvbih7YnVmZmVyOiBBcnJheUJ1ZmZlciwgZmRzOiBBcnJheTxXZWJGRD4sIGJ1ZmZlck9mZnNldDogbnVtYmVyfSk6dm9pZH19XG4gICAqXG4gICAqL1xuICBzdGF0aWMgb2JqZWN0T3B0aW9uYWwgKGFyZykge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogYXJnLFxuICAgICAgdHlwZTogJ28nLFxuICAgICAgc2l6ZTogNCxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHt7YnVmZmVyOiBBcnJheUJ1ZmZlciwgZmRzOiBBcnJheTxXZWJGRD4sIGJ1ZmZlck9mZnNldDogbnVtYmVyfX0gd2lyZU1zZ1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgX21hcnNoYWxsQXJnOiBmdW5jdGlvbiAod2lyZU1zZykge1xuICAgICAgICBuZXcgVWludDMyQXJyYXkod2lyZU1zZy5idWZmZXIsIHdpcmVNc2cuYnVmZmVyT2Zmc2V0LCAxKVswXSA9IChhcmcgPT09IG51bGwgPyAwIDogdGhpcy52YWx1ZS5pZClcbiAgICAgICAgd2lyZU1zZy5idWZmZXJPZmZzZXQgKz0gdGhpcy5zaXplXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHt7dmFsdWU6IG51bWJlciwgdHlwZTogJ24nLCBzaXplOiBudW1iZXIsIG9wdGlvbmFsOiBib29sZWFuLCBfbWFyc2hhbGxBcmc6IGZ1bmN0aW9uKHtidWZmZXI6IEFycmF5QnVmZmVyLCBmZHM6IEFycmF5PFdlYkZEPiwgYnVmZmVyT2Zmc2V0OiBudW1iZXJ9KTp2b2lkfX1cbiAgICovXG4gIHN0YXRpYyBuZXdPYmplY3QgKCkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogMCwgLy8gaWQgZmlsbGVkIGluIGJ5IF9tYXJzaGFsbENvbnN0cnVjdG9yXG4gICAgICB0eXBlOiAnbicsXG4gICAgICBzaXplOiA0LFxuICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge3tidWZmZXI6IEFycmF5QnVmZmVyLCBmZHM6IEFycmF5PFdlYkZEPiwgYnVmZmVyT2Zmc2V0OiBudW1iZXJ9fSB3aXJlTXNnXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICBfbWFyc2hhbGxBcmc6IGZ1bmN0aW9uICh3aXJlTXNnKSB7XG4gICAgICAgIG5ldyBVaW50MzJBcnJheSh3aXJlTXNnLmJ1ZmZlciwgd2lyZU1zZy5idWZmZXJPZmZzZXQsIDEpWzBdID0gdGhpcy52YWx1ZVxuICAgICAgICB3aXJlTXNnLmJ1ZmZlck9mZnNldCArPSB0aGlzLnNpemVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFyZ1xuICAgKiBAcmV0dXJucyB7e3ZhbHVlOiBzdHJpbmcsIHR5cGU6ICdzJywgc2l6ZTogbnVtYmVyLCBvcHRpb25hbDogYm9vbGVhbiwgX21hcnNoYWxsQXJnOiBmdW5jdGlvbih7YnVmZmVyOiBBcnJheUJ1ZmZlciwgZmRzOiBBcnJheTxXZWJGRD4sIGJ1ZmZlck9mZnNldDogbnVtYmVyfSk6dm9pZH19XG4gICAqXG4gICAqL1xuICBzdGF0aWMgc3RyaW5nIChhcmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGAke2FyZ31cXDBgLFxuICAgICAgdHlwZTogJ3MnLFxuICAgICAgc2l6ZTogNCArIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGZhbmN5IGxvZ2ljIHRvIGNhbGN1bGF0ZSBzaXplIHdpdGggcGFkZGluZyB0byBhIG11bHRpcGxlIG9mIDQgYnl0ZXMgKGludCkuXG4gICAgICAgIC8vIGxlbmd0aCsxIGZvciBudWxsIHRlcm1pbmF0b3JcbiAgICAgICAgcmV0dXJuIChhcmcubGVuZ3RoICsgMSArIDMpICYgfjNcbiAgICAgIH0pKCksXG4gICAgICBvcHRpb25hbDogZmFsc2UsXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7e2J1ZmZlcjogQXJyYXlCdWZmZXIsIGZkczogQXJyYXk8V2ViRkQ+LCBidWZmZXJPZmZzZXQ6IG51bWJlcn19IHdpcmVNc2dcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKi9cbiAgICAgIF9tYXJzaGFsbEFyZzogZnVuY3Rpb24gKHdpcmVNc2cpIHtcbiAgICAgICAgbmV3IFVpbnQzMkFycmF5KHdpcmVNc2cuYnVmZmVyLCB3aXJlTXNnLmJ1ZmZlck9mZnNldCwgMSlbMF0gPSB0aGlzLnZhbHVlLmxlbmd0aFxuXG4gICAgICAgIGNvbnN0IHN0ckxlbiA9IHRoaXMudmFsdWUubGVuZ3RoXG4gICAgICAgIGNvbnN0IGJ1ZjggPSBuZXcgVWludDhBcnJheSh3aXJlTXNnLmJ1ZmZlciwgd2lyZU1zZy5idWZmZXJPZmZzZXQgKyA0LCBzdHJMZW4pXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyTGVuOyBpKyspIHtcbiAgICAgICAgICBidWY4W2ldID0gdGhpcy52YWx1ZVtpXS5jb2RlUG9pbnRBdCgwKVxuICAgICAgICB9XG4gICAgICAgIHdpcmVNc2cuYnVmZmVyT2Zmc2V0ICs9IHRoaXMuc2l6ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXJnXG4gICAqIEByZXR1cm5zIHt7dmFsdWU6ICosIHR5cGU6ICdzJywgc2l6ZTogbnVtYmVyLCBvcHRpb25hbDogYm9vbGVhbiwgX21hcnNoYWxsQXJnOiBmdW5jdGlvbih7YnVmZmVyOiBBcnJheUJ1ZmZlciwgZmRzOiBBcnJheTxXZWJGRD4sIGJ1ZmZlck9mZnNldDogbnVtYmVyfSk6dm9pZH19XG4gICAqXG4gICAqL1xuICBzdGF0aWMgc3RyaW5nT3B0aW9uYWwgKGFyZykge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogYCR7YXJnfVxcMGAsXG4gICAgICB0eXBlOiAncycsXG4gICAgICBzaXplOiA0ICsgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGFyZyA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAwXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZmFuY3kgbG9naWMgdG8gY2FsY3VsYXRlIHNpemUgd2l0aCBwYWRkaW5nIHRvIGEgbXVsdGlwbGUgb2YgNCBieXRlcyAoaW50KS5cbiAgICAgICAgICAvLyBsZW5ndGgrMSBmb3IgbnVsbCB0ZXJtaW5hdG9yXG4gICAgICAgICAgcmV0dXJuIChhcmcubGVuZ3RoICsgMSArIDMpICYgfjNcbiAgICAgICAgfVxuICAgICAgfSkoKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHt7YnVmZmVyOiBBcnJheUJ1ZmZlciwgZmRzOiBBcnJheTxXZWJGRD4sIGJ1ZmZlck9mZnNldDogbnVtYmVyfX0gd2lyZU1zZ1xuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqL1xuICAgICAgX21hcnNoYWxsQXJnOiBmdW5jdGlvbiAod2lyZU1zZykge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIG5ldyBVaW50MzJBcnJheSh3aXJlTXNnLmJ1ZmZlciwgd2lyZU1zZy5idWZmZXJPZmZzZXQsIDEpWzBdID0gMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ldyBVaW50MzJBcnJheSh3aXJlTXNnLmJ1ZmZlciwgd2lyZU1zZy5idWZmZXJPZmZzZXQsIDEpWzBdID0gdGhpcy52YWx1ZS5sZW5ndGhcblxuICAgICAgICAgIGNvbnN0IHN0ckxlbiA9IHRoaXMudmFsdWUubGVuZ3RoXG4gICAgICAgICAgY29uc3QgYnVmOCA9IG5ldyBVaW50OEFycmF5KHdpcmVNc2cuYnVmZmVyLCB3aXJlTXNnLmJ1ZmZlck9mZnNldCArIDQsIHN0ckxlbilcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ckxlbjsgaSsrKSB7XG4gICAgICAgICAgICBidWY4W2ldID0gdGhpcy52YWx1ZVtpXS5jb2RlUG9pbnRBdCgwKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aXJlTXNnLmJ1ZmZlck9mZnNldCArPSB0aGlzLnNpemVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtUeXBlZEFycmF5fSBhcmdcbiAgICogQHJldHVybnMge3t2YWx1ZTogKiwgdHlwZTogJ2EnLCBzaXplOiBudW1iZXIsIG9wdGlvbmFsOiBib29sZWFuLCBfbWFyc2hhbGxBcmc6IGZ1bmN0aW9uKHtidWZmZXI6IEFycmF5QnVmZmVyLCBmZHM6IEFycmF5PFdlYkZEPiwgYnVmZmVyT2Zmc2V0OiBudW1iZXJ9KTp2b2lkfX1cbiAgICpcbiAgICovXG4gIHN0YXRpYyBhcnJheSAoYXJnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBhcmcsXG4gICAgICB0eXBlOiAnYScsXG4gICAgICBzaXplOiA0ICsgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZmFuY3kgbG9naWMgdG8gY2FsY3VsYXRlIHNpemUgd2l0aCBwYWRkaW5nIHRvIGEgbXVsdGlwbGUgb2YgNCBieXRlcyAoaW50KS5cbiAgICAgICAgcmV0dXJuIChhcmcuYnl0ZUxlbmd0aCArIDMpICYgfjNcbiAgICAgIH0pKCksXG4gICAgICBvcHRpb25hbDogZmFsc2UsXG4gICAgICAvKipcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3tidWZmZXI6IEFycmF5QnVmZmVyLCBmZHM6IEFycmF5PFdlYkZEPiwgYnVmZmVyT2Zmc2V0OiBudW1iZXJ9fSB3aXJlTXNnXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICovXG4gICAgICBfbWFyc2hhbGxBcmc6IGZ1bmN0aW9uICh3aXJlTXNnKSB7XG4gICAgICAgIG5ldyBVaW50MzJBcnJheSh3aXJlTXNnLmJ1ZmZlciwgd2lyZU1zZy5idWZmZXJPZmZzZXQsIDEpWzBdID0gdGhpcy52YWx1ZS5ieXRlTGVuZ3RoXG5cbiAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IHRoaXMudmFsdWUuYnl0ZUxlbmd0aFxuICAgICAgICBuZXcgVWludDhBcnJheSh3aXJlTXNnLmJ1ZmZlciwgd2lyZU1zZy5idWZmZXJPZmZzZXQgKyA0LCBieXRlTGVuZ3RoKS5zZXQobmV3IFVpbnQ4QXJyYXkodGhpcy52YWx1ZS5idWZmZXIsIDAsIGJ5dGVMZW5ndGgpKVxuXG4gICAgICAgIHdpcmVNc2cuYnVmZmVyT2Zmc2V0ICs9IHRoaXMuc2l6ZVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge1R5cGVkQXJyYXl9IGFyZ1xuICAgKiBAcmV0dXJucyB7e3ZhbHVlOiAqLCB0eXBlOiAnYScsIHNpemU6IG51bWJlciwgb3B0aW9uYWw6IGJvb2xlYW4sIF9tYXJzaGFsbEFyZzogZnVuY3Rpb24oe2J1ZmZlcjogQXJyYXlCdWZmZXIsIGZkczogQXJyYXk8V2ViRkQ+LCBidWZmZXJPZmZzZXQ6IG51bWJlcn0pOnZvaWR9fVxuICAgKlxuICAgKi9cbiAgc3RhdGljIGFycmF5T3B0aW9uYWwgKGFyZykge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogYXJnLFxuICAgICAgdHlwZTogJ2EnLFxuICAgICAgc2l6ZTogNCArIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChhcmcgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGZhbmN5IGxvZ2ljIHRvIGNhbGN1bGF0ZSBzaXplIHdpdGggcGFkZGluZyB0byBhIG11bHRpcGxlIG9mIDQgYnl0ZXMgKGludCkuXG4gICAgICAgICAgcmV0dXJuIChhcmcuYnl0ZUxlbmd0aCArIDMpICYgfjNcbiAgICAgICAgfVxuICAgICAgfSkoKSxcbiAgICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgICAgX21hcnNoYWxsQXJnOiBmdW5jdGlvbiAod2lyZU1zZykge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIG5ldyBVaW50MzJBcnJheSh3aXJlTXNnLmJ1ZmZlciwgd2lyZU1zZy5idWZmZXJPZmZzZXQsIDEpWzBdID0gMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ldyBVaW50MzJBcnJheSh3aXJlTXNnLmJ1ZmZlciwgd2lyZU1zZy5idWZmZXJPZmZzZXQsIDEpWzBdID0gdGhpcy52YWx1ZS5ieXRlTGVuZ3RoXG5cbiAgICAgICAgICBjb25zdCBieXRlTGVuZ3RoID0gdGhpcy52YWx1ZS5ieXRlTGVuZ3RoXG4gICAgICAgICAgbmV3IFVpbnQ4QXJyYXkod2lyZU1zZy5idWZmZXIsIHdpcmVNc2cuYnVmZmVyT2Zmc2V0ICsgNCwgYnl0ZUxlbmd0aCkuc2V0KG5ldyBVaW50OEFycmF5KHRoaXMudmFsdWUuYnVmZmVyLCAwLCBieXRlTGVuZ3RoKSlcbiAgICAgICAgfVxuICAgICAgICB3aXJlTXNnLmJ1ZmZlck9mZnNldCArPSB0aGlzLnNpemVcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHt7YnVmZmVyOiBVaW50MzJBcnJheSwgZmRzOiBBcnJheTxXZWJGRD4sIGJ1ZmZlck9mZnNldDogbnVtYmVyLCBjb25zdW1lZDogbnVtYmVyLCBzaXplOiBudW1iZXJ9fSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7bnVtYmVyfWNvbnN1bXB0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdGF0aWMgX2NoZWNrTWVzc2FnZVNpemUgKG1lc3NhZ2UsIGNvbnN1bXB0aW9uKSB7XG4gICAgaWYgKG1lc3NhZ2UuY29uc3VtZWQgKyBjb25zdW1wdGlvbiA+IG1lc3NhZ2Uuc2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXF1ZXN0IHRvbyBzaG9ydC5gKVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlLmNvbnN1bWVkICs9IGNvbnN1bXB0aW9uXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7e2J1ZmZlcjogVWludDMyQXJyYXksIGZkczogQXJyYXk8V2ViRkQ+LCBidWZmZXJPZmZzZXQ6IG51bWJlciwgY29uc3VtZWQ6IG51bWJlciwgc2l6ZTogbnVtYmVyfX0gbWVzc2FnZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIHUgKG1lc3NhZ2UpIHsgLy8gdW5zaWduZWQgaW50ZWdlciB7bnVtYmVyfVxuICAgIENvbm5lY3Rpb24uX2NoZWNrTWVzc2FnZVNpemUobWVzc2FnZSwgNClcbiAgICByZXR1cm4gbWVzc2FnZS5idWZmZXJbbWVzc2FnZS5idWZmZXJPZmZzZXQrK11cbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge3tidWZmZXI6IFVpbnQzMkFycmF5LCBmZHM6IEFycmF5PFdlYkZEPiwgYnVmZmVyT2Zmc2V0OiBudW1iZXIsIGNvbnN1bWVkOiBudW1iZXIsIHNpemU6IG51bWJlcn19IG1lc3NhZ2VcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIHN0YXRpYyBpIChtZXNzYWdlKSB7XG4gICAgQ29ubmVjdGlvbi5fY2hlY2tNZXNzYWdlU2l6ZShtZXNzYWdlLCA0KVxuICAgIGNvbnN0IGFyZyA9IG5ldyBJbnQzMkFycmF5KG1lc3NhZ2UuYnVmZmVyLmJ1ZmZlciwgbWVzc2FnZS5idWZmZXIuYnl0ZU9mZnNldCArIChtZXNzYWdlLmJ1ZmZlck9mZnNldCAqIFVpbnQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UKSwgMSlbMF1cbiAgICBtZXNzYWdlLmJ1ZmZlck9mZnNldCArPSAxXG4gICAgcmV0dXJuIGFyZ1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7e2J1ZmZlcjogVWludDMyQXJyYXksIGZkczogQXJyYXk8V2ViRkQ+LCBidWZmZXJPZmZzZXQ6IG51bWJlciwgY29uc3VtZWQ6IG51bWJlciwgc2l6ZTogbnVtYmVyfX0gbWVzc2FnZVxuICAgKiBAcmV0dXJucyB7Rml4ZWR9XG4gICAqL1xuICBzdGF0aWMgZiAobWVzc2FnZSkge1xuICAgIENvbm5lY3Rpb24uX2NoZWNrTWVzc2FnZVNpemUobWVzc2FnZSwgNClcbiAgICBjb25zdCBhcmcgPSBuZXcgSW50MzJBcnJheShtZXNzYWdlLmJ1ZmZlci5idWZmZXIsIG1lc3NhZ2UuYnVmZmVyLmJ5dGVPZmZzZXQgKyAobWVzc2FnZS5idWZmZXJPZmZzZXQgKiBVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCksIDEpWzBdXG4gICAgbWVzc2FnZS5idWZmZXJPZmZzZXQgKz0gMVxuICAgIHJldHVybiBuZXcgRml4ZWQoYXJnID4+IDApXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHt7YnVmZmVyOiBVaW50MzJBcnJheSwgZmRzOiBBcnJheTxXZWJGRD4sIGJ1ZmZlck9mZnNldDogbnVtYmVyLCBjb25zdW1lZDogbnVtYmVyLCBzaXplOiBudW1iZXJ9fSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9uYWxcbiAgICogQHBhcmFtIHtDb25uZWN0aW9ufWNvbm5lY3Rpb25cbiAgICogQHJldHVybnMge1dsT2JqZWN0fVxuICAgKi9cbiAgc3RhdGljIG8gKG1lc3NhZ2UsIG9wdGlvbmFsLCBjb25uZWN0aW9uKSB7XG4gICAgQ29ubmVjdGlvbi5fY2hlY2tNZXNzYWdlU2l6ZShtZXNzYWdlLCA0KVxuICAgIGNvbnN0IGFyZyA9IG1lc3NhZ2UuYnVmZmVyW21lc3NhZ2UuYnVmZmVyT2Zmc2V0KytdXG4gICAgaWYgKG9wdGlvbmFsICYmIGFyZyA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgd2xPYmplY3QgPSBjb25uZWN0aW9uLndsT2JqZWN0c1thcmddXG4gICAgICBpZiAod2xPYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIHdsT2JqZWN0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gb2JqZWN0IGlkICR7YXJnfWApXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7e2J1ZmZlcjogVWludDMyQXJyYXksIGZkczogQXJyYXk8V2ViRkQ+LCBidWZmZXJPZmZzZXQ6IG51bWJlciwgY29uc3VtZWQ6IG51bWJlciwgc2l6ZTogbnVtYmVyfX0gbWVzc2FnZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgc3RhdGljIG4gKG1lc3NhZ2UpIHtcbiAgICBDb25uZWN0aW9uLl9jaGVja01lc3NhZ2VTaXplKG1lc3NhZ2UsIDQpXG4gICAgcmV0dXJuIG1lc3NhZ2UuYnVmZmVyW21lc3NhZ2UuYnVmZmVyT2Zmc2V0KytdXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHt7YnVmZmVyOiBVaW50MzJBcnJheSwgZmRzOiBBcnJheTxXZWJGRD4sIGJ1ZmZlck9mZnNldDogbnVtYmVyLCBjb25zdW1lZDogbnVtYmVyLCBzaXplOiBudW1iZXJ9fSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9uYWxcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBzIChtZXNzYWdlLCBvcHRpb25hbCkgeyAvLyB7U3RyaW5nfVxuICAgIENvbm5lY3Rpb24uX2NoZWNrTWVzc2FnZVNpemUobWVzc2FnZSwgNClcbiAgICBjb25zdCBzdHJpbmdTaXplID0gbWVzc2FnZS5idWZmZXJbbWVzc2FnZS5idWZmZXJPZmZzZXQrK11cbiAgICBpZiAob3B0aW9uYWwgJiYgc3RyaW5nU2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYWxpZ25lZFNpemUgPSAoKHN0cmluZ1NpemUgKyAzKSAmIH4zKVxuICAgICAgQ29ubmVjdGlvbi5fY2hlY2tNZXNzYWdlU2l6ZShtZXNzYWdlLCBhbGlnbmVkU2l6ZSlcbiAgICAgIC8vIHNpemUgLTEgdG8gZWxpbWluYXRlIG51bGwgYnl0ZVxuICAgICAgY29uc3QgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobWVzc2FnZS5idWZmZXIuYnVmZmVyLCBtZXNzYWdlLmJ1ZmZlci5ieXRlT2Zmc2V0ICsgKG1lc3NhZ2UuYnVmZmVyT2Zmc2V0ICogVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQpLCBzdHJpbmdTaXplIC0gMSlcbiAgICAgIG1lc3NhZ2UuYnVmZmVyT2Zmc2V0ICs9IChhbGlnbmVkU2l6ZSAvIDQpXG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSguLi5ieXRlQXJyYXkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7e2J1ZmZlcjogVWludDMyQXJyYXksIGZkczogQXJyYXk8V2ViRkQ+LCBidWZmZXJPZmZzZXQ6IG51bWJlciwgY29uc3VtZWQ6IG51bWJlciwgc2l6ZTogbnVtYmVyfX0gbWVzc2FnZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IG9wdGlvbmFsXG4gICAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn1cbiAgICovXG4gIHN0YXRpYyBhIChtZXNzYWdlLCBvcHRpb25hbCkge1xuICAgIENvbm5lY3Rpb24uX2NoZWNrTWVzc2FnZVNpemUobWVzc2FnZSwgNClcbiAgICBjb25zdCBhcnJheVNpemUgPSBtZXNzYWdlLmJ1ZmZlclttZXNzYWdlLmJ1ZmZlck9mZnNldCsrXVxuICAgIGlmIChvcHRpb25hbCAmJiBhcnJheVNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGFsaWduZWRTaXplID0gKChhcnJheVNpemUgKyAzKSAmIH4zKVxuICAgICAgQ29ubmVjdGlvbi5fY2hlY2tNZXNzYWdlU2l6ZShtZXNzYWdlLCBhbGlnbmVkU2l6ZSlcbiAgICAgIGNvbnN0IGFyZyA9IG1lc3NhZ2UuYnVmZmVyLmJ1ZmZlci5zbGljZShtZXNzYWdlLmJ1ZmZlci5ieXRlT2Zmc2V0ICsgKG1lc3NhZ2UuYnVmZmVyT2Zmc2V0ICogVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQpLCBtZXNzYWdlLmJ1ZmZlci5ieXRlT2Zmc2V0ICsgKG1lc3NhZ2UuYnVmZmVyT2Zmc2V0ICogVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQpICsgYXJyYXlTaXplKVxuICAgICAgbWVzc2FnZS5idWZmZXJPZmZzZXQgKz0gYWxpZ25lZFNpemVcbiAgICAgIHJldHVybiBhcmdcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHt7YnVmZmVyOiBVaW50MzJBcnJheSwgZmRzOiBBcnJheTxXZWJGRD4sIGJ1ZmZlck9mZnNldDogbnVtYmVyLCBjb25zdW1lZDogbnVtYmVyLCBzaXplOiBudW1iZXJ9fSBtZXNzYWdlXG4gICAqIEByZXR1cm5zIHtXZWJGRH1cbiAgICovXG4gIHN0YXRpYyBoIChtZXNzYWdlKSB7IC8vIGZpbGUgZGVzY3JpcHRvciB7bnVtYmVyfVxuICAgIGlmIChtZXNzYWdlLmZkcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gbWVzc2FnZS5mZHMuc2hpZnQoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBlbm91Z2ggZmlsZSBkZXNjcmlwdG9ycyBpbiBtZXNzYWdlIG9iamVjdC4nKVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxudW1iZXIsV2xPYmplY3Q+fVxuICAgICAqL1xuICAgIHRoaXMud2xPYmplY3RzID0ge31cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY2xvc2VkID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8e2J1ZmZlcjogQXJyYXlCdWZmZXIsIGZkczogQXJyYXk8V2ViRkQ+fT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9vdXRNZXNzYWdlcyA9IFtdXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PHtidWZmZXI6IFVpbnQzMkFycmF5LCBmZHM6IEFycmF5PFdlYkZEPn0+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5faW5NZXNzYWdlcyA9IFtdXG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGlkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcGNvZGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpemVcbiAgICogQHBhcmFtIHtBcnJheTx7dmFsdWU6ICosIHR5cGU6IHN0cmluZywgc2l6ZTogbnVtYmVyLCBvcHRpb25hbDogYm9vbGVhbiwgX21hcnNoYWxsQXJnOiBmdW5jdGlvbih7YnVmZmVyOiBBcnJheUJ1ZmZlciwgZmRzOiBBcnJheTxXZWJGRD4sIGJ1ZmZlck9mZnNldDogbnVtYmVyfSk6dm9pZH0+fSBhcmdzQXJyYXlcbiAgICovXG4gIG1hcnNoYWxsTXNnIChpZCwgb3Bjb2RlLCBzaXplLCBhcmdzQXJyYXkpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7e2J1ZmZlcjogQXJyYXlCdWZmZXIsIGZkczogQXJyYXk8V2ViRkQ+LCBidWZmZXJPZmZzZXQ6IG51bWJlcn19XG4gICAgICovXG4gICAgY29uc3Qgd2lyZU1zZyA9IHtcbiAgICAgIGJ1ZmZlcjogbmV3IEFycmF5QnVmZmVyKHNpemUpLFxuICAgICAgZmRzOiBbXSxcbiAgICAgIGJ1ZmZlck9mZnNldDogMFxuICAgIH1cblxuICAgIC8vIHdyaXRlIGFjdHVhbCB3aXJlIG1lc3NhZ2VcbiAgICBjb25zdCBidWZ1MzIgPSBuZXcgVWludDMyQXJyYXkod2lyZU1zZy5idWZmZXIpXG4gICAgY29uc3QgYnVmdTE2ID0gbmV3IFVpbnQxNkFycmF5KHdpcmVNc2cuYnVmZmVyKVxuICAgIGJ1ZnUzMlswXSA9IGlkXG4gICAgYnVmdTE2WzJdID0gb3Bjb2RlXG4gICAgYnVmdTE2WzNdID0gc2l6ZVxuICAgIHdpcmVNc2cuYnVmZmVyT2Zmc2V0ID0gOFxuXG4gICAgLy8gd3JpdGUgYWN0dWFsIGFyZ3VtZW50IHZhbHVlIHRvIGJ1ZmZlclxuICAgIGFyZ3NBcnJheS5mb3JFYWNoKChhcmcpID0+IGFyZy5fbWFyc2hhbGxBcmcod2lyZU1zZykpXG4gICAgdGhpcy5vblNlbmQod2lyZU1zZylcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgcmVjZWl2ZWQgd2lyZSBtZXNzYWdlcy5cbiAgICogQHBhcmFtIHt7YnVmZmVyOiBVaW50MzJBcnJheSwgZmRzOiBBcnJheTxXZWJGRD59fSBpbmNvbWluZ1dpcmVNZXNzYWdlc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxuICAgKiBAdGhyb3dzIEVycm9yIElmIGFuIGlsbGVnYWwgY2xpZW50IHJlcXVlc3QgaXMgcmVjZWl2ZWQgaWUuIGJhZCBsZW5ndGggb3IgbWlzc2luZyBmaWxlIGRlc2NyaXB0b3IuXG4gICAqL1xuICBhc3luYyBtZXNzYWdlIChpbmNvbWluZ1dpcmVNZXNzYWdlcykge1xuICAgIGlmICh0aGlzLmNsb3NlZCkgeyByZXR1cm4gfVxuXG4gICAgLy8gbW9yZSB0aGFuIG9uZSBtZXNzYWdlIGluIHF1ZXVlIG1lYW5zIHRoZSBtZXNzYWdlIGxvb3AgaXMgaW4gYXdhaXQsIGRvbid0IGNvbmN1cnJlbnRseSBwcm9jZXNzIHRoZSBuZXdcbiAgICAvLyBtZXNzYWdlLCBpbnN0ZWFkIHJldHVybiBlYXJseSBhbmQgbGV0IHRoZSByZXN1bWUtZnJvbS1hd2FpdCBwaWNrIHVwIHRoZSBuZXdseSBxdWV1ZWQgbWVzc2FnZS5cbiAgICBpZiAodGhpcy5faW5NZXNzYWdlcy5wdXNoKGluY29taW5nV2lyZU1lc3NhZ2VzKSA+IDEpIHsgcmV0dXJuIH1cblxuICAgIHdoaWxlICh0aGlzLl9pbk1lc3NhZ2VzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgd2lyZU1lc3NhZ2VzID0gLyoqIEB0eXBlIHt7YnVmZmVyOiBVaW50MzJBcnJheSwgZmRzOiBBcnJheTxXZWJGRD4sIGJ1ZmZlck9mZnNldDogbnVtYmVyLCBjb25zdW1lZDogbnVtYmVyLCBzaXplOiBudW1iZXJ9fSAqL3RoaXMuX2luTWVzc2FnZXNbMF1cbiAgICAgIHdpcmVNZXNzYWdlcy5idWZmZXJPZmZzZXQgPSAwXG4gICAgICB3aXJlTWVzc2FnZXMuY29uc3VtZWQgPSAwXG4gICAgICB3aXJlTWVzc2FnZXMuc2l6ZSA9IDBcbiAgICAgIHdoaWxlICh3aXJlTWVzc2FnZXMuYnVmZmVyT2Zmc2V0IDwgd2lyZU1lc3NhZ2VzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgaWQgPSB3aXJlTWVzc2FnZXMuYnVmZmVyW3dpcmVNZXNzYWdlcy5idWZmZXJPZmZzZXRdXG4gICAgICAgIGNvbnN0IHNpemVPcGNvZGUgPSB3aXJlTWVzc2FnZXMuYnVmZmVyW3dpcmVNZXNzYWdlcy5idWZmZXJPZmZzZXQgKyAxXVxuICAgICAgICB3aXJlTWVzc2FnZXMuc2l6ZSA9IHNpemVPcGNvZGUgPj4+IDE2XG4gICAgICAgIGNvbnN0IG9wY29kZSA9IHNpemVPcGNvZGUgJiAweDAwMDBGRkZGXG5cbiAgICAgICAgaWYgKHdpcmVNZXNzYWdlcy5zaXplID4gd2lyZU1lc3NhZ2VzLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0IGJ1ZmZlciB0b28gc21hbGwnKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgd2xPYmplY3QgPSB0aGlzLndsT2JqZWN0c1tpZF1cbiAgICAgICAgaWYgKHdsT2JqZWN0KSB7XG4gICAgICAgICAgd2lyZU1lc3NhZ2VzLmJ1ZmZlck9mZnNldCArPSAyXG4gICAgICAgICAgd2lyZU1lc3NhZ2VzLmNvbnN1bWVkID0gOFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB3bE9iamVjdFtvcGNvZGVdKHdpcmVNZXNzYWdlcylcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBcbndsT2JqZWN0OiAke3dsT2JqZWN0LmNvbnN0cnVjdG9yLm5hbWV9WyR7b3Bjb2RlfV0oLi4pXG5uYW1lOiAke2UubmFtZX0gbWVzc2FnZTogJHtlLm1lc3NhZ2V9IHRleHQ6ICR7ZS50ZXh0fVxuZXJyb3Igb2JqZWN0IHN0YWNrOiBcbiR7ZS5zdGFja31cbmApXG4gICAgICAgICAgICB0aHJvdyBlXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmNsb3NlZCkgeyByZXR1cm4gfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvYmplY3QgJHtpZH1gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9pbk1lc3NhZ2VzLnNoaWZ0KClcbiAgICB9XG5cbiAgICB0aGlzLmZsdXNoKClcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGRvZXNuJ3QgYWN0dWFsbHkgc2VuZCB0aGUgbWVzc2FnZSwgYnV0IHF1ZXVlcyBpdCBzbyBpdCBjYW4gYmUgc2VuZCBvbiBmbHVzaC5cbiAgICogQHBhcmFtIHt7YnVmZmVyOiBBcnJheUJ1ZmZlciwgZmRzOiBBcnJheTxXZWJGRD59fXdpcmVNc2cgYSBzaW5nbGUgd2lyZSBtZXNzYWdlIGV2ZW50LlxuICAgKi9cbiAgb25TZW5kICh3aXJlTXNnKSB7XG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7IHJldHVybiB9XG5cbiAgICB0aGlzLl9vdXRNZXNzYWdlcy5wdXNoKHdpcmVNc2cpXG4gIH1cblxuICAvKipcbiAgICogRW1wdHkgdGhlIHF1ZXVlIG9mIHdpcmUgbWVzc2FnZXMgYW5kIHNlbmQgdGhlbSB0byB0aGUgb3RoZXIgZW5kLlxuICAgKi9cbiAgZmx1c2ggKCkge1xuICAgIGlmICh0aGlzLmNsb3NlZCkgeyByZXR1cm4gfVxuICAgIGlmICh0aGlzLl9vdXRNZXNzYWdlcy5sZW5ndGggPT09IDApIHsgcmV0dXJuIH1cblxuICAgIHRoaXMub25GbHVzaCh0aGlzLl9vdXRNZXNzYWdlcylcbiAgICB0aGlzLl9vdXRNZXNzYWdlcyA9IFtdXG4gIH1cblxuICAvKipcbiAgICogQ2FsbGJhY2sgd2hlbiB0aGlzIGNvbm5lY3Rpb24gd2lzaGVzIHRvIHNlbmQgZGF0YSB0byB0aGUgb3RoZXIgZW5kLiBUaGlzIGNhbGxiYWNrIGNhbiBiZSB1c2VkIHRvIHNlbmQgdGhlIGdpdmVuXG4gICAqIGFycmF5IGJ1ZmZlcnMgdXNpbmcgYW55IHRyYW5zcG9ydCBtZWNoYW5pc20uXG4gICAqIEBwYXJhbSB7QXJyYXk8e2J1ZmZlcjogQXJyYXlCdWZmZXIsIGZkczogQXJyYXk8V2ViRkQ+fT59d2lyZU1lc3NhZ2VzXG4gICAqL1xuICBvbkZsdXNoICh3aXJlTWVzc2FnZXMpIHt9XG5cbiAgY2xvc2UgKCkge1xuICAgIGlmICh0aGlzLmNsb3NlZCkgeyByZXR1cm4gfVxuXG4gICAgLy8gZGVzdHJveSByZXNvdXJjZXMgaW4gZGVzY2VuZGluZyBvcmRlclxuICAgIE9iamVjdC52YWx1ZXModGhpcy53bE9iamVjdHMpLnNvcnQoKGEsIGIpID0+IGEuaWQgLSBiLmlkKS5mb3JFYWNoKCh3bE9iamVjdCkgPT4gd2xPYmplY3QuZGVzdHJveSgpKVxuXG4gICAgdGhpcy5fb3V0TWVzc2FnZXMgPSBudWxsXG4gICAgdGhpcy5faW5NZXNzYWdlcyA9IG51bGxcbiAgICB0aGlzLmNsb3NlZCA9IHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge1dsT2JqZWN0fSB3bE9iamVjdFxuICAgKi9cbiAgcmVnaXN0ZXJXbE9iamVjdCAod2xPYmplY3QpIHtcbiAgICBpZiAodGhpcy5jbG9zZWQpIHsgcmV0dXJuIH1cbiAgICBpZiAod2xPYmplY3QuaWQgaW4gdGhpcy53bE9iamVjdHMpIHsgdGhyb3cgbmV3IEVycm9yKGBJbGxlZ2FsIG9iamVjdCBpZDogJHt3bE9iamVjdC5pZH0uIEFscmVhZHkgcmVnaXN0ZXJlZC5gKSB9XG4gICAgdGhpcy53bE9iamVjdHNbd2xPYmplY3QuaWRdID0gd2xPYmplY3RcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge1dsT2JqZWN0fSB3bE9iamVjdFxuICAgKi9cbiAgdW5yZWdpc3RlcldsT2JqZWN0ICh3bE9iamVjdCkge1xuICAgIGlmICh0aGlzLmNsb3NlZCkgeyByZXR1cm4gfVxuICAgIGRlbGV0ZSB0aGlzLndsT2JqZWN0c1t3bE9iamVjdC5pZF1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBDb25uZWN0aW9uIiwiLypcbk1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgMjAxNyBFcmlrIERlIFJpamNrZVxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5jb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG5TT0ZUV0FSRS5cbiovXG5cbid1c2Ugc3RyaWN0J1xuXG5jbGFzcyBGaXhlZCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn1udW1iZXJcbiAgICogQHJldHVybiB7Rml4ZWR9XG4gICAqL1xuICBzdGF0aWMgcGFyc2UgKG51bWJlcikge1xuICAgIHJldHVybiBuZXcgRml4ZWQoKG51bWJlciAqIDI1Ni4wKSA+PiAwKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudCBmaXhlZCBhcyBhIHNpZ25lZCAyNC1iaXQgaW50ZWdlci5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGFzSW50ICgpIHtcbiAgICByZXR1cm4gKCh0aGlzLl9yYXcgLyAyNTYuMCkgPj4gMClcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXByZXNlbnQgZml4ZWQgYXMgYSBzaWduZWQgMjQtYml0IG51bWJlciB3aXRoIGFuIDgtYml0IGZyYWN0aW9uYWwgcGFydC5cbiAgICpcbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIGFzRG91YmxlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmF3IC8gMjU2LjBcbiAgfVxuXG4gIC8qKlxuICAgKiB1c2UgcGFyc2VGaXhlZCBpbnN0ZWFkXG4gICAqIEBwYXJhbSB7bnVtYmVyfXJhd1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHJhdykge1xuICAgIHRoaXMuX3JhdyA9IHJhd1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IEZpeGVkIiwiLypcbk1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgMjAxNyBFcmlrIERlIFJpamNrZVxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cbiAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5jb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG4gIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG5TT0ZUV0FSRS5cbiovXG5cbid1c2Ugc3RyaWN0J1xuXG5jbGFzcyBXZWJGRCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn1mZFxuICAgKiBAcGFyYW0geydJbWFnZUJpdG1hcCd8J0FycmF5QnVmZmVyJ3wnTWVzc2FnZVBvcnQnfWZkVHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ31mZERvbWFpblVVSURcbiAgICogQHBhcmFtIHtmdW5jdGlvbihXZWJGRCk6IFByb21pc2U8VHJhbnNmZXJhYmxlPn1vbkdldFRyYW5zZmVyYWJsZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFdlYkZEKTogUHJvbWlzZTx2b2lkPn0gb25DbG9zZVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGZkLCBmZFR5cGUsIGZkRG9tYWluVVVJRCwgb25HZXRUcmFuc2ZlcmFibGUsIG9uQ2xvc2UpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZmQgPSBmZFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5mZFR5cGUgPSBmZFR5cGVcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuZmREb21haW5VVUlEID0gZmREb21haW5VVUlEXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Z1bmN0aW9uKFdlYkZEKTogUHJvbWlzZTxUcmFuc2ZlcmFibGU+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fb25HZXRUcmFuc2ZlcmFibGUgPSBvbkdldFRyYW5zZmVyYWJsZVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihXZWJGRCk6IFByb21pc2U8dm9pZD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9vbkNsb3NlID0gb25DbG9zZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8VHJhbnNmZXJhYmxlPn1cbiAgICovXG4gIGFzeW5jIGdldFRyYW5zZmVyYWJsZSAoKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuX29uR2V0VHJhbnNmZXJhYmxlKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn1cbiAgICovXG4gIGFzeW5jIGNsb3NlICgpIHtcbiAgICBhd2FpdCB0aGlzLl9vbkNsb3NlKHRoaXMpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgV2ViRkQiLCIvKlxuTUlUIExpY2Vuc2VcblxuQ29weXJpZ2h0IChjKSAyMDE3IEVyaWsgRGUgUmlqY2tlXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbmNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcblNPRlRXQVJFLlxuKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNsYXNzIFdsT2JqZWN0IHtcbiAgY29uc3RydWN0b3IgKGlkKSB7XG4gICAgdGhpcy5pZCA9IGlkXG4gICAgLyoqXG4gICAgICogQHR5cGUge1Byb21pc2U8dm9pZD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9kZXN0cm95UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gdGhpcy5fZGVzdHJveVJlc29sdmVyID0gcmVzb2x2ZSlcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24oUmVzb3VyY2UpOnZvaWQ+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZGVzdHJveUxpc3RlbmVycyA9IFtdXG4gICAgdGhpcy5fZGVzdHJveVByb21pc2UudGhlbigoKSA9PiB0aGlzLl9kZXN0cm95TGlzdGVuZXJzLmZvckVhY2goZGVzdHJveUxpc3RlbmVyID0+IGRlc3Ryb3lMaXN0ZW5lcih0aGlzKSkpXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLl9kZXN0cm95UmVzb2x2ZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oUmVzb3VyY2UpOnZvaWR9ZGVzdHJveUxpc3RlbmVyXG4gICAqL1xuICBhZGREZXN0cm95TGlzdGVuZXIgKGRlc3Ryb3lMaXN0ZW5lcikge1xuICAgIHRoaXMuX2Rlc3Ryb3lMaXN0ZW5lcnMucHVzaChkZXN0cm95TGlzdGVuZXIpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbihSZXNvdXJjZSk6dm9pZH1kZXN0cm95TGlzdGVuZXJcbiAgICovXG4gIHJlbW92ZURlc3Ryb3lMaXN0ZW5lciAoZGVzdHJveUxpc3RlbmVyKSB7XG4gICAgdGhpcy5fZGVzdHJveUxpc3RlbmVycyA9IHRoaXMuX2Rlc3Ryb3lMaXN0ZW5lcnMuZmlsdGVyKChpdGVtKSA9PiB7IHJldHVybiBpdGVtICE9PSBkZXN0cm95TGlzdGVuZXIgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxuICAgKi9cbiAgb25EZXN0cm95ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVzdHJveVByb21pc2VcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBXbE9iamVjdCIsIi8qKlxyXG4gKiBDb21tb24gdXRpbGl0aWVzXHJcbiAqIEBtb2R1bGUgZ2xNYXRyaXhcclxuICovXG4vLyBDb25maWd1cmF0aW9uIENvbnN0YW50c1xuZXhwb3J0IHZhciBFUFNJTE9OID0gMC4wMDAwMDE7XG5leHBvcnQgdmFyIEFSUkFZX1RZUEUgPSB0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyA/IEZsb2F0MzJBcnJheSA6IEFycmF5O1xuZXhwb3J0IHZhciBSQU5ET00gPSBNYXRoLnJhbmRvbTtcbi8qKlxyXG4gKiBTZXRzIHRoZSB0eXBlIG9mIGFycmF5IHVzZWQgd2hlbiBjcmVhdGluZyBuZXcgdmVjdG9ycyBhbmQgbWF0cmljZXNcclxuICpcclxuICogQHBhcmFtIHtUeXBlfSB0eXBlIEFycmF5IHR5cGUsIHN1Y2ggYXMgRmxvYXQzMkFycmF5IG9yIEFycmF5XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0TWF0cml4QXJyYXlUeXBlKHR5cGUpIHtcbiAgQVJSQVlfVFlQRSA9IHR5cGU7XG59XG52YXIgZGVncmVlID0gTWF0aC5QSSAvIDE4MDtcbi8qKlxyXG4gKiBDb252ZXJ0IERlZ3JlZSBUbyBSYWRpYW5cclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQW5nbGUgaW4gRGVncmVlc1xyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRvUmFkaWFuKGEpIHtcbiAgcmV0dXJuIGEgKiBkZWdyZWU7XG59XG4vKipcclxuICogVGVzdHMgd2hldGhlciBvciBub3QgdGhlIGFyZ3VtZW50cyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgdmFsdWUsIHdpdGhpbiBhbiBhYnNvbHV0ZVxyXG4gKiBvciByZWxhdGl2ZSB0b2xlcmFuY2Ugb2YgZ2xNYXRyaXguRVBTSUxPTiAoYW4gYWJzb2x1dGUgdG9sZXJhbmNlIGlzIHVzZWQgZm9yIHZhbHVlcyBsZXNzXHJcbiAqIHRoYW4gb3IgZXF1YWwgdG8gMS4wLCBhbmQgYSByZWxhdGl2ZSB0b2xlcmFuY2UgaXMgdXNlZCBmb3IgbGFyZ2VyIHZhbHVlcylcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGEgVGhlIGZpcnN0IG51bWJlciB0byB0ZXN0LlxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBUaGUgc2Vjb25kIG51bWJlciB0byB0ZXN0LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbnVtYmVycyBhcmUgYXBwcm94aW1hdGVseSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBNYXRoLmFicyhhIC0gYikgPD0gRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYSksIE1hdGguYWJzKGIpKTtcbn0iLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbmltcG9ydCAqIGFzIG1hdDIgZnJvbSBcIi4vbWF0Mi5qc1wiO1xuaW1wb3J0ICogYXMgbWF0MmQgZnJvbSBcIi4vbWF0MmQuanNcIjtcbmltcG9ydCAqIGFzIG1hdDMgZnJvbSBcIi4vbWF0My5qc1wiO1xuaW1wb3J0ICogYXMgbWF0NCBmcm9tIFwiLi9tYXQ0LmpzXCI7XG5pbXBvcnQgKiBhcyBxdWF0IGZyb20gXCIuL3F1YXQuanNcIjtcbmltcG9ydCAqIGFzIHF1YXQyIGZyb20gXCIuL3F1YXQyLmpzXCI7XG5pbXBvcnQgKiBhcyB2ZWMyIGZyb20gXCIuL3ZlYzIuanNcIjtcbmltcG9ydCAqIGFzIHZlYzMgZnJvbSBcIi4vdmVjMy5qc1wiO1xuaW1wb3J0ICogYXMgdmVjNCBmcm9tIFwiLi92ZWM0LmpzXCI7XG5leHBvcnQgeyBnbE1hdHJpeCwgbWF0MiwgbWF0MmQsIG1hdDMsIG1hdDQsIHF1YXQsIHF1YXQyLCB2ZWMyLCB2ZWMzLCB2ZWM0IH07IiwiaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uLmpzXCI7XG4vKipcclxuICogMngyIE1hdHJpeFxyXG4gKiBAbW9kdWxlIG1hdDJcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJcclxuICpcclxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gIH1cblxuICBvdXRbMF0gPSAxO1xuICBvdXRbM10gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IGEgbWF0cml4IHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDIgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IGEgbWF0MiB0byB0aGUgaWRlbnRpdHkgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgbWF0MiB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0IEEgbmV3IDJ4MiBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKG0wMCwgbTAxLCBtMTAsIG0xMSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMTA7XG4gIG91dFszXSA9IG0xMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQyIHRvIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTAgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMSBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0xMCwgbTExKSB7XG4gIG91dFswXSA9IG0wMDtcbiAgb3V0WzFdID0gbTAxO1xuICBvdXRbMl0gPSBtMTA7XG4gIG91dFszXSA9IG0xMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGVcbiAgLy8gc29tZSB2YWx1ZXNcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIHZhciBhMSA9IGFbMV07XG4gICAgb3V0WzFdID0gYVsyXTtcbiAgICBvdXRbMl0gPSBhMTtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMl07XG4gICAgb3V0WzJdID0gYVsxXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBJbnZlcnRzIGEgbWF0MlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTsgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuXG4gIHZhciBkZXQgPSBhMCAqIGEzIC0gYTIgKiBhMTtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSBhMyAqIGRldDtcbiAgb3V0WzFdID0gLWExICogZGV0O1xuICBvdXRbMl0gPSAtYTIgKiBkZXQ7XG4gIG91dFszXSA9IGEwICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0MlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIC8vIENhY2hpbmcgdGhpcyB2YWx1ZSBpcyBuZXNzZWNhcnkgaWYgb3V0ID09IGFcbiAgdmFyIGEwID0gYVswXTtcbiAgb3V0WzBdID0gYVszXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICBvdXRbM10gPSBhMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHJldHVybiBhWzBdICogYVszXSAtIGFbMl0gKiBhWzFdO1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM107XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl0sXG4gICAgICBiMyA9IGJbM107XG4gIG91dFswXSA9IGEwICogYjAgKyBhMiAqIGIxO1xuICBvdXRbMV0gPSBhMSAqIGIwICsgYTMgKiBiMTtcbiAgb3V0WzJdID0gYTAgKiBiMiArIGEyICogYjM7XG4gIG91dFszXSA9IGExICogYjIgKyBhMyAqIGIzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXQyIGJ5IHRoZSBnaXZlbiBhbmdsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYTAgKiBjICsgYTIgKiBzO1xuICBvdXRbMV0gPSBhMSAqIGMgKyBhMyAqIHM7XG4gIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGM7XG4gIG91dFszXSA9IGExICogLXMgKyBhMyAqIGM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIHRoZSBtYXQyIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgdjAgPSB2WzBdLFxuICAgICAgdjEgPSB2WzFdO1xuICBvdXRbMF0gPSBhMCAqIHYwO1xuICBvdXRbMV0gPSBhMSAqIHYwO1xuICBvdXRbMl0gPSBhMiAqIHYxO1xuICBvdXRbM10gPSBhMyAqIHYxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0Mi5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDIucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IG1hdDIgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gcztcbiAgb3V0WzJdID0gLXM7XG4gIG91dFszXSA9IGM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQyLmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0Mi5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCBtYXQyIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7dmVjMn0gdiBTY2FsaW5nIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IHZbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gJ21hdDIoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59XG4vKipcclxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikpO1xufVxuLyoqXHJcbiAqIFJldHVybnMgTCwgRCBhbmQgVSBtYXRyaWNlcyAoTG93ZXIgdHJpYW5ndWxhciwgRGlhZ29uYWwgYW5kIFVwcGVyIHRyaWFuZ3VsYXIpIGJ5IGZhY3Rvcml6aW5nIHRoZSBpbnB1dCBtYXRyaXhcclxuICogQHBhcmFtIHttYXQyfSBMIHRoZSBsb3dlciB0cmlhbmd1bGFyIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJ9IEQgdGhlIGRpYWdvbmFsIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJ9IFUgdGhlIHVwcGVyIHRyaWFuZ3VsYXIgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgaW5wdXQgbWF0cml4IHRvIGZhY3Rvcml6ZVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIExEVShMLCBELCBVLCBhKSB7XG4gIExbMl0gPSBhWzJdIC8gYVswXTtcbiAgVVswXSA9IGFbMF07XG4gIFVbMV0gPSBhWzFdO1xuICBVWzNdID0gYVszXSAtIExbMl0gKiBVWzFdO1xuICByZXR1cm4gW0wsIEQsIFVdO1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHttYXQyfSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7bWF0Mn0gYiBUaGUgc2Vjb25kIG1hdHJpeC5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIG1hdHJpY2VzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXSAmJiBhWzJdID09PSBiWzJdICYmIGFbM10gPT09IGJbM107XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IGEgVGhlIGZpcnN0IG1hdHJpeC5cclxuICogQHBhcmFtIHttYXQyfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpICYmIE1hdGguYWJzKGEzIC0gYjMpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEzKSwgTWF0aC5hYnMoYjMpKTtcbn1cbi8qKlxyXG4gKiBNdWx0aXBseSBlYWNoIGVsZW1lbnQgb2YgdGhlIG1hdHJpeCBieSBhIHNjYWxhci5cclxuICpcclxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBtYXRyaXgncyBlbGVtZW50cyBieVxyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXIob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDIncyBhZnRlciBtdWx0aXBseWluZyBlYWNoIGVsZW1lbnQgb2YgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiJ3MgZWxlbWVudHMgYnkgYmVmb3JlIGFkZGluZ1xyXG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXJBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICBvdXRbM10gPSBhWzNdICsgYlszXSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0Mi5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0Mi5zdWJ0cmFjdH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHN1YiA9IHN1YnRyYWN0OyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuLyoqXHJcbiAqIDJ4MyBNYXRyaXhcclxuICogQG1vZHVsZSBtYXQyZFxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogQSBtYXQyZCBjb250YWlucyBzaXggZWxlbWVudHMgZGVmaW5lZCBhczpcclxuICogPHByZT5cclxuICogW2EsIGMsIHR4LFxyXG4gKiAgYiwgZCwgdHldXHJcbiAqIDwvcHJlPlxyXG4gKiBUaGlzIGlzIGEgc2hvcnQgZm9ybSBmb3IgdGhlIDN4MyBtYXRyaXg6XHJcbiAqIDxwcmU+XHJcbiAqIFthLCBjLCB0eCxcclxuICogIGIsIGQsIHR5LFxyXG4gKiAgMCwgMCwgMV1cclxuICogPC9wcmU+XHJcbiAqIFRoZSBsYXN0IHJvdyBpcyBpZ25vcmVkIHNvIHRoZSBhcnJheSBpcyBzaG9ydGVyIGFuZCBvcGVyYXRpb25zIGFyZSBmYXN0ZXIuXHJcbiAqL1xuXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQyZFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IGEgbmV3IDJ4MyBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg2KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAwO1xuICB9XG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzNdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDJkIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IGEgbWF0cml4IHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gYSBuZXcgMngzIG1hdHJpeFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDYpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyZCB0byBhbm90aGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgYSBtYXQyZCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyBtYXQyZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGEgQ29tcG9uZW50IEEgKGluZGV4IDApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIENvbXBvbmVudCBCIChpbmRleCAxKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYyBDb21wb25lbnQgQyAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IGQgQ29tcG9uZW50IEQgKGluZGV4IDMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eCBDb21wb25lbnQgVFggKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eSBDb21wb25lbnQgVFkgKGluZGV4IDUpXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gQSBuZXcgbWF0MmRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKGEsIGIsIGMsIGQsIHR4LCB0eSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7XG4gIG91dFswXSA9IGE7XG4gIG91dFsxXSA9IGI7XG4gIG91dFsyXSA9IGM7XG4gIG91dFszXSA9IGQ7XG4gIG91dFs0XSA9IHR4O1xuICBvdXRbNV0gPSB0eTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBtYXQyZCB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge051bWJlcn0gYSBDb21wb25lbnQgQSAoaW5kZXggMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgQ29tcG9uZW50IEIgKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjIENvbXBvbmVudCBDIChpbmRleCAyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gZCBDb21wb25lbnQgRCAoaW5kZXggMylcclxuICogQHBhcmFtIHtOdW1iZXJ9IHR4IENvbXBvbmVudCBUWCAoaW5kZXggNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IHR5IENvbXBvbmVudCBUWSAoaW5kZXggNSlcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCBhLCBiLCBjLCBkLCB0eCwgdHkpIHtcbiAgb3V0WzBdID0gYTtcbiAgb3V0WzFdID0gYjtcbiAgb3V0WzJdID0gYztcbiAgb3V0WzNdID0gZDtcbiAgb3V0WzRdID0gdHg7XG4gIG91dFs1XSA9IHR5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEludmVydHMgYSBtYXQyZFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIGFhID0gYVswXSxcbiAgICAgIGFiID0gYVsxXSxcbiAgICAgIGFjID0gYVsyXSxcbiAgICAgIGFkID0gYVszXTtcbiAgdmFyIGF0eCA9IGFbNF0sXG4gICAgICBhdHkgPSBhWzVdO1xuICB2YXIgZGV0ID0gYWEgKiBhZCAtIGFiICogYWM7XG5cbiAgaWYgKCFkZXQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRldCA9IDEuMCAvIGRldDtcbiAgb3V0WzBdID0gYWQgKiBkZXQ7XG4gIG91dFsxXSA9IC1hYiAqIGRldDtcbiAgb3V0WzJdID0gLWFjICogZGV0O1xuICBvdXRbM10gPSBhYSAqIGRldDtcbiAgb3V0WzRdID0gKGFjICogYXR5IC0gYWQgKiBhdHgpICogZGV0O1xuICBvdXRbNV0gPSAoYWIgKiBhdHggLSBhYSAqIGF0eSkgKiBkZXQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQyZFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gIHJldHVybiBhWzBdICogYVszXSAtIGFbMV0gKiBhWzJdO1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDJkJ3NcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHttYXQyZH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXSxcbiAgICAgIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXSxcbiAgICAgIGIzID0gYlszXSxcbiAgICAgIGI0ID0gYls0XSxcbiAgICAgIGI1ID0gYls1XTtcbiAgb3V0WzBdID0gYTAgKiBiMCArIGEyICogYjE7XG4gIG91dFsxXSA9IGExICogYjAgKyBhMyAqIGIxO1xuICBvdXRbMl0gPSBhMCAqIGIyICsgYTIgKiBiMztcbiAgb3V0WzNdID0gYTEgKiBiMiArIGEzICogYjM7XG4gIG91dFs0XSA9IGEwICogYjQgKyBhMiAqIGI1ICsgYTQ7XG4gIG91dFs1XSA9IGExICogYjQgKyBhMyAqIGI1ICsgYTU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIG1hdDJkIGJ5IHRoZSBnaXZlbiBhbmdsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCkge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdO1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYTAgKiBjICsgYTIgKiBzO1xuICBvdXRbMV0gPSBhMSAqIGMgKyBhMyAqIHM7XG4gIG91dFsyXSA9IGEwICogLXMgKyBhMiAqIGM7XG4gIG91dFszXSA9IGExICogLXMgKyBhMyAqIGM7XG4gIG91dFs0XSA9IGE0O1xuICBvdXRbNV0gPSBhNTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTY2FsZXMgdGhlIG1hdDJkIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXHJcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdO1xuICB2YXIgdjAgPSB2WzBdLFxuICAgICAgdjEgPSB2WzFdO1xuICBvdXRbMF0gPSBhMCAqIHYwO1xuICBvdXRbMV0gPSBhMSAqIHYwO1xuICBvdXRbMl0gPSBhMiAqIHYxO1xuICBvdXRbM10gPSBhMyAqIHYxO1xuICBvdXRbNF0gPSBhNDtcbiAgb3V0WzVdID0gYTU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNsYXRlcyB0aGUgbWF0MmQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcclxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHRyYW5zbGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXSxcbiAgICAgIGE0ID0gYVs0XSxcbiAgICAgIGE1ID0gYVs1XTtcbiAgdmFyIHYwID0gdlswXSxcbiAgICAgIHYxID0gdlsxXTtcbiAgb3V0WzBdID0gYTA7XG4gIG91dFsxXSA9IGExO1xuICBvdXRbMl0gPSBhMjtcbiAgb3V0WzNdID0gYTM7XG4gIG91dFs0XSA9IGEwICogdjAgKyBhMiAqIHYxICsgYTQ7XG4gIG91dFs1XSA9IGExICogdjAgKyBhMyAqIHYxICsgYTU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGVcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQyZC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDJkLnJvdGF0ZShkZXN0LCBkZXN0LCByYWQpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IHM7XG4gIG91dFsyXSA9IC1zO1xuICBvdXRbM10gPSBjO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQyZC5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHt2ZWMyfSB2IFNjYWxpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IHZbMV07XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0MmQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQyZC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gb3V0IG1hdDJkIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7dmVjMn0gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHJhbnNsYXRpb24ob3V0LCB2KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDE7XG4gIG91dFs0XSA9IHZbMF07XG4gIG91dFs1XSA9IHZbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDJkXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IGEgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihhKSB7XG4gIHJldHVybiAnbWF0MmQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnLCAnICsgYVs0XSArICcsICcgKyBhWzVdICsgJyknO1xufVxuLyoqXHJcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQyZFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikgKyBNYXRoLnBvdyhhWzRdLCAyKSArIE1hdGgucG93KGFbNV0sIDIpICsgMSk7XG59XG4vKipcclxuICogQWRkcyB0d28gbWF0MmQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge21hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgb3V0WzNdID0gYVszXSArIGJbM107XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge21hdDJkfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgb3V0WzRdID0gYVs0XSAtIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gLSBiWzVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgbWF0cml4J3MgZWxlbWVudHMgYnlcclxuICogQHJldHVybnMge21hdDJkfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhcihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIG91dFs0XSA9IGFbNF0gKiBiO1xuICBvdXRbNV0gPSBhWzVdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQyZCdzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7bWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXHJcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHlTY2FsYXJBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXSAqIHNjYWxlO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXSAqIHNjYWxlO1xuICBvdXRbMl0gPSBhWzJdICsgYlsyXSAqIHNjYWxlO1xuICBvdXRbM10gPSBhWzNdICsgYlszXSAqIHNjYWxlO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XSAqIHNjYWxlO1xuICBvdXRbNV0gPSBhWzVdICsgYls1XSAqIHNjYWxlO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIG1hdHJpY2VzIGhhdmUgZXhhY3RseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcclxuICpcclxuICogQHBhcmFtIHttYXQyZH0gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge21hdDJkfSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXSAmJiBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV07XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDJkfSBhIFRoZSBmaXJzdCBtYXRyaXguXHJcbiAqIEBwYXJhbSB7bWF0MmR9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdLFxuICAgICAgYjQgPSBiWzRdLFxuICAgICAgYjUgPSBiWzVdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE0KSwgTWF0aC5hYnMoYjQpKSAmJiBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSk7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyZC5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0MmQuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKlxyXG4gKiAzeDMgTWF0cml4XHJcbiAqIEBtb2R1bGUgbWF0M1xyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0M1xyXG4gKlxyXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICB9XG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzRdID0gMTtcbiAgb3V0WzhdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3BpZXMgdGhlIHVwcGVyLWxlZnQgM3gzIHZhbHVlcyBpbnRvIHRoZSBnaXZlbiBtYXQzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIDN4MyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQ0fSBhICAgdGhlIHNvdXJjZSA0eDQgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTWF0NChvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVs0XTtcbiAgb3V0WzRdID0gYVs1XTtcbiAgb3V0WzVdID0gYVs2XTtcbiAgb3V0WzZdID0gYVs4XTtcbiAgb3V0WzddID0gYVs5XTtcbiAgb3V0WzhdID0gYVsxMF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBtYXQzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gYSBtYXRyaXggdG8gY2xvbmVcclxuICogQHJldHVybnMge21hdDN9IGEgbmV3IDN4MyBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MyB0byBhbm90aGVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgb3V0WzRdID0gYVs0XTtcbiAgb3V0WzVdID0gYVs1XTtcbiAgb3V0WzZdID0gYVs2XTtcbiAgb3V0WzddID0gYVs3XTtcbiAgb3V0WzhdID0gYVs4XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgbWF0MyB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMCBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAwKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAxIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDEgcG9zaXRpb24gKGluZGV4IDEpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDIgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAzKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDQpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMCBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA2KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIxIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDEgcG9zaXRpb24gKGluZGV4IDcpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjIgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggOClcclxuICogQHJldHVybnMge21hdDN9IEEgbmV3IG1hdDNcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKG0wMCwgbTAxLCBtMDIsIG0xMCwgbTExLCBtMTIsIG0yMCwgbTIxLCBtMjIpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMTA7XG4gIG91dFs0XSA9IG0xMTtcbiAgb3V0WzVdID0gbTEyO1xuICBvdXRbNl0gPSBtMjA7XG4gIG91dFs3XSA9IG0yMTtcbiAgb3V0WzhdID0gbTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIG1hdDMgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAwIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDAgcG9zaXRpb24gKGluZGV4IDApXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDEgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggMSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMiBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAyKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTEwIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDAgcG9zaXRpb24gKGluZGV4IDMpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTEgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMiBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA1KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDYpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggNylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCA4KVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgbTAwLCBtMDEsIG0wMiwgbTEwLCBtMTEsIG0xMiwgbTIwLCBtMjEsIG0yMikge1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMTA7XG4gIG91dFs0XSA9IG0xMTtcbiAgb3V0WzVdID0gbTEyO1xuICBvdXRbNl0gPSBtMjA7XG4gIG91dFs3XSA9IG0yMTtcbiAgb3V0WzhdID0gbTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCBhIG1hdDMgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDE7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gIGlmIChvdXQgPT09IGEpIHtcbiAgICB2YXIgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTEyID0gYVs1XTtcbiAgICBvdXRbMV0gPSBhWzNdO1xuICAgIG91dFsyXSA9IGFbNl07XG4gICAgb3V0WzNdID0gYTAxO1xuICAgIG91dFs1XSA9IGFbN107XG4gICAgb3V0WzZdID0gYTAyO1xuICAgIG91dFs3XSA9IGExMjtcbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbM107XG4gICAgb3V0WzJdID0gYVs2XTtcbiAgICBvdXRbM10gPSBhWzFdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs3XTtcbiAgICBvdXRbNl0gPSBhWzJdO1xuICAgIG91dFs3XSA9IGFbNV07XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogSW52ZXJ0cyBhIG1hdDNcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl07XG4gIHZhciBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV07XG4gIHZhciBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF07XG4gIHZhciBiMDEgPSBhMjIgKiBhMTEgLSBhMTIgKiBhMjE7XG4gIHZhciBiMTEgPSAtYTIyICogYTEwICsgYTEyICogYTIwO1xuICB2YXIgYjIxID0gYTIxICogYTEwIC0gYTExICogYTIwOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgdmFyIGRldCA9IGEwMCAqIGIwMSArIGEwMSAqIGIxMSArIGEwMiAqIGIyMTtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSBiMDEgKiBkZXQ7XG4gIG91dFsxXSA9ICgtYTIyICogYTAxICsgYTAyICogYTIxKSAqIGRldDtcbiAgb3V0WzJdID0gKGExMiAqIGEwMSAtIGEwMiAqIGExMSkgKiBkZXQ7XG4gIG91dFszXSA9IGIxMSAqIGRldDtcbiAgb3V0WzRdID0gKGEyMiAqIGEwMCAtIGEwMiAqIGEyMCkgKiBkZXQ7XG4gIG91dFs1XSA9ICgtYTEyICogYTAwICsgYTAyICogYTEwKSAqIGRldDtcbiAgb3V0WzZdID0gYjIxICogZGV0O1xuICBvdXRbN10gPSAoLWEyMSAqIGEwMCArIGEwMSAqIGEyMCkgKiBkZXQ7XG4gIG91dFs4XSA9IChhMTEgKiBhMDAgLSBhMDEgKiBhMTApICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGFkanVnYXRlIG9mIGEgbWF0M1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl07XG4gIHZhciBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV07XG4gIHZhciBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF07XG4gIG91dFswXSA9IGExMSAqIGEyMiAtIGExMiAqIGEyMTtcbiAgb3V0WzFdID0gYTAyICogYTIxIC0gYTAxICogYTIyO1xuICBvdXRbMl0gPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIG91dFszXSA9IGExMiAqIGEyMCAtIGExMCAqIGEyMjtcbiAgb3V0WzRdID0gYTAwICogYTIyIC0gYTAyICogYTIwO1xuICBvdXRbNV0gPSBhMDIgKiBhMTAgLSBhMDAgKiBhMTI7XG4gIG91dFs2XSA9IGExMCAqIGEyMSAtIGExMSAqIGEyMDtcbiAgb3V0WzddID0gYTAxICogYTIwIC0gYTAwICogYTIxO1xuICBvdXRbOF0gPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZXJtaW5hbnQoYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdO1xuICB2YXIgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdO1xuICB2YXIgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdO1xuICByZXR1cm4gYTAwICogKGEyMiAqIGExMSAtIGExMiAqIGEyMSkgKyBhMDEgKiAoLWEyMiAqIGExMCArIGExMiAqIGEyMCkgKyBhMDIgKiAoYTIxICogYTEwIC0gYTExICogYTIwKTtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQzJ3NcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7bWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdO1xuICB2YXIgYTEwID0gYVszXSxcbiAgICAgIGExMSA9IGFbNF0sXG4gICAgICBhMTIgPSBhWzVdO1xuICB2YXIgYTIwID0gYVs2XSxcbiAgICAgIGEyMSA9IGFbN10sXG4gICAgICBhMjIgPSBhWzhdO1xuICB2YXIgYjAwID0gYlswXSxcbiAgICAgIGIwMSA9IGJbMV0sXG4gICAgICBiMDIgPSBiWzJdO1xuICB2YXIgYjEwID0gYlszXSxcbiAgICAgIGIxMSA9IGJbNF0sXG4gICAgICBiMTIgPSBiWzVdO1xuICB2YXIgYjIwID0gYls2XSxcbiAgICAgIGIyMSA9IGJbN10sXG4gICAgICBiMjIgPSBiWzhdO1xuICBvdXRbMF0gPSBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjA7XG4gIG91dFsxXSA9IGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMTtcbiAgb3V0WzJdID0gYjAwICogYTAyICsgYjAxICogYTEyICsgYjAyICogYTIyO1xuICBvdXRbM10gPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjA7XG4gIG91dFs0XSA9IGIxMCAqIGEwMSArIGIxMSAqIGExMSArIGIxMiAqIGEyMTtcbiAgb3V0WzVdID0gYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyO1xuICBvdXRbNl0gPSBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjA7XG4gIG91dFs3XSA9IGIyMCAqIGEwMSArIGIyMSAqIGExMSArIGIyMiAqIGEyMTtcbiAgb3V0WzhdID0gYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zbGF0ZSBhIG1hdDMgYnkgdGhlIGdpdmVuIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcclxuICogQHBhcmFtIHt2ZWMyfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGExMCA9IGFbM10sXG4gICAgICBhMTEgPSBhWzRdLFxuICAgICAgYTEyID0gYVs1XSxcbiAgICAgIGEyMCA9IGFbNl0sXG4gICAgICBhMjEgPSBhWzddLFxuICAgICAgYTIyID0gYVs4XSxcbiAgICAgIHggPSB2WzBdLFxuICAgICAgeSA9IHZbMV07XG4gIG91dFswXSA9IGEwMDtcbiAgb3V0WzFdID0gYTAxO1xuICBvdXRbMl0gPSBhMDI7XG4gIG91dFszXSA9IGExMDtcbiAgb3V0WzRdID0gYTExO1xuICBvdXRbNV0gPSBhMTI7XG4gIG91dFs2XSA9IHggKiBhMDAgKyB5ICogYTEwICsgYTIwO1xuICBvdXRbN10gPSB4ICogYTAxICsgeSAqIGExMSArIGEyMTtcbiAgb3V0WzhdID0geCAqIGEwMiArIHkgKiBhMTIgKyBhMjI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIG1hdDMgYnkgdGhlIGdpdmVuIGFuZ2xlXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMTAgPSBhWzNdLFxuICAgICAgYTExID0gYVs0XSxcbiAgICAgIGExMiA9IGFbNV0sXG4gICAgICBhMjAgPSBhWzZdLFxuICAgICAgYTIxID0gYVs3XSxcbiAgICAgIGEyMiA9IGFbOF0sXG4gICAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBjICogYTAwICsgcyAqIGExMDtcbiAgb3V0WzFdID0gYyAqIGEwMSArIHMgKiBhMTE7XG4gIG91dFsyXSA9IGMgKiBhMDIgKyBzICogYTEyO1xuICBvdXRbM10gPSBjICogYTEwIC0gcyAqIGEwMDtcbiAgb3V0WzRdID0gYyAqIGExMSAtIHMgKiBhMDE7XG4gIG91dFs1XSA9IGMgKiBhMTIgLSBzICogYTAyO1xuICBvdXRbNl0gPSBhMjA7XG4gIG91dFs3XSA9IGEyMTtcbiAgb3V0WzhdID0gYTIyO1xuICByZXR1cm4gb3V0O1xufVxuO1xuLyoqXHJcbiAqIFNjYWxlcyB0aGUgbWF0MyBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKiovXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIHYpIHtcbiAgdmFyIHggPSB2WzBdLFxuICAgICAgeSA9IHZbMV07XG4gIG91dFswXSA9IHggKiBhWzBdO1xuICBvdXRbMV0gPSB4ICogYVsxXTtcbiAgb3V0WzJdID0geCAqIGFbMl07XG4gIG91dFszXSA9IHkgKiBhWzNdO1xuICBvdXRbNF0gPSB5ICogYVs0XTtcbiAgb3V0WzVdID0geSAqIGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0My5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDMudHJhbnNsYXRlKGRlc3QsIGRlc3QsIHZlYyk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHt2ZWMyfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdikge1xuICBvdXRbMF0gPSAxO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAxO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSB2WzBdO1xuICBvdXRbN10gPSB2WzFdO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0My5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDMucm90YXRlKGRlc3QsIGRlc3QsIHJhZCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYztcbiAgb3V0WzFdID0gcztcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gLXM7XG4gIG91dFs0XSA9IGM7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQzLmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0My5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7dmVjMn0gdiBTY2FsaW5nIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHZbMV07XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29waWVzIHRoZSB2YWx1ZXMgZnJvbSBhIG1hdDJkIGludG8gYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byBjb3B5XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICoqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbU1hdDJkKG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSBhWzJdO1xuICBvdXRbNF0gPSBhWzNdO1xuICBvdXRbNV0gPSAwO1xuICBvdXRbNl0gPSBhWzRdO1xuICBvdXRbN10gPSBhWzVdO1xuICBvdXRbOF0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiogQ2FsY3VsYXRlcyBhIDN4MyBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gcXVhdGVybmlvblxyXG4qXHJcbiogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4qIEBwYXJhbSB7cXVhdH0gcSBRdWF0ZXJuaW9uIHRvIGNyZWF0ZSBtYXRyaXggZnJvbVxyXG4qXHJcbiogQHJldHVybnMge21hdDN9IG91dFxyXG4qL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVF1YXQob3V0LCBxKSB7XG4gIHZhciB4ID0gcVswXSxcbiAgICAgIHkgPSBxWzFdLFxuICAgICAgeiA9IHFbMl0sXG4gICAgICB3ID0gcVszXTtcbiAgdmFyIHgyID0geCArIHg7XG4gIHZhciB5MiA9IHkgKyB5O1xuICB2YXIgejIgPSB6ICsgejtcbiAgdmFyIHh4ID0geCAqIHgyO1xuICB2YXIgeXggPSB5ICogeDI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHp4ID0geiAqIHgyO1xuICB2YXIgenkgPSB6ICogeTI7XG4gIHZhciB6eiA9IHogKiB6MjtcbiAgdmFyIHd4ID0gdyAqIHgyO1xuICB2YXIgd3kgPSB3ICogeTI7XG4gIHZhciB3eiA9IHcgKiB6MjtcbiAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gIG91dFszXSA9IHl4IC0gd3o7XG4gIG91dFs2XSA9IHp4ICsgd3k7XG4gIG91dFsxXSA9IHl4ICsgd3o7XG4gIG91dFs0XSA9IDEgLSB4eCAtIHp6O1xuICBvdXRbN10gPSB6eSAtIHd4O1xuICBvdXRbMl0gPSB6eCAtIHd5O1xuICBvdXRbNV0gPSB6eSArIHd4O1xuICBvdXRbOF0gPSAxIC0geHggLSB5eTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4qIENhbGN1bGF0ZXMgYSAzeDMgbm9ybWFsIG1hdHJpeCAodHJhbnNwb3NlIGludmVyc2UpIGZyb20gdGhlIDR4NCBtYXRyaXhcclxuKlxyXG4qIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuKiBAcGFyYW0ge21hdDR9IGEgTWF0NCB0byBkZXJpdmUgdGhlIG5vcm1hbCBtYXRyaXggZnJvbVxyXG4qXHJcbiogQHJldHVybnMge21hdDN9IG91dFxyXG4qL1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsRnJvbU1hdDQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICB2YXIgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICB2YXIgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICB2YXIgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICB2YXIgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICB2YXIgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICB2YXIgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICB2YXIgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICB2YXIgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICB2YXIgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICB2YXIgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICB2YXIgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICB2YXIgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgdmFyIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgb3V0WzFdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gIG91dFsyXSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICBvdXRbM10gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgb3V0WzRdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs1XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICBvdXRbNl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgb3V0WzddID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gIG91dFs4XSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIDJEIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCBXaWR0aCBvZiB5b3VyIGdsIGNvbnRleHRcclxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBIZWlnaHQgb2YgZ2wgY29udGV4dFxyXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcHJvamVjdGlvbihvdXQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgb3V0WzBdID0gMiAvIHdpZHRoO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAtMiAvIGhlaWdodDtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gLTE7XG4gIG91dFs3XSA9IDE7XG4gIG91dFs4XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDNcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gJ21hdDMoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnLCAnICsgYVs0XSArICcsICcgKyBhWzVdICsgJywgJyArIGFbNl0gKyAnLCAnICsgYVs3XSArICcsICcgKyBhWzhdICsgJyknO1xufVxuLyoqXHJcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb2IoYSkge1xuICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpICsgTWF0aC5wb3coYVs0XSwgMikgKyBNYXRoLnBvdyhhWzVdLCAyKSArIE1hdGgucG93KGFbNl0sIDIpICsgTWF0aC5wb3coYVs3XSwgMikgKyBNYXRoLnBvdyhhWzhdLCAyKSk7XG59XG4vKipcclxuICogQWRkcyB0d28gbWF0MydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIG91dFszXSA9IGFbM10gKyBiWzNdO1xuICBvdXRbNF0gPSBhWzRdICsgYls0XTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gKyBiWzZdO1xuICBvdXRbN10gPSBhWzddICsgYls3XTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU3VidHJhY3RzIG1hdHJpeCBiIGZyb20gbWF0cml4IGFcclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7bWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC0gYlszXTtcbiAgb3V0WzRdID0gYVs0XSAtIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gLSBiWzVdO1xuICBvdXRbNl0gPSBhWzZdIC0gYls2XTtcbiAgb3V0WzddID0gYVs3XSAtIGJbN107XG4gIG91dFs4XSA9IGFbOF0gLSBiWzhdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGJ5XHJcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhcihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIG91dFs0XSA9IGFbNF0gKiBiO1xuICBvdXRbNV0gPSBhWzVdICogYjtcbiAgb3V0WzZdID0gYVs2XSAqIGI7XG4gIG91dFs3XSA9IGFbN10gKiBiO1xuICBvdXRbOF0gPSBhWzhdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byBtYXQzJ3MgYWZ0ZXIgbXVsdGlwbHlpbmcgZWFjaCBlbGVtZW50IG9mIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZS5cclxuICpcclxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7bWF0M30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYidzIGVsZW1lbnRzIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge21hdDN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5U2NhbGFyQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgb3V0WzNdID0gYVszXSArIGJbM10gKiBzY2FsZTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF0gKiBzY2FsZTtcbiAgb3V0WzVdID0gYVs1XSArIGJbNV0gKiBzY2FsZTtcbiAgb3V0WzZdID0gYVs2XSArIGJbNl0gKiBzY2FsZTtcbiAgb3V0WzddID0gYVs3XSArIGJbN10gKiBzY2FsZTtcbiAgb3V0WzhdID0gYVs4XSArIGJbOF0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge21hdDN9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdICYmIGFbNF0gPT09IGJbNF0gJiYgYVs1XSA9PT0gYls1XSAmJiBhWzZdID09PSBiWzZdICYmIGFbN10gPT09IGJbN10gJiYgYVs4XSA9PT0gYls4XTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0M30gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge21hdDN9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdLFxuICAgICAgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdLFxuICAgICAgYTYgPSBhWzZdLFxuICAgICAgYTcgPSBhWzddLFxuICAgICAgYTggPSBhWzhdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdLFxuICAgICAgYjQgPSBiWzRdLFxuICAgICAgYjUgPSBiWzVdLFxuICAgICAgYjYgPSBiWzZdLFxuICAgICAgYjcgPSBiWzddLFxuICAgICAgYjggPSBiWzhdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE0KSwgTWF0aC5hYnMoYjQpKSAmJiBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSkgJiYgTWF0aC5hYnMoYTYgLSBiNikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTYpLCBNYXRoLmFicyhiNikpICYmIE1hdGguYWJzKGE3IC0gYjcpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE3KSwgTWF0aC5hYnMoYjcpKSAmJiBNYXRoLmFicyhhOCAtIGI4KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOCksIE1hdGguYWJzKGI4KSk7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBtYXQzLm11bHRpcGx5fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgbXVsID0gbXVsdGlwbHk7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBtYXQzLnN1YnRyYWN0fVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc3ViID0gc3VidHJhY3Q7IiwiaW1wb3J0ICogYXMgZ2xNYXRyaXggZnJvbSBcIi4vY29tbW9uLmpzXCI7XG4vKipcclxuICogNHg0IE1hdHJpeDxicj5Gb3JtYXQ6IGNvbHVtbi1tYWpvciwgd2hlbiB0eXBlZCBvdXQgaXQgbG9va3MgbGlrZSByb3ctbWFqb3I8YnI+VGhlIG1hdHJpY2VzIGFyZSBiZWluZyBwb3N0IG11bHRpcGxpZWQuXHJcbiAqIEBtb2R1bGUgbWF0NFxyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0NFxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bWF0NH0gYSBuZXcgNHg0IG1hdHJpeFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDE2KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gIH1cblxuICBvdXRbMF0gPSAxO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbMTBdID0gMTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBtYXQ0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gYSBtYXRyaXggdG8gY2xvbmVcclxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgxNik7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIG91dFs5XSA9IGFbOV07XG4gIG91dFsxMF0gPSBhWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdO1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDQgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF07XG4gIG91dFs1XSA9IGFbNV07XG4gIG91dFs2XSA9IGFbNl07XG4gIG91dFs3XSA9IGFbN107XG4gIG91dFs4XSA9IGFbOF07XG4gIG91dFs5XSA9IGFbOV07XG4gIG91dFsxMF0gPSBhWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdO1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlIGEgbmV3IG1hdDQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDMgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA0KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDUpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMyBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAzIHBvc2l0aW9uIChpbmRleCA3KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDgpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggOSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMyBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxMSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMCBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAxMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMSBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxMylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMiBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMyBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxNSlcclxuICogQHJldHVybnMge21hdDR9IEEgbmV3IG1hdDRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKG0wMCwgbTAxLCBtMDIsIG0wMywgbTEwLCBtMTEsIG0xMiwgbTEzLCBtMjAsIG0yMSwgbTIyLCBtMjMsIG0zMCwgbTMxLCBtMzIsIG0zMykge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMDM7XG4gIG91dFs0XSA9IG0xMDtcbiAgb3V0WzVdID0gbTExO1xuICBvdXRbNl0gPSBtMTI7XG4gIG91dFs3XSA9IG0xMztcbiAgb3V0WzhdID0gbTIwO1xuICBvdXRbOV0gPSBtMjE7XG4gIG91dFsxMF0gPSBtMjI7XG4gIG91dFsxMV0gPSBtMjM7XG4gIG91dFsxMl0gPSBtMzA7XG4gIG91dFsxM10gPSBtMzE7XG4gIG91dFsxNF0gPSBtMzI7XG4gIG91dFsxNV0gPSBtMzM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgbWF0NCB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDAgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMCBwb3NpdGlvbiAoaW5kZXggMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0wMSBDb21wb25lbnQgaW4gY29sdW1uIDAsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTAyIENvbXBvbmVudCBpbiBjb2x1bW4gMCwgcm93IDIgcG9zaXRpb24gKGluZGV4IDIpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMDMgQ29tcG9uZW50IGluIGNvbHVtbiAwLCByb3cgMyBwb3NpdGlvbiAoaW5kZXggMylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMCBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAwIHBvc2l0aW9uIChpbmRleCA0KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTExIENvbXBvbmVudCBpbiBjb2x1bW4gMSwgcm93IDEgcG9zaXRpb24gKGluZGV4IDUpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMTIgQ29tcG9uZW50IGluIGNvbHVtbiAxLCByb3cgMiBwb3NpdGlvbiAoaW5kZXggNilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0xMyBDb21wb25lbnQgaW4gY29sdW1uIDEsIHJvdyAzIHBvc2l0aW9uIChpbmRleCA3KVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbTIwIENvbXBvbmVudCBpbiBjb2x1bW4gMiwgcm93IDAgcG9zaXRpb24gKGluZGV4IDgpXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtMjEgQ29tcG9uZW50IGluIGNvbHVtbiAyLCByb3cgMSBwb3NpdGlvbiAoaW5kZXggOSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMiBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxMClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0yMyBDb21wb25lbnQgaW4gY29sdW1uIDIsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxMSlcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMCBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAwIHBvc2l0aW9uIChpbmRleCAxMilcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMSBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAxIHBvc2l0aW9uIChpbmRleCAxMylcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMiBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAyIHBvc2l0aW9uIChpbmRleCAxNClcclxuICogQHBhcmFtIHtOdW1iZXJ9IG0zMyBDb21wb25lbnQgaW4gY29sdW1uIDMsIHJvdyAzIHBvc2l0aW9uIChpbmRleCAxNSlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChvdXQsIG0wMCwgbTAxLCBtMDIsIG0wMywgbTEwLCBtMTEsIG0xMiwgbTEzLCBtMjAsIG0yMSwgbTIyLCBtMjMsIG0zMCwgbTMxLCBtMzIsIG0zMykge1xuICBvdXRbMF0gPSBtMDA7XG4gIG91dFsxXSA9IG0wMTtcbiAgb3V0WzJdID0gbTAyO1xuICBvdXRbM10gPSBtMDM7XG4gIG91dFs0XSA9IG0xMDtcbiAgb3V0WzVdID0gbTExO1xuICBvdXRbNl0gPSBtMTI7XG4gIG91dFs3XSA9IG0xMztcbiAgb3V0WzhdID0gbTIwO1xuICBvdXRbOV0gPSBtMjE7XG4gIG91dFsxMF0gPSBtMjI7XG4gIG91dFsxMV0gPSBtMjM7XG4gIG91dFsxMl0gPSBtMzA7XG4gIG91dFsxM10gPSBtMzE7XG4gIG91dFsxNF0gPSBtMzI7XG4gIG91dFsxNV0gPSBtMzM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IGEgbWF0NCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMTtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc3Bvc2Uob3V0LCBhKSB7XG4gIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgaWYgKG91dCA9PT0gYSkge1xuICAgIHZhciBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdO1xuICAgIHZhciBhMTIgPSBhWzZdLFxuICAgICAgICBhMTMgPSBhWzddO1xuICAgIHZhciBhMjMgPSBhWzExXTtcbiAgICBvdXRbMV0gPSBhWzRdO1xuICAgIG91dFsyXSA9IGFbOF07XG4gICAgb3V0WzNdID0gYVsxMl07XG4gICAgb3V0WzRdID0gYTAxO1xuICAgIG91dFs2XSA9IGFbOV07XG4gICAgb3V0WzddID0gYVsxM107XG4gICAgb3V0WzhdID0gYTAyO1xuICAgIG91dFs5XSA9IGExMjtcbiAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgb3V0WzEyXSA9IGEwMztcbiAgICBvdXRbMTNdID0gYTEzO1xuICAgIG91dFsxNF0gPSBhMjM7XG4gIH0gZWxzZSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzRdO1xuICAgIG91dFsyXSA9IGFbOF07XG4gICAgb3V0WzNdID0gYVsxMl07XG4gICAgb3V0WzRdID0gYVsxXTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbOV07XG4gICAgb3V0WzddID0gYVsxM107XG4gICAgb3V0WzhdID0gYVsyXTtcbiAgICBvdXRbOV0gPSBhWzZdO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgb3V0WzEyXSA9IGFbM107XG4gICAgb3V0WzEzXSA9IGFbN107XG4gICAgb3V0WzE0XSA9IGFbMTFdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogSW52ZXJ0cyBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgICAgYTAxID0gYVsxXSxcbiAgICAgIGEwMiA9IGFbMl0sXG4gICAgICBhMDMgPSBhWzNdO1xuICB2YXIgYTEwID0gYVs0XSxcbiAgICAgIGExMSA9IGFbNV0sXG4gICAgICBhMTIgPSBhWzZdLFxuICAgICAgYTEzID0gYVs3XTtcbiAgdmFyIGEyMCA9IGFbOF0sXG4gICAgICBhMjEgPSBhWzldLFxuICAgICAgYTIyID0gYVsxMF0sXG4gICAgICBhMjMgPSBhWzExXTtcbiAgdmFyIGEzMCA9IGFbMTJdLFxuICAgICAgYTMxID0gYVsxM10sXG4gICAgICBhMzIgPSBhWzE0XSxcbiAgICAgIGEzMyA9IGFbMTVdO1xuICB2YXIgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwO1xuICB2YXIgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwO1xuICB2YXIgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICB2YXIgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExO1xuICB2YXIgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExO1xuICB2YXIgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICB2YXIgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwO1xuICB2YXIgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwO1xuICB2YXIgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICB2YXIgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxO1xuICB2YXIgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxO1xuICB2YXIgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyOyAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG5cbiAgdmFyIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICBpZiAoIWRldCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGV0ID0gMS4wIC8gZGV0O1xuICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGpvaW50KG91dCwgYSkge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICAgIGEwMSA9IGFbMV0sXG4gICAgICBhMDIgPSBhWzJdLFxuICAgICAgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF0sXG4gICAgICBhMTEgPSBhWzVdLFxuICAgICAgYTEyID0gYVs2XSxcbiAgICAgIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdLFxuICAgICAgYTIxID0gYVs5XSxcbiAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgYTIzID0gYVsxMV07XG4gIHZhciBhMzAgPSBhWzEyXSxcbiAgICAgIGEzMSA9IGFbMTNdLFxuICAgICAgYTMyID0gYVsxNF0sXG4gICAgICBhMzMgPSBhWzE1XTtcbiAgb3V0WzBdID0gYTExICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpO1xuICBvdXRbMV0gPSAtKGEwMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gIG91dFsyXSA9IGEwMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTExICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKTtcbiAgb3V0WzNdID0gLShhMDEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICBvdXRbNF0gPSAtKGExMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSk7XG4gIG91dFs1XSA9IGEwMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKTtcbiAgb3V0WzZdID0gLShhMDAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICBvdXRbN10gPSBhMDAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMik7XG4gIG91dFs4XSA9IGExMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKTtcbiAgb3V0WzldID0gLShhMDAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkpO1xuICBvdXRbMTBdID0gYTAwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpO1xuICBvdXRbMTFdID0gLShhMDAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSkpO1xuICBvdXRbMTJdID0gLShhMTAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkpO1xuICBvdXRbMTNdID0gYTAwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpO1xuICBvdXRbMTRdID0gLShhMDAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xuICBvdXRbMTVdID0gYTAwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0NFxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcclxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdLFxuICAgICAgYTExID0gYVs1XSxcbiAgICAgIGExMiA9IGFbNl0sXG4gICAgICBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XSxcbiAgICAgIGEyMSA9IGFbOV0sXG4gICAgICBhMjIgPSBhWzEwXSxcbiAgICAgIGEyMyA9IGFbMTFdO1xuICB2YXIgYTMwID0gYVsxMl0sXG4gICAgICBhMzEgPSBhWzEzXSxcbiAgICAgIGEzMiA9IGFbMTRdLFxuICAgICAgYTMzID0gYVsxNV07XG4gIHZhciBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTA7XG4gIHZhciBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XG4gIHZhciBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7XG4gIHZhciBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTE7XG4gIHZhciBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7XG4gIHZhciBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7XG4gIHZhciBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzA7XG4gIHZhciBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7XG4gIHZhciBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7XG4gIHZhciBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzE7XG4gIHZhciBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XG4gIHZhciBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7IC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcblxuICByZXR1cm4gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgICBhMDEgPSBhWzFdLFxuICAgICAgYTAyID0gYVsyXSxcbiAgICAgIGEwMyA9IGFbM107XG4gIHZhciBhMTAgPSBhWzRdLFxuICAgICAgYTExID0gYVs1XSxcbiAgICAgIGExMiA9IGFbNl0sXG4gICAgICBhMTMgPSBhWzddO1xuICB2YXIgYTIwID0gYVs4XSxcbiAgICAgIGEyMSA9IGFbOV0sXG4gICAgICBhMjIgPSBhWzEwXSxcbiAgICAgIGEyMyA9IGFbMTFdO1xuICB2YXIgYTMwID0gYVsxMl0sXG4gICAgICBhMzEgPSBhWzEzXSxcbiAgICAgIGEzMiA9IGFbMTRdLFxuICAgICAgYTMzID0gYVsxNV07IC8vIENhY2hlIG9ubHkgdGhlIGN1cnJlbnQgbGluZSBvZiB0aGUgc2Vjb25kIG1hdHJpeFxuXG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl0sXG4gICAgICBiMyA9IGJbM107XG4gIG91dFswXSA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwO1xuICBvdXRbMV0gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcbiAgb3V0WzJdID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7XG4gIG91dFszXSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xuICBiMCA9IGJbNF07XG4gIGIxID0gYls1XTtcbiAgYjIgPSBiWzZdO1xuICBiMyA9IGJbN107XG4gIG91dFs0XSA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwO1xuICBvdXRbNV0gPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTtcbiAgb3V0WzZdID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7XG4gIG91dFs3XSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xuICBiMCA9IGJbOF07XG4gIGIxID0gYls5XTtcbiAgYjIgPSBiWzEwXTtcbiAgYjMgPSBiWzExXTtcbiAgb3V0WzhdID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7XG4gIG91dFs5XSA9IGIwICogYTAxICsgYjEgKiBhMTEgKyBiMiAqIGEyMSArIGIzICogYTMxO1xuICBvdXRbMTBdID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7XG4gIG91dFsxMV0gPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMztcbiAgYjAgPSBiWzEyXTtcbiAgYjEgPSBiWzEzXTtcbiAgYjIgPSBiWzE0XTtcbiAgYjMgPSBiWzE1XTtcbiAgb3V0WzEyXSA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwO1xuICBvdXRbMTNdID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7XG4gIG91dFsxNF0gPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjtcbiAgb3V0WzE1XSA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zbGF0ZSBhIG1hdDQgYnkgdGhlIGdpdmVuIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcclxuICogQHBhcmFtIHt2ZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgdmFyIHggPSB2WzBdLFxuICAgICAgeSA9IHZbMV0sXG4gICAgICB6ID0gdlsyXTtcbiAgdmFyIGEwMCwgYTAxLCBhMDIsIGEwMztcbiAgdmFyIGExMCwgYTExLCBhMTIsIGExMztcbiAgdmFyIGEyMCwgYTIxLCBhMjIsIGEyMztcblxuICBpZiAoYSA9PT0gb3V0KSB7XG4gICAgb3V0WzEyXSA9IGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiArIGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzNdICogeCArIGFbN10gKiB5ICsgYVsxMV0gKiB6ICsgYVsxNV07XG4gIH0gZWxzZSB7XG4gICAgYTAwID0gYVswXTtcbiAgICBhMDEgPSBhWzFdO1xuICAgIGEwMiA9IGFbMl07XG4gICAgYTAzID0gYVszXTtcbiAgICBhMTAgPSBhWzRdO1xuICAgIGExMSA9IGFbNV07XG4gICAgYTEyID0gYVs2XTtcbiAgICBhMTMgPSBhWzddO1xuICAgIGEyMCA9IGFbOF07XG4gICAgYTIxID0gYVs5XTtcbiAgICBhMjIgPSBhWzEwXTtcbiAgICBhMjMgPSBhWzExXTtcbiAgICBvdXRbMF0gPSBhMDA7XG4gICAgb3V0WzFdID0gYTAxO1xuICAgIG91dFsyXSA9IGEwMjtcbiAgICBvdXRbM10gPSBhMDM7XG4gICAgb3V0WzRdID0gYTEwO1xuICAgIG91dFs1XSA9IGExMTtcbiAgICBvdXRbNl0gPSBhMTI7XG4gICAgb3V0WzddID0gYTEzO1xuICAgIG91dFs4XSA9IGEyMDtcbiAgICBvdXRbOV0gPSBhMjE7XG4gICAgb3V0WzEwXSA9IGEyMjtcbiAgICBvdXRbMTFdID0gYTIzO1xuICAgIG91dFsxMl0gPSBhMDAgKiB4ICsgYTEwICogeSArIGEyMCAqIHogKyBhWzEyXTtcbiAgICBvdXRbMTNdID0gYTAxICogeCArIGExMSAqIHkgKyBhMjEgKiB6ICsgYVsxM107XG4gICAgb3V0WzE0XSA9IGEwMiAqIHggKyBhMTIgKiB5ICsgYTIyICogeiArIGFbMTRdO1xuICAgIG91dFsxNV0gPSBhMDMgKiB4ICsgYTEzICogeSArIGEyMyAqIHogKyBhWzE1XTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIHRoZSBtYXQ0IGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMzIG5vdCB1c2luZyB2ZWN0b3JpemF0aW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7dmVjM30gdiB0aGUgdmVjMyB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICoqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gIHZhciB4ID0gdlswXSxcbiAgICAgIHkgPSB2WzFdLFxuICAgICAgeiA9IHZbMl07XG4gIG91dFswXSA9IGFbMF0gKiB4O1xuICBvdXRbMV0gPSBhWzFdICogeDtcbiAgb3V0WzJdID0gYVsyXSAqIHg7XG4gIG91dFszXSA9IGFbM10gKiB4O1xuICBvdXRbNF0gPSBhWzRdICogeTtcbiAgb3V0WzVdID0gYVs1XSAqIHk7XG4gIG91dFs2XSA9IGFbNl0gKiB5O1xuICBvdXRbN10gPSBhWzddICogeTtcbiAgb3V0WzhdID0gYVs4XSAqIHo7XG4gIG91dFs5XSA9IGFbOV0gKiB6O1xuICBvdXRbMTBdID0gYVsxMF0gKiB6O1xuICBvdXRbMTFdID0gYVsxMV0gKiB6O1xuICBvdXRbMTJdID0gYVsxMl07XG4gIG91dFsxM10gPSBhWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdO1xuICBvdXRbMTVdID0gYVsxNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIG1hdDQgYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgZ2l2ZW4gYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCwgYXhpcykge1xuICB2YXIgeCA9IGF4aXNbMF0sXG4gICAgICB5ID0gYXhpc1sxXSxcbiAgICAgIHogPSBheGlzWzJdO1xuICB2YXIgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7XG4gIHZhciBzLCBjLCB0O1xuICB2YXIgYTAwLCBhMDEsIGEwMiwgYTAzO1xuICB2YXIgYTEwLCBhMTEsIGExMiwgYTEzO1xuICB2YXIgYTIwLCBhMjEsIGEyMiwgYTIzO1xuICB2YXIgYjAwLCBiMDEsIGIwMjtcbiAgdmFyIGIxMCwgYjExLCBiMTI7XG4gIHZhciBiMjAsIGIyMSwgYjIyO1xuXG4gIGlmIChsZW4gPCBnbE1hdHJpeC5FUFNJTE9OKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBsZW4gPSAxIC8gbGVuO1xuICB4ICo9IGxlbjtcbiAgeSAqPSBsZW47XG4gIHogKj0gbGVuO1xuICBzID0gTWF0aC5zaW4ocmFkKTtcbiAgYyA9IE1hdGguY29zKHJhZCk7XG4gIHQgPSAxIC0gYztcbiAgYTAwID0gYVswXTtcbiAgYTAxID0gYVsxXTtcbiAgYTAyID0gYVsyXTtcbiAgYTAzID0gYVszXTtcbiAgYTEwID0gYVs0XTtcbiAgYTExID0gYVs1XTtcbiAgYTEyID0gYVs2XTtcbiAgYTEzID0gYVs3XTtcbiAgYTIwID0gYVs4XTtcbiAgYTIxID0gYVs5XTtcbiAgYTIyID0gYVsxMF07XG4gIGEyMyA9IGFbMTFdOyAvLyBDb25zdHJ1Y3QgdGhlIGVsZW1lbnRzIG9mIHRoZSByb3RhdGlvbiBtYXRyaXhcblxuICBiMDAgPSB4ICogeCAqIHQgKyBjO1xuICBiMDEgPSB5ICogeCAqIHQgKyB6ICogcztcbiAgYjAyID0geiAqIHggKiB0IC0geSAqIHM7XG4gIGIxMCA9IHggKiB5ICogdCAtIHogKiBzO1xuICBiMTEgPSB5ICogeSAqIHQgKyBjO1xuICBiMTIgPSB6ICogeSAqIHQgKyB4ICogcztcbiAgYjIwID0geCAqIHogKiB0ICsgeSAqIHM7XG4gIGIyMSA9IHkgKiB6ICogdCAtIHggKiBzO1xuICBiMjIgPSB6ICogeiAqIHQgKyBjOyAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG4gIG91dFswXSA9IGEwMCAqIGIwMCArIGExMCAqIGIwMSArIGEyMCAqIGIwMjtcbiAgb3V0WzFdID0gYTAxICogYjAwICsgYTExICogYjAxICsgYTIxICogYjAyO1xuICBvdXRbMl0gPSBhMDIgKiBiMDAgKyBhMTIgKiBiMDEgKyBhMjIgKiBiMDI7XG4gIG91dFszXSA9IGEwMyAqIGIwMCArIGExMyAqIGIwMSArIGEyMyAqIGIwMjtcbiAgb3V0WzRdID0gYTAwICogYjEwICsgYTEwICogYjExICsgYTIwICogYjEyO1xuICBvdXRbNV0gPSBhMDEgKiBiMTAgKyBhMTEgKiBiMTEgKyBhMjEgKiBiMTI7XG4gIG91dFs2XSA9IGEwMiAqIGIxMCArIGExMiAqIGIxMSArIGEyMiAqIGIxMjtcbiAgb3V0WzddID0gYTAzICogYjEwICsgYTEzICogYjExICsgYTIzICogYjEyO1xuICBvdXRbOF0gPSBhMDAgKiBiMjAgKyBhMTAgKiBiMjEgKyBhMjAgKiBiMjI7XG4gIG91dFs5XSA9IGEwMSAqIGIyMCArIGExMSAqIGIyMSArIGEyMSAqIGIyMjtcbiAgb3V0WzEwXSA9IGEwMiAqIGIyMCArIGExMiAqIGIyMSArIGEyMiAqIGIyMjtcbiAgb3V0WzExXSA9IGEwMyAqIGIyMCArIGExMyAqIGIyMSArIGEyMyAqIGIyMjtcblxuICBpZiAoYSAhPT0gb3V0KSB7XG4gICAgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTtcbiAgdmFyIGExMCA9IGFbNF07XG4gIHZhciBhMTEgPSBhWzVdO1xuICB2YXIgYTEyID0gYVs2XTtcbiAgdmFyIGExMyA9IGFbN107XG4gIHZhciBhMjAgPSBhWzhdO1xuICB2YXIgYTIxID0gYVs5XTtcbiAgdmFyIGEyMiA9IGFbMTBdO1xuICB2YXIgYTIzID0gYVsxMV07XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgfSAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cblxuICBvdXRbNF0gPSBhMTAgKiBjICsgYTIwICogcztcbiAgb3V0WzVdID0gYTExICogYyArIGEyMSAqIHM7XG4gIG91dFs2XSA9IGExMiAqIGMgKyBhMjIgKiBzO1xuICBvdXRbN10gPSBhMTMgKiBjICsgYTIzICogcztcbiAgb3V0WzhdID0gYTIwICogYyAtIGExMCAqIHM7XG4gIG91dFs5XSA9IGEyMSAqIGMgLSBhMTEgKiBzO1xuICBvdXRbMTBdID0gYTIyICogYyAtIGExMiAqIHM7XG4gIG91dFsxMV0gPSBhMjMgKiBjIC0gYTEzICogcztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7XG4gIHZhciBhMDAgPSBhWzBdO1xuICB2YXIgYTAxID0gYVsxXTtcbiAgdmFyIGEwMiA9IGFbMl07XG4gIHZhciBhMDMgPSBhWzNdO1xuICB2YXIgYTIwID0gYVs4XTtcbiAgdmFyIGEyMSA9IGFbOV07XG4gIHZhciBhMjIgPSBhWzEwXTtcbiAgdmFyIGEyMyA9IGFbMTFdO1xuXG4gIGlmIChhICE9PSBvdXQpIHtcbiAgICAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gIH0gLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG5cbiAgb3V0WzBdID0gYTAwICogYyAtIGEyMCAqIHM7XG4gIG91dFsxXSA9IGEwMSAqIGMgLSBhMjEgKiBzO1xuICBvdXRbMl0gPSBhMDIgKiBjIC0gYTIyICogcztcbiAgb3V0WzNdID0gYTAzICogYyAtIGEyMyAqIHM7XG4gIG91dFs4XSA9IGEwMCAqIHMgKyBhMjAgKiBjO1xuICBvdXRbOV0gPSBhMDEgKiBzICsgYTIxICogYztcbiAgb3V0WzEwXSA9IGEwMiAqIHMgKyBhMjIgKiBjO1xuICBvdXRbMTFdID0gYTAzICogcyArIGEyMyAqIGM7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcclxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB2YXIgYTAwID0gYVswXTtcbiAgdmFyIGEwMSA9IGFbMV07XG4gIHZhciBhMDIgPSBhWzJdO1xuICB2YXIgYTAzID0gYVszXTtcbiAgdmFyIGExMCA9IGFbNF07XG4gIHZhciBhMTEgPSBhWzVdO1xuICB2YXIgYTEyID0gYVs2XTtcbiAgdmFyIGExMyA9IGFbN107XG5cbiAgaWYgKGEgIT09IG91dCkge1xuICAgIC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICBvdXRbOV0gPSBhWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICB9IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuXG4gIG91dFswXSA9IGEwMCAqIGMgKyBhMTAgKiBzO1xuICBvdXRbMV0gPSBhMDEgKiBjICsgYTExICogcztcbiAgb3V0WzJdID0gYTAyICogYyArIGExMiAqIHM7XG4gIG91dFszXSA9IGEwMyAqIGMgKyBhMTMgKiBzO1xuICBvdXRbNF0gPSBhMTAgKiBjIC0gYTAwICogcztcbiAgb3V0WzVdID0gYTExICogYyAtIGEwMSAqIHM7XG4gIG91dFs2XSA9IGExMiAqIGMgLSBhMDIgKiBzO1xuICBvdXRbN10gPSBhMTMgKiBjIC0gYTAzICogcztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHJhbnNsYXRpb24ob3V0LCB2KSB7XG4gIG91dFswXSA9IDE7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDE7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSAxO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IHZbMF07XG4gIG91dFsxM10gPSB2WzFdO1xuICBvdXRbMTRdID0gdlsyXTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBkZXN0LCB2ZWMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7dmVjM30gdiBTY2FsaW5nIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IHZbMV07XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IDA7XG4gIG91dFs5XSA9IDA7XG4gIG91dFsxMF0gPSB2WzJdO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGUgYXJvdW5kIGEgZ2l2ZW4gYXhpc1xyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnJvdGF0ZShkZXN0LCBkZXN0LCByYWQsIGF4aXMpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCByYWQsIGF4aXMpIHtcbiAgdmFyIHggPSBheGlzWzBdLFxuICAgICAgeSA9IGF4aXNbMV0sXG4gICAgICB6ID0gYXhpc1syXTtcbiAgdmFyIGxlbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xuICB2YXIgcywgYywgdDtcblxuICBpZiAobGVuIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGVuID0gMSAvIGxlbjtcbiAgeCAqPSBsZW47XG4gIHkgKj0gbGVuO1xuICB6ICo9IGxlbjtcbiAgcyA9IE1hdGguc2luKHJhZCk7XG4gIGMgPSBNYXRoLmNvcyhyYWQpO1xuICB0ID0gMSAtIGM7IC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0geCAqIHggKiB0ICsgYztcbiAgb3V0WzFdID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIG91dFsyXSA9IHogKiB4ICogdCAtIHkgKiBzO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4ICogeSAqIHQgLSB6ICogcztcbiAgb3V0WzVdID0geSAqIHkgKiB0ICsgYztcbiAgb3V0WzZdID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHggKiB6ICogdCArIHkgKiBzO1xuICBvdXRbOV0gPSB5ICogeiAqIHQgLSB4ICogcztcbiAgb3V0WzEwXSA9IHogKiB6ICogdCArIGM7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXHJcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxyXG4gKlxyXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcclxuICogICAgIG1hdDQucm90YXRlWChkZXN0LCBkZXN0LCByYWQpO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tWFJvdGF0aW9uKG91dCwgcmFkKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGMgPSBNYXRoLmNvcyhyYWQpOyAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG5cbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gYztcbiAgb3V0WzZdID0gcztcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gLXM7XG4gIG91dFsxMF0gPSBjO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IDA7XG4gIG91dFsxM10gPSAwO1xuICBvdXRbMTRdID0gMDtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnJvdGF0ZVkoZGVzdCwgZGVzdCwgcmFkKTtcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVlSb3RhdGlvbihvdXQsIHJhZCkge1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gIHZhciBjID0gTWF0aC5jb3MocmFkKTsgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuXG4gIG91dFswXSA9IGM7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IC1zO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSAxO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSBzO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTBdID0gYztcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE0XSA9IDA7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC5yb3RhdGVaKGRlc3QsIGRlc3QsIHJhZCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21aUm90YXRpb24ob3V0LCByYWQpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYyA9IE1hdGguY29zKHJhZCk7IC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cblxuICBvdXRbMF0gPSBjO1xuICBvdXRbMV0gPSBzO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAtcztcbiAgb3V0WzVdID0gYztcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDE7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uIGFuZCB2ZWN0b3IgdHJhbnNsYXRpb25cclxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XHJcbiAqXHJcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcclxuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcclxuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKG91dCwgcSwgdikge1xuICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgdmFyIHggPSBxWzBdLFxuICAgICAgeSA9IHFbMV0sXG4gICAgICB6ID0gcVsyXSxcbiAgICAgIHcgPSBxWzNdO1xuICB2YXIgeDIgPSB4ICsgeDtcbiAgdmFyIHkyID0geSArIHk7XG4gIHZhciB6MiA9IHogKyB6O1xuICB2YXIgeHggPSB4ICogeDI7XG4gIHZhciB4eSA9IHggKiB5MjtcbiAgdmFyIHh6ID0geCAqIHoyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB5eiA9IHkgKiB6MjtcbiAgdmFyIHp6ID0geiAqIHoyO1xuICB2YXIgd3ggPSB3ICogeDI7XG4gIHZhciB3eSA9IHcgKiB5MjtcbiAgdmFyIHd6ID0gdyAqIHoyO1xuICBvdXRbMF0gPSAxIC0gKHl5ICsgenopO1xuICBvdXRbMV0gPSB4eSArIHd6O1xuICBvdXRbMl0gPSB4eiAtIHd5O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4eSAtIHd6O1xuICBvdXRbNV0gPSAxIC0gKHh4ICsgenopO1xuICBvdXRbNl0gPSB5eiArIHd4O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB4eiArIHd5O1xuICBvdXRbOV0gPSB5eiAtIHd4O1xuICBvdXRbMTBdID0gMSAtICh4eCArIHl5KTtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgbWF0NCBmcm9tIGEgZHVhbCBxdWF0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBNYXRyaXhcclxuICogQHBhcmFtIHtxdWF0Mn0gYSBEdWFsIFF1YXRlcm5pb25cclxuICogQHJldHVybnMge21hdDR9IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUXVhdDIob3V0LCBhKSB7XG4gIHZhciB0cmFuc2xhdGlvbiA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICB2YXIgYnggPSAtYVswXSxcbiAgICAgIGJ5ID0gLWFbMV0sXG4gICAgICBieiA9IC1hWzJdLFxuICAgICAgYncgPSBhWzNdLFxuICAgICAgYXggPSBhWzRdLFxuICAgICAgYXkgPSBhWzVdLFxuICAgICAgYXogPSBhWzZdLFxuICAgICAgYXcgPSBhWzddO1xuICB2YXIgbWFnbml0dWRlID0gYnggKiBieCArIGJ5ICogYnkgKyBieiAqIGJ6ICsgYncgKiBidzsgLy9Pbmx5IHNjYWxlIGlmIGl0IG1ha2VzIHNlbnNlXG5cbiAgaWYgKG1hZ25pdHVkZSA+IDApIHtcbiAgICB0cmFuc2xhdGlvblswXSA9IChheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5KSAqIDIgLyBtYWduaXR1ZGU7XG4gICAgdHJhbnNsYXRpb25bMV0gPSAoYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieikgKiAyIC8gbWFnbml0dWRlO1xuICAgIHRyYW5zbGF0aW9uWzJdID0gKGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYngpICogMiAvIG1hZ25pdHVkZTtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc2xhdGlvblswXSA9IChheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5KSAqIDI7XG4gICAgdHJhbnNsYXRpb25bMV0gPSAoYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieikgKiAyO1xuICAgIHRyYW5zbGF0aW9uWzJdID0gKGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYngpICogMjtcbiAgfVxuXG4gIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKG91dCwgYSwgdHJhbnNsYXRpb24pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uIHZlY3RvciBjb21wb25lbnQgb2YgYSB0cmFuc2Zvcm1hdGlvblxyXG4gKiAgbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uLFxyXG4gKiAgdGhlIHJldHVybmVkIHZlY3RvciB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSB0cmFuc2xhdGlvbiB2ZWN0b3JcclxuICogIG9yaWdpbmFsbHkgc3VwcGxpZWQuXHJcbiAqIEBwYXJhbSAge3ZlYzN9IG91dCBWZWN0b3IgdG8gcmVjZWl2ZSB0cmFuc2xhdGlvbiBjb21wb25lbnRcclxuICogQHBhcmFtICB7bWF0NH0gbWF0IE1hdHJpeCB0byBiZSBkZWNvbXBvc2VkIChpbnB1dClcclxuICogQHJldHVybiB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNsYXRpb24ob3V0LCBtYXQpIHtcbiAgb3V0WzBdID0gbWF0WzEyXTtcbiAgb3V0WzFdID0gbWF0WzEzXTtcbiAgb3V0WzJdID0gbWF0WzE0XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzY2FsaW5nIGZhY3RvciBjb21wb25lbnQgb2YgYSB0cmFuc2Zvcm1hdGlvblxyXG4gKiAgbWF0cml4LiBJZiBhIG1hdHJpeCBpcyBidWlsdCB3aXRoIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVcclxuICogIHdpdGggYSBub3JtYWxpemVkIFF1YXRlcm5pb24gcGFyYW10ZXIsIHRoZSByZXR1cm5lZCB2ZWN0b3Igd2lsbCBiZVxyXG4gKiAgdGhlIHNhbWUgYXMgdGhlIHNjYWxpbmcgdmVjdG9yXHJcbiAqICBvcmlnaW5hbGx5IHN1cHBsaWVkLlxyXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXQgVmVjdG9yIHRvIHJlY2VpdmUgc2NhbGluZyBmYWN0b3IgY29tcG9uZW50XHJcbiAqIEBwYXJhbSAge21hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXHJcbiAqIEByZXR1cm4ge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjYWxpbmcob3V0LCBtYXQpIHtcbiAgdmFyIG0xMSA9IG1hdFswXTtcbiAgdmFyIG0xMiA9IG1hdFsxXTtcbiAgdmFyIG0xMyA9IG1hdFsyXTtcbiAgdmFyIG0yMSA9IG1hdFs0XTtcbiAgdmFyIG0yMiA9IG1hdFs1XTtcbiAgdmFyIG0yMyA9IG1hdFs2XTtcbiAgdmFyIG0zMSA9IG1hdFs4XTtcbiAgdmFyIG0zMiA9IG1hdFs5XTtcbiAgdmFyIG0zMyA9IG1hdFsxMF07XG4gIG91dFswXSA9IE1hdGguc3FydChtMTEgKiBtMTEgKyBtMTIgKiBtMTIgKyBtMTMgKiBtMTMpO1xuICBvdXRbMV0gPSBNYXRoLnNxcnQobTIxICogbTIxICsgbTIyICogbTIyICsgbTIzICogbTIzKTtcbiAgb3V0WzJdID0gTWF0aC5zcXJ0KG0zMSAqIG0zMSArIG0zMiAqIG0zMiArIG0zMyAqIG0zMyk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyBhIHF1YXRlcm5pb24gcmVwcmVzZW50aW5nIHRoZSByb3RhdGlvbmFsIGNvbXBvbmVudFxyXG4gKiAgb2YgYSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguIElmIGEgbWF0cml4IGlzIGJ1aWx0IHdpdGhcclxuICogIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uLCB0aGUgcmV0dXJuZWQgcXVhdGVybmlvbiB3aWxsIGJlIHRoZVxyXG4gKiAgc2FtZSBhcyB0aGUgcXVhdGVybmlvbiBvcmlnaW5hbGx5IHN1cHBsaWVkLlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBRdWF0ZXJuaW9uIHRvIHJlY2VpdmUgdGhlIHJvdGF0aW9uIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge21hdDR9IG1hdCBNYXRyaXggdG8gYmUgZGVjb21wb3NlZCAoaW5wdXQpXHJcbiAqIEByZXR1cm4ge3F1YXR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJvdGF0aW9uKG91dCwgbWF0KSB7XG4gIC8vIEFsZ29yaXRobSB0YWtlbiBmcm9tIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb1F1YXRlcm5pb24vaW5kZXguaHRtXG4gIHZhciB0cmFjZSA9IG1hdFswXSArIG1hdFs1XSArIG1hdFsxMF07XG4gIHZhciBTID0gMDtcblxuICBpZiAodHJhY2UgPiAwKSB7XG4gICAgUyA9IE1hdGguc3FydCh0cmFjZSArIDEuMCkgKiAyO1xuICAgIG91dFszXSA9IDAuMjUgKiBTO1xuICAgIG91dFswXSA9IChtYXRbNl0gLSBtYXRbOV0pIC8gUztcbiAgICBvdXRbMV0gPSAobWF0WzhdIC0gbWF0WzJdKSAvIFM7XG4gICAgb3V0WzJdID0gKG1hdFsxXSAtIG1hdFs0XSkgLyBTO1xuICB9IGVsc2UgaWYgKG1hdFswXSA+IG1hdFs1XSAmJiBtYXRbMF0gPiBtYXRbMTBdKSB7XG4gICAgUyA9IE1hdGguc3FydCgxLjAgKyBtYXRbMF0gLSBtYXRbNV0gLSBtYXRbMTBdKSAqIDI7XG4gICAgb3V0WzNdID0gKG1hdFs2XSAtIG1hdFs5XSkgLyBTO1xuICAgIG91dFswXSA9IDAuMjUgKiBTO1xuICAgIG91dFsxXSA9IChtYXRbMV0gKyBtYXRbNF0pIC8gUztcbiAgICBvdXRbMl0gPSAobWF0WzhdICsgbWF0WzJdKSAvIFM7XG4gIH0gZWxzZSBpZiAobWF0WzVdID4gbWF0WzEwXSkge1xuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgbWF0WzVdIC0gbWF0WzBdIC0gbWF0WzEwXSkgKiAyO1xuICAgIG91dFszXSA9IChtYXRbOF0gLSBtYXRbMl0pIC8gUztcbiAgICBvdXRbMF0gPSAobWF0WzFdICsgbWF0WzRdKSAvIFM7XG4gICAgb3V0WzFdID0gMC4yNSAqIFM7XG4gICAgb3V0WzJdID0gKG1hdFs2XSArIG1hdFs5XSkgLyBTO1xuICB9IGVsc2Uge1xuICAgIFMgPSBNYXRoLnNxcnQoMS4wICsgbWF0WzEwXSAtIG1hdFswXSAtIG1hdFs1XSkgKiAyO1xuICAgIG91dFszXSA9IChtYXRbMV0gLSBtYXRbNF0pIC8gUztcbiAgICBvdXRbMF0gPSAobWF0WzhdICsgbWF0WzJdKSAvIFM7XG4gICAgb3V0WzFdID0gKG1hdFs2XSArIG1hdFs5XSkgLyBTO1xuICAgIG91dFsyXSA9IDAuMjUgKiBTO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uLCB2ZWN0b3IgdHJhbnNsYXRpb24gYW5kIHZlY3RvciBzY2FsZVxyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xyXG4gKiAgICAgbGV0IHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xyXG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xyXG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgc2NhbGUpXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMzfSBzIFNjYWxpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvblNjYWxlKG91dCwgcSwgdiwgcykge1xuICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgdmFyIHggPSBxWzBdLFxuICAgICAgeSA9IHFbMV0sXG4gICAgICB6ID0gcVsyXSxcbiAgICAgIHcgPSBxWzNdO1xuICB2YXIgeDIgPSB4ICsgeDtcbiAgdmFyIHkyID0geSArIHk7XG4gIHZhciB6MiA9IHogKyB6O1xuICB2YXIgeHggPSB4ICogeDI7XG4gIHZhciB4eSA9IHggKiB5MjtcbiAgdmFyIHh6ID0geCAqIHoyO1xuICB2YXIgeXkgPSB5ICogeTI7XG4gIHZhciB5eiA9IHkgKiB6MjtcbiAgdmFyIHp6ID0geiAqIHoyO1xuICB2YXIgd3ggPSB3ICogeDI7XG4gIHZhciB3eSA9IHcgKiB5MjtcbiAgdmFyIHd6ID0gdyAqIHoyO1xuICB2YXIgc3ggPSBzWzBdO1xuICB2YXIgc3kgPSBzWzFdO1xuICB2YXIgc3ogPSBzWzJdO1xuICBvdXRbMF0gPSAoMSAtICh5eSArIHp6KSkgKiBzeDtcbiAgb3V0WzFdID0gKHh5ICsgd3opICogc3g7XG4gIG91dFsyXSA9ICh4eiAtIHd5KSAqIHN4O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAoeHkgLSB3eikgKiBzeTtcbiAgb3V0WzVdID0gKDEgLSAoeHggKyB6eikpICogc3k7XG4gIG91dFs2XSA9ICh5eiArIHd4KSAqIHN5O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAoeHogKyB3eSkgKiBzejtcbiAgb3V0WzldID0gKHl6IC0gd3gpICogc3o7XG4gIG91dFsxMF0gPSAoMSAtICh4eCArIHl5KSkgKiBzejtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdO1xuICBvdXRbMTNdID0gdlsxXTtcbiAgb3V0WzE0XSA9IHZbMl07XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24sIHZlY3RvciB0cmFuc2xhdGlvbiBhbmQgdmVjdG9yIHNjYWxlLCByb3RhdGluZyBhbmQgc2NhbGluZyBhcm91bmQgdGhlIGdpdmVuIG9yaWdpblxyXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcclxuICpcclxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XHJcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgb3JpZ2luKTtcclxuICogICAgIGxldCBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcclxuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcclxuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XHJcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIHNjYWxlKVxyXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgbmVnYXRpdmVPcmlnaW4pO1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjM30gcyBTY2FsaW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzN9IG8gVGhlIG9yaWdpbiB2ZWN0b3IgYXJvdW5kIHdoaWNoIHRvIHNjYWxlIGFuZCByb3RhdGVcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGVPcmlnaW4ob3V0LCBxLCB2LCBzLCBvKSB7XG4gIC8vIFF1YXRlcm5pb24gbWF0aFxuICB2YXIgeCA9IHFbMF0sXG4gICAgICB5ID0gcVsxXSxcbiAgICAgIHogPSBxWzJdLFxuICAgICAgdyA9IHFbM107XG4gIHZhciB4MiA9IHggKyB4O1xuICB2YXIgeTIgPSB5ICsgeTtcbiAgdmFyIHoyID0geiArIHo7XG4gIHZhciB4eCA9IHggKiB4MjtcbiAgdmFyIHh5ID0geCAqIHkyO1xuICB2YXIgeHogPSB4ICogejI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHl6ID0geSAqIHoyO1xuICB2YXIgenogPSB6ICogejI7XG4gIHZhciB3eCA9IHcgKiB4MjtcbiAgdmFyIHd5ID0gdyAqIHkyO1xuICB2YXIgd3ogPSB3ICogejI7XG4gIHZhciBzeCA9IHNbMF07XG4gIHZhciBzeSA9IHNbMV07XG4gIHZhciBzeiA9IHNbMl07XG4gIHZhciBveCA9IG9bMF07XG4gIHZhciBveSA9IG9bMV07XG4gIHZhciBveiA9IG9bMl07XG4gIHZhciBvdXQwID0gKDEgLSAoeXkgKyB6eikpICogc3g7XG4gIHZhciBvdXQxID0gKHh5ICsgd3opICogc3g7XG4gIHZhciBvdXQyID0gKHh6IC0gd3kpICogc3g7XG4gIHZhciBvdXQ0ID0gKHh5IC0gd3opICogc3k7XG4gIHZhciBvdXQ1ID0gKDEgLSAoeHggKyB6eikpICogc3k7XG4gIHZhciBvdXQ2ID0gKHl6ICsgd3gpICogc3k7XG4gIHZhciBvdXQ4ID0gKHh6ICsgd3kpICogc3o7XG4gIHZhciBvdXQ5ID0gKHl6IC0gd3gpICogc3o7XG4gIHZhciBvdXQxMCA9ICgxIC0gKHh4ICsgeXkpKSAqIHN6O1xuICBvdXRbMF0gPSBvdXQwO1xuICBvdXRbMV0gPSBvdXQxO1xuICBvdXRbMl0gPSBvdXQyO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSBvdXQ0O1xuICBvdXRbNV0gPSBvdXQ1O1xuICBvdXRbNl0gPSBvdXQ2O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSBvdXQ4O1xuICBvdXRbOV0gPSBvdXQ5O1xuICBvdXRbMTBdID0gb3V0MTA7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gdlswXSArIG94IC0gKG91dDAgKiBveCArIG91dDQgKiBveSArIG91dDggKiBveik7XG4gIG91dFsxM10gPSB2WzFdICsgb3kgLSAob3V0MSAqIG94ICsgb3V0NSAqIG95ICsgb3V0OSAqIG96KTtcbiAgb3V0WzE0XSA9IHZbMl0gKyBveiAtIChvdXQyICogb3ggKyBvdXQ2ICogb3kgKyBvdXQxMCAqIG96KTtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyBhIDR4NCBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7cXVhdH0gcSBRdWF0ZXJuaW9uIHRvIGNyZWF0ZSBtYXRyaXggZnJvbVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVF1YXQob3V0LCBxKSB7XG4gIHZhciB4ID0gcVswXSxcbiAgICAgIHkgPSBxWzFdLFxuICAgICAgeiA9IHFbMl0sXG4gICAgICB3ID0gcVszXTtcbiAgdmFyIHgyID0geCArIHg7XG4gIHZhciB5MiA9IHkgKyB5O1xuICB2YXIgejIgPSB6ICsgejtcbiAgdmFyIHh4ID0geCAqIHgyO1xuICB2YXIgeXggPSB5ICogeDI7XG4gIHZhciB5eSA9IHkgKiB5MjtcbiAgdmFyIHp4ID0geiAqIHgyO1xuICB2YXIgenkgPSB6ICogeTI7XG4gIHZhciB6eiA9IHogKiB6MjtcbiAgdmFyIHd4ID0gdyAqIHgyO1xuICB2YXIgd3kgPSB3ICogeTI7XG4gIHZhciB3eiA9IHcgKiB6MjtcbiAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gIG91dFsxXSA9IHl4ICsgd3o7XG4gIG91dFsyXSA9IHp4IC0gd3k7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHl4IC0gd3o7XG4gIG91dFs1XSA9IDEgLSB4eCAtIHp6O1xuICBvdXRbNl0gPSB6eSArIHd4O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB6eCArIHd5O1xuICBvdXRbOV0gPSB6eSAtIHd4O1xuICBvdXRbMTBdID0gMSAtIHh4IC0geXk7XG4gIG91dFsxMV0gPSAwO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSAwO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBmcnVzdHVtIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge051bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcnVzdHVtKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgdmFyIHJsID0gMSAvIChyaWdodCAtIGxlZnQpO1xuICB2YXIgdGIgPSAxIC8gKHRvcCAtIGJvdHRvbSk7XG4gIHZhciBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gIG91dFswXSA9IG5lYXIgKiAyICogcmw7XG4gIG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IDA7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IG5lYXIgKiAyICogdGI7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IChyaWdodCArIGxlZnQpICogcmw7XG4gIG91dFs5XSA9ICh0b3AgKyBib3R0b20pICogdGI7XG4gIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgb3V0WzExXSA9IC0xO1xuICBvdXRbMTJdID0gMDtcbiAgb3V0WzEzXSA9IDA7XG4gIG91dFsxNF0gPSBmYXIgKiBuZWFyICogMiAqIG5mO1xuICBvdXRbMTVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHMuXHJcbiAqIFBhc3NpbmcgbnVsbC91bmRlZmluZWQvbm8gdmFsdWUgZm9yIGZhciB3aWxsIGdlbmVyYXRlIGluZmluaXRlIHByb2plY3Rpb24gbWF0cml4LlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z5IFZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgaW4gcmFkaWFuc1xyXG4gKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0IEFzcGVjdCByYXRpby4gdHlwaWNhbGx5IHZpZXdwb3J0IHdpZHRoL2hlaWdodFxyXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtLCBjYW4gYmUgbnVsbCBvciBJbmZpbml0eVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcGVyc3BlY3RpdmUob3V0LCBmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xuICB2YXIgZiA9IDEuMCAvIE1hdGgudGFuKGZvdnkgLyAyKSxcbiAgICAgIG5mO1xuICBvdXRbMF0gPSBmIC8gYXNwZWN0O1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAwO1xuICBvdXRbNV0gPSBmO1xuICBvdXRbNl0gPSAwO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAwO1xuICBvdXRbOV0gPSAwO1xuICBvdXRbMTFdID0gLTE7XG4gIG91dFsxMl0gPSAwO1xuICBvdXRbMTNdID0gMDtcbiAgb3V0WzE1XSA9IDA7XG5cbiAgaWYgKGZhciAhPSBudWxsICYmIGZhciAhPT0gSW5maW5pdHkpIHtcbiAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxNF0gPSAyICogZmFyICogbmVhciAqIG5mO1xuICB9IGVsc2Uge1xuICAgIG91dFsxMF0gPSAtMTtcbiAgICBvdXRbMTRdID0gLTIgKiBuZWFyO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBmaWVsZCBvZiB2aWV3LlxyXG4gKiBUaGlzIGlzIHByaW1hcmlseSB1c2VmdWwgZm9yIGdlbmVyYXRpbmcgcHJvamVjdGlvbiBtYXRyaWNlcyB0byBiZSB1c2VkXHJcbiAqIHdpdGggdGhlIHN0aWxsIGV4cGVyaWVtZW50YWwgV2ViVlIgQVBJLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBmb3YgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyB2YWx1ZXM6IHVwRGVncmVlcywgZG93bkRlZ3JlZXMsIGxlZnREZWdyZWVzLCByaWdodERlZ3JlZXNcclxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXcob3V0LCBmb3YsIG5lYXIsIGZhcikge1xuICB2YXIgdXBUYW4gPSBNYXRoLnRhbihmb3YudXBEZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wKTtcbiAgdmFyIGRvd25UYW4gPSBNYXRoLnRhbihmb3YuZG93bkRlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjApO1xuICB2YXIgbGVmdFRhbiA9IE1hdGgudGFuKGZvdi5sZWZ0RGVncmVlcyAqIE1hdGguUEkgLyAxODAuMCk7XG4gIHZhciByaWdodFRhbiA9IE1hdGgudGFuKGZvdi5yaWdodERlZ3JlZXMgKiBNYXRoLlBJIC8gMTgwLjApO1xuICB2YXIgeFNjYWxlID0gMi4wIC8gKGxlZnRUYW4gKyByaWdodFRhbik7XG4gIHZhciB5U2NhbGUgPSAyLjAgLyAodXBUYW4gKyBkb3duVGFuKTtcbiAgb3V0WzBdID0geFNjYWxlO1xuICBvdXRbMV0gPSAwLjA7XG4gIG91dFsyXSA9IDAuMDtcbiAgb3V0WzNdID0gMC4wO1xuICBvdXRbNF0gPSAwLjA7XG4gIG91dFs1XSA9IHlTY2FsZTtcbiAgb3V0WzZdID0gMC4wO1xuICBvdXRbN10gPSAwLjA7XG4gIG91dFs4XSA9IC0oKGxlZnRUYW4gLSByaWdodFRhbikgKiB4U2NhbGUgKiAwLjUpO1xuICBvdXRbOV0gPSAodXBUYW4gLSBkb3duVGFuKSAqIHlTY2FsZSAqIDAuNTtcbiAgb3V0WzEwXSA9IGZhciAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzExXSA9IC0xLjA7XG4gIG91dFsxMl0gPSAwLjA7XG4gIG91dFsxM10gPSAwLjA7XG4gIG91dFsxNF0gPSBmYXIgKiBuZWFyIC8gKG5lYXIgLSBmYXIpO1xuICBvdXRbMTVdID0gMC4wO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIG9ydGhvZ29uYWwgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cclxuICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cclxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gb3J0aG8ob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICB2YXIgbHIgPSAxIC8gKGxlZnQgLSByaWdodCk7XG4gIHZhciBidCA9IDEgLyAoYm90dG9tIC0gdG9wKTtcbiAgdmFyIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgb3V0WzBdID0gLTIgKiBscjtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMDtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gLTIgKiBidDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgb3V0WzhdID0gMDtcbiAgb3V0WzldID0gMDtcbiAgb3V0WzEwXSA9IDIgKiBuZjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAobGVmdCArIHJpZ2h0KSAqIGxyO1xuICBvdXRbMTNdID0gKHRvcCArIGJvdHRvbSkgKiBidDtcbiAgb3V0WzE0XSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICBvdXRbMTVdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZXMgYSBsb29rLWF0IG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBleWUgcG9zaXRpb24sIGZvY2FsIHBvaW50LCBhbmQgdXAgYXhpcy5cclxuICogSWYgeW91IHdhbnQgYSBtYXRyaXggdGhhdCBhY3R1YWxseSBtYWtlcyBhbiBvYmplY3QgbG9vayBhdCBhbm90aGVyIG9iamVjdCwgeW91IHNob3VsZCB1c2UgdGFyZ2V0VG8gaW5zdGVhZC5cclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xyXG4gKiBAcGFyYW0ge3ZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXHJcbiAqIEBwYXJhbSB7dmVjM30gY2VudGVyIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdFxyXG4gKiBAcGFyYW0ge3ZlYzN9IHVwIHZlYzMgcG9pbnRpbmcgdXBcclxuICogQHJldHVybnMge21hdDR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxvb2tBdChvdXQsIGV5ZSwgY2VudGVyLCB1cCkge1xuICB2YXIgeDAsIHgxLCB4MiwgeTAsIHkxLCB5MiwgejAsIHoxLCB6MiwgbGVuO1xuICB2YXIgZXlleCA9IGV5ZVswXTtcbiAgdmFyIGV5ZXkgPSBleWVbMV07XG4gIHZhciBleWV6ID0gZXllWzJdO1xuICB2YXIgdXB4ID0gdXBbMF07XG4gIHZhciB1cHkgPSB1cFsxXTtcbiAgdmFyIHVweiA9IHVwWzJdO1xuICB2YXIgY2VudGVyeCA9IGNlbnRlclswXTtcbiAgdmFyIGNlbnRlcnkgPSBjZW50ZXJbMV07XG4gIHZhciBjZW50ZXJ6ID0gY2VudGVyWzJdO1xuXG4gIGlmIChNYXRoLmFicyhleWV4IC0gY2VudGVyeCkgPCBnbE1hdHJpeC5FUFNJTE9OICYmIE1hdGguYWJzKGV5ZXkgLSBjZW50ZXJ5KSA8IGdsTWF0cml4LkVQU0lMT04gJiYgTWF0aC5hYnMoZXlleiAtIGNlbnRlcnopIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgIHJldHVybiBpZGVudGl0eShvdXQpO1xuICB9XG5cbiAgejAgPSBleWV4IC0gY2VudGVyeDtcbiAgejEgPSBleWV5IC0gY2VudGVyeTtcbiAgejIgPSBleWV6IC0gY2VudGVyejtcbiAgbGVuID0gMSAvIE1hdGguc3FydCh6MCAqIHowICsgejEgKiB6MSArIHoyICogejIpO1xuICB6MCAqPSBsZW47XG4gIHoxICo9IGxlbjtcbiAgejIgKj0gbGVuO1xuICB4MCA9IHVweSAqIHoyIC0gdXB6ICogejE7XG4gIHgxID0gdXB6ICogejAgLSB1cHggKiB6MjtcbiAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICBsZW4gPSBNYXRoLnNxcnQoeDAgKiB4MCArIHgxICogeDEgKyB4MiAqIHgyKTtcblxuICBpZiAoIWxlbikge1xuICAgIHgwID0gMDtcbiAgICB4MSA9IDA7XG4gICAgeDIgPSAwO1xuICB9IGVsc2Uge1xuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeDAgKj0gbGVuO1xuICAgIHgxICo9IGxlbjtcbiAgICB4MiAqPSBsZW47XG4gIH1cblxuICB5MCA9IHoxICogeDIgLSB6MiAqIHgxO1xuICB5MSA9IHoyICogeDAgLSB6MCAqIHgyO1xuICB5MiA9IHowICogeDEgLSB6MSAqIHgwO1xuICBsZW4gPSBNYXRoLnNxcnQoeTAgKiB5MCArIHkxICogeTEgKyB5MiAqIHkyKTtcblxuICBpZiAoIWxlbikge1xuICAgIHkwID0gMDtcbiAgICB5MSA9IDA7XG4gICAgeTIgPSAwO1xuICB9IGVsc2Uge1xuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeTAgKj0gbGVuO1xuICAgIHkxICo9IGxlbjtcbiAgICB5MiAqPSBsZW47XG4gIH1cblxuICBvdXRbMF0gPSB4MDtcbiAgb3V0WzFdID0geTA7XG4gIG91dFsyXSA9IHowO1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSB4MTtcbiAgb3V0WzVdID0geTE7XG4gIG91dFs2XSA9IHoxO1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSB4MjtcbiAgb3V0WzldID0geTI7XG4gIG91dFsxMF0gPSB6MjtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSAtKHgwICogZXlleCArIHgxICogZXlleSArIHgyICogZXlleik7XG4gIG91dFsxM10gPSAtKHkwICogZXlleCArIHkxICogZXlleSArIHkyICogZXlleik7XG4gIG91dFsxNF0gPSAtKHowICogZXlleCArIHoxICogZXlleSArIHoyICogZXlleik7XG4gIG91dFsxNV0gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIG1hdHJpeCB0aGF0IG1ha2VzIHNvbWV0aGluZyBsb29rIGF0IHNvbWV0aGluZyBlbHNlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXHJcbiAqIEBwYXJhbSB7dmVjM30gZXllIFBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcclxuICogQHBhcmFtIHt2ZWMzfSBjZW50ZXIgUG9pbnQgdGhlIHZpZXdlciBpcyBsb29raW5nIGF0XHJcbiAqIEBwYXJhbSB7dmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdGFyZ2V0VG8ob3V0LCBleWUsIHRhcmdldCwgdXApIHtcbiAgdmFyIGV5ZXggPSBleWVbMF0sXG4gICAgICBleWV5ID0gZXllWzFdLFxuICAgICAgZXlleiA9IGV5ZVsyXSxcbiAgICAgIHVweCA9IHVwWzBdLFxuICAgICAgdXB5ID0gdXBbMV0sXG4gICAgICB1cHogPSB1cFsyXTtcbiAgdmFyIHowID0gZXlleCAtIHRhcmdldFswXSxcbiAgICAgIHoxID0gZXlleSAtIHRhcmdldFsxXSxcbiAgICAgIHoyID0gZXlleiAtIHRhcmdldFsyXTtcbiAgdmFyIGxlbiA9IHowICogejAgKyB6MSAqIHoxICsgejIgKiB6MjtcblxuICBpZiAobGVuID4gMCkge1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICB6MCAqPSBsZW47XG4gICAgejEgKj0gbGVuO1xuICAgIHoyICo9IGxlbjtcbiAgfVxuXG4gIHZhciB4MCA9IHVweSAqIHoyIC0gdXB6ICogejEsXG4gICAgICB4MSA9IHVweiAqIHowIC0gdXB4ICogejIsXG4gICAgICB4MiA9IHVweCAqIHoxIC0gdXB5ICogejA7XG4gIGxlbiA9IHgwICogeDAgKyB4MSAqIHgxICsgeDIgKiB4MjtcblxuICBpZiAobGVuID4gMCkge1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICB4MCAqPSBsZW47XG4gICAgeDEgKj0gbGVuO1xuICAgIHgyICo9IGxlbjtcbiAgfVxuXG4gIG91dFswXSA9IHgwO1xuICBvdXRbMV0gPSB4MTtcbiAgb3V0WzJdID0geDI7XG4gIG91dFszXSA9IDA7XG4gIG91dFs0XSA9IHoxICogeDIgLSB6MiAqIHgxO1xuICBvdXRbNV0gPSB6MiAqIHgwIC0gejAgKiB4MjtcbiAgb3V0WzZdID0gejAgKiB4MSAtIHoxICogeDA7XG4gIG91dFs3XSA9IDA7XG4gIG91dFs4XSA9IHowO1xuICBvdXRbOV0gPSB6MTtcbiAgb3V0WzEwXSA9IHoyO1xuICBvdXRbMTFdID0gMDtcbiAgb3V0WzEyXSA9IGV5ZXg7XG4gIG91dFsxM10gPSBleWV5O1xuICBvdXRbMTRdID0gZXllejtcbiAgb3V0WzE1XSA9IDE7XG4gIHJldHVybiBvdXQ7XG59XG47XG4vKipcclxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBhIG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gJ21hdDQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnLCAnICsgYVs0XSArICcsICcgKyBhWzVdICsgJywgJyArIGFbNl0gKyAnLCAnICsgYVs3XSArICcsICcgKyBhWzhdICsgJywgJyArIGFbOV0gKyAnLCAnICsgYVsxMF0gKyAnLCAnICsgYVsxMV0gKyAnLCAnICsgYVsxMl0gKyAnLCAnICsgYVsxM10gKyAnLCAnICsgYVsxNF0gKyAnLCAnICsgYVsxNV0gKyAnKSc7XG59XG4vKipcclxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDRcclxuICpcclxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IEZyb2Jlbml1cyBub3JtXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvYihhKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikgKyBNYXRoLnBvdyhhWzRdLCAyKSArIE1hdGgucG93KGFbNV0sIDIpICsgTWF0aC5wb3coYVs2XSwgMikgKyBNYXRoLnBvdyhhWzddLCAyKSArIE1hdGgucG93KGFbOF0sIDIpICsgTWF0aC5wb3coYVs5XSwgMikgKyBNYXRoLnBvdyhhWzEwXSwgMikgKyBNYXRoLnBvdyhhWzExXSwgMikgKyBNYXRoLnBvdyhhWzEyXSwgMikgKyBNYXRoLnBvdyhhWzEzXSwgMikgKyBNYXRoLnBvdyhhWzE0XSwgMikgKyBNYXRoLnBvdyhhWzE1XSwgMikpO1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIG1hdDQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XTtcbiAgb3V0WzddID0gYVs3XSArIGJbN107XG4gIG91dFs4XSA9IGFbOF0gKyBiWzhdO1xuICBvdXRbOV0gPSBhWzldICsgYls5XTtcbiAgb3V0WzEwXSA9IGFbMTBdICsgYlsxMF07XG4gIG91dFsxMV0gPSBhWzExXSArIGJbMTFdO1xuICBvdXRbMTJdID0gYVsxMl0gKyBiWzEyXTtcbiAgb3V0WzEzXSA9IGFbMTNdICsgYlsxM107XG4gIG91dFsxNF0gPSBhWzE0XSArIGJbMTRdO1xuICBvdXRbMTVdID0gYVsxNV0gKyBiWzE1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgbWF0cml4IGIgZnJvbSBtYXRyaXggYVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICBvdXRbNF0gPSBhWzRdIC0gYls0XTtcbiAgb3V0WzVdID0gYVs1XSAtIGJbNV07XG4gIG91dFs2XSA9IGFbNl0gLSBiWzZdO1xuICBvdXRbN10gPSBhWzddIC0gYls3XTtcbiAgb3V0WzhdID0gYVs4XSAtIGJbOF07XG4gIG91dFs5XSA9IGFbOV0gLSBiWzldO1xuICBvdXRbMTBdID0gYVsxMF0gLSBiWzEwXTtcbiAgb3V0WzExXSA9IGFbMTFdIC0gYlsxMV07XG4gIG91dFsxMl0gPSBhWzEyXSAtIGJbMTJdO1xuICBvdXRbMTNdID0gYVsxM10gLSBiWzEzXTtcbiAgb3V0WzE0XSA9IGFbMTRdIC0gYlsxNF07XG4gIG91dFsxNV0gPSBhWzE1XSAtIGJbMTVdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGx5IGVhY2ggZWxlbWVudCBvZiB0aGUgbWF0cml4IGJ5IGEgc2NhbGFyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIG1hdHJpeCdzIGVsZW1lbnRzIGJ5XHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhcihvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICBvdXRbMl0gPSBhWzJdICogYjtcbiAgb3V0WzNdID0gYVszXSAqIGI7XG4gIG91dFs0XSA9IGFbNF0gKiBiO1xuICBvdXRbNV0gPSBhWzVdICogYjtcbiAgb3V0WzZdID0gYVs2XSAqIGI7XG4gIG91dFs3XSA9IGFbN10gKiBiO1xuICBvdXRbOF0gPSBhWzhdICogYjtcbiAgb3V0WzldID0gYVs5XSAqIGI7XG4gIG91dFsxMF0gPSBhWzEwXSAqIGI7XG4gIG91dFsxMV0gPSBhWzExXSAqIGI7XG4gIG91dFsxMl0gPSBhWzEyXSAqIGI7XG4gIG91dFsxM10gPSBhWzEzXSAqIGI7XG4gIG91dFsxNF0gPSBhWzE0XSAqIGI7XG4gIG91dFsxNV0gPSBhWzE1XSAqIGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gbWF0NCdzIGFmdGVyIG11bHRpcGx5aW5nIGVhY2ggZWxlbWVudCBvZiB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIncyBlbGVtZW50cyBieSBiZWZvcmUgYWRkaW5nXHJcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseVNjYWxhckFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdICogc2NhbGU7XG4gIG91dFszXSA9IGFbM10gKyBiWzNdICogc2NhbGU7XG4gIG91dFs0XSA9IGFbNF0gKyBiWzRdICogc2NhbGU7XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdICogc2NhbGU7XG4gIG91dFs2XSA9IGFbNl0gKyBiWzZdICogc2NhbGU7XG4gIG91dFs3XSA9IGFbN10gKyBiWzddICogc2NhbGU7XG4gIG91dFs4XSA9IGFbOF0gKyBiWzhdICogc2NhbGU7XG4gIG91dFs5XSA9IGFbOV0gKyBiWzldICogc2NhbGU7XG4gIG91dFsxMF0gPSBhWzEwXSArIGJbMTBdICogc2NhbGU7XG4gIG91dFsxMV0gPSBhWzExXSArIGJbMTFdICogc2NhbGU7XG4gIG91dFsxMl0gPSBhWzEyXSArIGJbMTJdICogc2NhbGU7XG4gIG91dFsxM10gPSBhWzEzXSArIGJbMTNdICogc2NhbGU7XG4gIG91dFsxNF0gPSBhWzE0XSArIGJbMTRdICogc2NhbGU7XG4gIG91dFsxNV0gPSBhWzE1XSArIGJbMTVdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgbWF0cmljZXMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxyXG4gKlxyXG4gKiBAcGFyYW0ge21hdDR9IGEgVGhlIGZpcnN0IG1hdHJpeC5cclxuICogQHBhcmFtIHttYXQ0fSBiIFRoZSBzZWNvbmQgbWF0cml4LlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgbWF0cmljZXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXSAmJiBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV0gJiYgYVs2XSA9PT0gYls2XSAmJiBhWzddID09PSBiWzddICYmIGFbOF0gPT09IGJbOF0gJiYgYVs5XSA9PT0gYls5XSAmJiBhWzEwXSA9PT0gYlsxMF0gJiYgYVsxMV0gPT09IGJbMTFdICYmIGFbMTJdID09PSBiWzEyXSAmJiBhWzEzXSA9PT0gYlsxM10gJiYgYVsxNF0gPT09IGJbMTRdICYmIGFbMTVdID09PSBiWzE1XTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBtYXRyaWNlcyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7bWF0NH0gYSBUaGUgZmlyc3QgbWF0cml4LlxyXG4gKiBAcGFyYW0ge21hdDR9IGIgVGhlIHNlY29uZCBtYXRyaXguXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSBtYXRyaWNlcyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgYTQgPSBhWzRdLFxuICAgICAgYTUgPSBhWzVdLFxuICAgICAgYTYgPSBhWzZdLFxuICAgICAgYTcgPSBhWzddO1xuICB2YXIgYTggPSBhWzhdLFxuICAgICAgYTkgPSBhWzldLFxuICAgICAgYTEwID0gYVsxMF0sXG4gICAgICBhMTEgPSBhWzExXTtcbiAgdmFyIGExMiA9IGFbMTJdLFxuICAgICAgYTEzID0gYVsxM10sXG4gICAgICBhMTQgPSBhWzE0XSxcbiAgICAgIGExNSA9IGFbMTVdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdO1xuICB2YXIgYjQgPSBiWzRdLFxuICAgICAgYjUgPSBiWzVdLFxuICAgICAgYjYgPSBiWzZdLFxuICAgICAgYjcgPSBiWzddO1xuICB2YXIgYjggPSBiWzhdLFxuICAgICAgYjkgPSBiWzldLFxuICAgICAgYjEwID0gYlsxMF0sXG4gICAgICBiMTEgPSBiWzExXTtcbiAgdmFyIGIxMiA9IGJbMTJdLFxuICAgICAgYjEzID0gYlsxM10sXG4gICAgICBiMTQgPSBiWzE0XSxcbiAgICAgIGIxNSA9IGJbMTVdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpICYmIE1hdGguYWJzKGE0IC0gYjQpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE0KSwgTWF0aC5hYnMoYjQpKSAmJiBNYXRoLmFicyhhNSAtIGI1KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNSksIE1hdGguYWJzKGI1KSkgJiYgTWF0aC5hYnMoYTYgLSBiNikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTYpLCBNYXRoLmFicyhiNikpICYmIE1hdGguYWJzKGE3IC0gYjcpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE3KSwgTWF0aC5hYnMoYjcpKSAmJiBNYXRoLmFicyhhOCAtIGI4KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhOCksIE1hdGguYWJzKGI4KSkgJiYgTWF0aC5hYnMoYTkgLSBiOSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTkpLCBNYXRoLmFicyhiOSkpICYmIE1hdGguYWJzKGExMCAtIGIxMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEwKSwgTWF0aC5hYnMoYjEwKSkgJiYgTWF0aC5hYnMoYTExIC0gYjExKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTEpLCBNYXRoLmFicyhiMTEpKSAmJiBNYXRoLmFicyhhMTIgLSBiMTIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExMiksIE1hdGguYWJzKGIxMikpICYmIE1hdGguYWJzKGExMyAtIGIxMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEzKSwgTWF0aC5hYnMoYjEzKSkgJiYgTWF0aC5hYnMoYTE0IC0gYjE0KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMTQpLCBNYXRoLmFicyhiMTQpKSAmJiBNYXRoLmFicyhhMTUgLSBiMTUpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExNSksIE1hdGguYWJzKGIxNSkpO1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0NC5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgbWF0NC5zdWJ0cmFjdH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHN1YiA9IHN1YnRyYWN0OyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuaW1wb3J0ICogYXMgbWF0MyBmcm9tIFwiLi9tYXQzLmpzXCI7XG5pbXBvcnQgKiBhcyB2ZWMzIGZyb20gXCIuL3ZlYzMuanNcIjtcbmltcG9ydCAqIGFzIHZlYzQgZnJvbSBcIi4vdmVjNC5qc1wiO1xuLyoqXHJcbiAqIFF1YXRlcm5pb25cclxuICogQG1vZHVsZSBxdWF0XHJcbiAqL1xuXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBxdWF0XHJcbiAqXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNCk7XG5cbiAgaWYgKGdsTWF0cml4LkFSUkFZX1RZUEUgIT0gRmxvYXQzMkFycmF5KSB7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gIH1cblxuICBvdXRbM10gPSAxO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCBhIHF1YXQgdG8gdGhlIGlkZW50aXR5IHF1YXRlcm5pb25cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXRzIGEgcXVhdCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhbmQgcm90YXRpb24gYXhpcyxcclxuICogdGhlbiByZXR1cm5zIGl0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIGFyb3VuZCB3aGljaCB0byByb3RhdGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgaW4gcmFkaWFuc1xyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEF4aXNBbmdsZShvdXQsIGF4aXMsIHJhZCkge1xuICByYWQgPSByYWQgKiAwLjU7XG4gIHZhciBzID0gTWF0aC5zaW4ocmFkKTtcbiAgb3V0WzBdID0gcyAqIGF4aXNbMF07XG4gIG91dFsxXSA9IHMgKiBheGlzWzFdO1xuICBvdXRbMl0gPSBzICogYXhpc1syXTtcbiAgb3V0WzNdID0gTWF0aC5jb3MocmFkKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZXRzIHRoZSByb3RhdGlvbiBheGlzIGFuZCBhbmdsZSBmb3IgYSBnaXZlblxyXG4gKiAgcXVhdGVybmlvbi4gSWYgYSBxdWF0ZXJuaW9uIGlzIGNyZWF0ZWQgd2l0aFxyXG4gKiAgc2V0QXhpc0FuZ2xlLCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgc2FtZVxyXG4gKiAgdmFsdWVzIGFzIHByb3ZpZGllZCBpbiB0aGUgb3JpZ2luYWwgcGFyYW1ldGVyIGxpc3RcclxuICogIE9SIGZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHZhbHVlcy5cclxuICogRXhhbXBsZTogVGhlIHF1YXRlcm5pb24gZm9ybWVkIGJ5IGF4aXMgWzAsIDAsIDFdIGFuZFxyXG4gKiAgYW5nbGUgLTkwIGlzIHRoZSBzYW1lIGFzIHRoZSBxdWF0ZXJuaW9uIGZvcm1lZCBieVxyXG4gKiAgWzAsIDAsIDFdIGFuZCAyNzAuIFRoaXMgbWV0aG9kIGZhdm9ycyB0aGUgbGF0dGVyLlxyXG4gKiBAcGFyYW0gIHt2ZWMzfSBvdXRfYXhpcyAgVmVjdG9yIHJlY2VpdmluZyB0aGUgYXhpcyBvZiByb3RhdGlvblxyXG4gKiBAcGFyYW0gIHtxdWF0fSBxICAgICBRdWF0ZXJuaW9uIHRvIGJlIGRlY29tcG9zZWRcclxuICogQHJldHVybiB7TnVtYmVyfSAgICAgQW5nbGUsIGluIHJhZGlhbnMsIG9mIHRoZSByb3RhdGlvblxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEF4aXNBbmdsZShvdXRfYXhpcywgcSkge1xuICB2YXIgcmFkID0gTWF0aC5hY29zKHFbM10pICogMi4wO1xuICB2YXIgcyA9IE1hdGguc2luKHJhZCAvIDIuMCk7XG5cbiAgaWYgKHMgPiBnbE1hdHJpeC5FUFNJTE9OKSB7XG4gICAgb3V0X2F4aXNbMF0gPSBxWzBdIC8gcztcbiAgICBvdXRfYXhpc1sxXSA9IHFbMV0gLyBzO1xuICAgIG91dF9heGlzWzJdID0gcVsyXSAvIHM7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgcyBpcyB6ZXJvLCByZXR1cm4gYW55IGF4aXMgKG5vIHJvdGF0aW9uIC0gYXhpcyBkb2VzIG5vdCBtYXR0ZXIpXG4gICAgb3V0X2F4aXNbMF0gPSAxO1xuICAgIG91dF9heGlzWzFdID0gMDtcbiAgICBvdXRfYXhpc1syXSA9IDA7XG4gIH1cblxuICByZXR1cm4gcmFkO1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIHF1YXQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdLFxuICAgICAgYXcgPSBhWzNdO1xuICB2YXIgYnggPSBiWzBdLFxuICAgICAgYnkgPSBiWzFdLFxuICAgICAgYnogPSBiWzJdLFxuICAgICAgYncgPSBiWzNdO1xuICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5O1xuICBvdXRbMV0gPSBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6O1xuICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4O1xuICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWCBheGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIHJhZCkge1xuICByYWQgKj0gMC41O1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdLFxuICAgICAgYXcgPSBhWzNdO1xuICB2YXIgYnggPSBNYXRoLnNpbihyYWQpLFxuICAgICAgYncgPSBNYXRoLmNvcyhyYWQpO1xuICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieDtcbiAgb3V0WzFdID0gYXkgKiBidyArIGF6ICogYng7XG4gIG91dFsyXSA9IGF6ICogYncgLSBheSAqIGJ4O1xuICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFkgYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCByYWQpIHtcbiAgcmFkICo9IDAuNTtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXSxcbiAgICAgIGF6ID0gYVsyXSxcbiAgICAgIGF3ID0gYVszXTtcbiAgdmFyIGJ5ID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgIGJ3ID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYXggKiBidyAtIGF6ICogYnk7XG4gIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5O1xuICBvdXRbMl0gPSBheiAqIGJ3ICsgYXggKiBieTtcbiAgb3V0WzNdID0gYXcgKiBidyAtIGF5ICogYnk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBaIGF4aXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgcmFkKSB7XG4gIHJhZCAqPSAwLjU7XG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl0sXG4gICAgICBhdyA9IGFbM107XG4gIHZhciBieiA9IE1hdGguc2luKHJhZCksXG4gICAgICBidyA9IE1hdGguY29zKHJhZCk7XG4gIG91dFswXSA9IGF4ICogYncgKyBheSAqIGJ6O1xuICBvdXRbMV0gPSBheSAqIGJ3IC0gYXggKiBiejtcbiAgb3V0WzJdID0gYXogKiBidyArIGF3ICogYno7XG4gIG91dFszXSA9IGF3ICogYncgLSBheiAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIFcgY29tcG9uZW50IG9mIGEgcXVhdCBmcm9tIHRoZSBYLCBZLCBhbmQgWiBjb21wb25lbnRzLlxyXG4gKiBBc3N1bWVzIHRoYXQgcXVhdGVybmlvbiBpcyAxIHVuaXQgaW4gbGVuZ3RoLlxyXG4gKiBBbnkgZXhpc3RpbmcgVyBjb21wb25lbnQgd2lsbCBiZSBpZ25vcmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIFcgY29tcG9uZW50IG9mXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVXKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICBvdXRbM10gPSBNYXRoLnNxcnQoTWF0aC5hYnMoMS4wIC0geCAqIHggLSB5ICogeSAtIHogKiB6KSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2xlcnAob3V0LCBhLCBiLCB0KSB7XG4gIC8vIGJlbmNobWFya3M6XG4gIC8vICAgIGh0dHA6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tc2xlcnAtaW1wbGVtZW50YXRpb25zXG4gIHZhciBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl0sXG4gICAgICBhdyA9IGFbM107XG4gIHZhciBieCA9IGJbMF0sXG4gICAgICBieSA9IGJbMV0sXG4gICAgICBieiA9IGJbMl0sXG4gICAgICBidyA9IGJbM107XG4gIHZhciBvbWVnYSwgY29zb20sIHNpbm9tLCBzY2FsZTAsIHNjYWxlMTsgLy8gY2FsYyBjb3NpbmVcblxuICBjb3NvbSA9IGF4ICogYnggKyBheSAqIGJ5ICsgYXogKiBieiArIGF3ICogYnc7IC8vIGFkanVzdCBzaWducyAoaWYgbmVjZXNzYXJ5KVxuXG4gIGlmIChjb3NvbSA8IDAuMCkge1xuICAgIGNvc29tID0gLWNvc29tO1xuICAgIGJ4ID0gLWJ4O1xuICAgIGJ5ID0gLWJ5O1xuICAgIGJ6ID0gLWJ6O1xuICAgIGJ3ID0gLWJ3O1xuICB9IC8vIGNhbGN1bGF0ZSBjb2VmZmljaWVudHNcblxuXG4gIGlmICgxLjAgLSBjb3NvbSA+IGdsTWF0cml4LkVQU0lMT04pIHtcbiAgICAvLyBzdGFuZGFyZCBjYXNlIChzbGVycClcbiAgICBvbWVnYSA9IE1hdGguYWNvcyhjb3NvbSk7XG4gICAgc2lub20gPSBNYXRoLnNpbihvbWVnYSk7XG4gICAgc2NhbGUwID0gTWF0aC5zaW4oKDEuMCAtIHQpICogb21lZ2EpIC8gc2lub207XG4gICAgc2NhbGUxID0gTWF0aC5zaW4odCAqIG9tZWdhKSAvIHNpbm9tO1xuICB9IGVsc2Uge1xuICAgIC8vIFwiZnJvbVwiIGFuZCBcInRvXCIgcXVhdGVybmlvbnMgYXJlIHZlcnkgY2xvc2VcbiAgICAvLyAgLi4uIHNvIHdlIGNhbiBkbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uXG4gICAgc2NhbGUwID0gMS4wIC0gdDtcbiAgICBzY2FsZTEgPSB0O1xuICB9IC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZXNcblxuXG4gIG91dFswXSA9IHNjYWxlMCAqIGF4ICsgc2NhbGUxICogYng7XG4gIG91dFsxXSA9IHNjYWxlMCAqIGF5ICsgc2NhbGUxICogYnk7XG4gIG91dFsyXSA9IHNjYWxlMCAqIGF6ICsgc2NhbGUxICogYno7XG4gIG91dFszXSA9IHNjYWxlMCAqIGF3ICsgc2NhbGUxICogYnc7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHF1YXRlcm5pb25cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20ob3V0KSB7XG4gIC8vIEltcGxlbWVudGF0aW9uIG9mIGh0dHA6Ly9wbGFubmluZy5jcy51aXVjLmVkdS9ub2RlMTk4Lmh0bWxcbiAgLy8gVE9ETzogQ2FsbGluZyByYW5kb20gMyB0aW1lcyBpcyBwcm9iYWJseSBub3QgdGhlIGZhc3Rlc3Qgc29sdXRpb25cbiAgdmFyIHUxID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gIHZhciB1MiA9IGdsTWF0cml4LlJBTkRPTSgpO1xuICB2YXIgdTMgPSBnbE1hdHJpeC5SQU5ET00oKTtcbiAgdmFyIHNxcnQxTWludXNVMSA9IE1hdGguc3FydCgxIC0gdTEpO1xuICB2YXIgc3FydFUxID0gTWF0aC5zcXJ0KHUxKTtcbiAgb3V0WzBdID0gc3FydDFNaW51c1UxICogTWF0aC5zaW4oMi4wICogTWF0aC5QSSAqIHUyKTtcbiAgb3V0WzFdID0gc3FydDFNaW51c1UxICogTWF0aC5jb3MoMi4wICogTWF0aC5QSSAqIHUyKTtcbiAgb3V0WzJdID0gc3FydFUxICogTWF0aC5zaW4oMi4wICogTWF0aC5QSSAqIHUzKTtcbiAgb3V0WzNdID0gc3FydFUxICogTWF0aC5jb3MoMi4wICogTWF0aC5QSSAqIHUzKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBpbnZlcnNlIG9mIGEgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIGludmVyc2Ugb2ZcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVydChvdXQsIGEpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXSxcbiAgICAgIGEzID0gYVszXTtcbiAgdmFyIGRvdCA9IGEwICogYTAgKyBhMSAqIGExICsgYTIgKiBhMiArIGEzICogYTM7XG4gIHZhciBpbnZEb3QgPSBkb3QgPyAxLjAgLyBkb3QgOiAwOyAvLyBUT0RPOiBXb3VsZCBiZSBmYXN0ZXIgdG8gcmV0dXJuIFswLDAsMCwwXSBpbW1lZGlhdGVseSBpZiBkb3QgPT0gMFxuXG4gIG91dFswXSA9IC1hMCAqIGludkRvdDtcbiAgb3V0WzFdID0gLWExICogaW52RG90O1xuICBvdXRbMl0gPSAtYTIgKiBpbnZEb3Q7XG4gIG91dFszXSA9IGEzICogaW52RG90O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGNvbmp1Z2F0ZSBvZiBhIHF1YXRcclxuICogSWYgdGhlIHF1YXRlcm5pb24gaXMgbm9ybWFsaXplZCwgdGhpcyBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbiBxdWF0LmludmVyc2UgYW5kIHByb2R1Y2VzIHRoZSBzYW1lIHJlc3VsdC5cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBjb25qdWdhdGUgb2ZcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbmp1Z2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiAzeDMgcm90YXRpb24gbWF0cml4LlxyXG4gKlxyXG4gKiBOT1RFOiBUaGUgcmVzdWx0YW50IHF1YXRlcm5pb24gaXMgbm90IG5vcm1hbGl6ZWQsIHNvIHlvdSBzaG91bGQgYmUgc3VyZVxyXG4gKiB0byByZW5vcm1hbGl6ZSB0aGUgcXVhdGVybmlvbiB5b3Vyc2VsZiB3aGVyZSBuZWNlc3NhcnkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge21hdDN9IG0gcm90YXRpb24gbWF0cml4XHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbU1hdDMob3V0LCBtKSB7XG4gIC8vIEFsZ29yaXRobSBpbiBLZW4gU2hvZW1ha2UncyBhcnRpY2xlIGluIDE5ODcgU0lHR1JBUEggY291cnNlIG5vdGVzXG4gIC8vIGFydGljbGUgXCJRdWF0ZXJuaW9uIENhbGN1bHVzIGFuZCBGYXN0IEFuaW1hdGlvblwiLlxuICB2YXIgZlRyYWNlID0gbVswXSArIG1bNF0gKyBtWzhdO1xuICB2YXIgZlJvb3Q7XG5cbiAgaWYgKGZUcmFjZSA+IDAuMCkge1xuICAgIC8vIHx3fCA+IDEvMiwgbWF5IGFzIHdlbGwgY2hvb3NlIHcgPiAxLzJcbiAgICBmUm9vdCA9IE1hdGguc3FydChmVHJhY2UgKyAxLjApOyAvLyAyd1xuXG4gICAgb3V0WzNdID0gMC41ICogZlJvb3Q7XG4gICAgZlJvb3QgPSAwLjUgLyBmUm9vdDsgLy8gMS8oNHcpXG5cbiAgICBvdXRbMF0gPSAobVs1XSAtIG1bN10pICogZlJvb3Q7XG4gICAgb3V0WzFdID0gKG1bNl0gLSBtWzJdKSAqIGZSb290O1xuICAgIG91dFsyXSA9IChtWzFdIC0gbVszXSkgKiBmUm9vdDtcbiAgfSBlbHNlIHtcbiAgICAvLyB8d3wgPD0gMS8yXG4gICAgdmFyIGkgPSAwO1xuICAgIGlmIChtWzRdID4gbVswXSkgaSA9IDE7XG4gICAgaWYgKG1bOF0gPiBtW2kgKiAzICsgaV0pIGkgPSAyO1xuICAgIHZhciBqID0gKGkgKyAxKSAlIDM7XG4gICAgdmFyIGsgPSAoaSArIDIpICUgMztcbiAgICBmUm9vdCA9IE1hdGguc3FydChtW2kgKiAzICsgaV0gLSBtW2ogKiAzICsgal0gLSBtW2sgKiAzICsga10gKyAxLjApO1xuICAgIG91dFtpXSA9IDAuNSAqIGZSb290O1xuICAgIGZSb290ID0gMC41IC8gZlJvb3Q7XG4gICAgb3V0WzNdID0gKG1baiAqIDMgKyBrXSAtIG1bayAqIDMgKyBqXSkgKiBmUm9vdDtcbiAgICBvdXRbal0gPSAobVtqICogMyArIGldICsgbVtpICogMyArIGpdKSAqIGZSb290O1xuICAgIG91dFtrXSA9IChtW2sgKiAzICsgaV0gKyBtW2kgKiAzICsga10pICogZlJvb3Q7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBxdWF0ZXJuaW9uIGZyb20gdGhlIGdpdmVuIGV1bGVyIGFuZ2xlIHgsIHksIHouXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge3h9IEFuZ2xlIHRvIHJvdGF0ZSBhcm91bmQgWCBheGlzIGluIGRlZ3JlZXMuXHJcbiAqIEBwYXJhbSB7eX0gQW5nbGUgdG8gcm90YXRlIGFyb3VuZCBZIGF4aXMgaW4gZGVncmVlcy5cclxuICogQHBhcmFtIHt6fSBBbmdsZSB0byByb3RhdGUgYXJvdW5kIFogYXhpcyBpbiBkZWdyZWVzLlxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21FdWxlcihvdXQsIHgsIHksIHopIHtcbiAgdmFyIGhhbGZUb1JhZCA9IDAuNSAqIE1hdGguUEkgLyAxODAuMDtcbiAgeCAqPSBoYWxmVG9SYWQ7XG4gIHkgKj0gaGFsZlRvUmFkO1xuICB6ICo9IGhhbGZUb1JhZDtcbiAgdmFyIHN4ID0gTWF0aC5zaW4oeCk7XG4gIHZhciBjeCA9IE1hdGguY29zKHgpO1xuICB2YXIgc3kgPSBNYXRoLnNpbih5KTtcbiAgdmFyIGN5ID0gTWF0aC5jb3MoeSk7XG4gIHZhciBzeiA9IE1hdGguc2luKHopO1xuICB2YXIgY3ogPSBNYXRoLmNvcyh6KTtcbiAgb3V0WzBdID0gc3ggKiBjeSAqIGN6IC0gY3ggKiBzeSAqIHN6O1xuICBvdXRbMV0gPSBjeCAqIHN5ICogY3ogKyBzeCAqIGN5ICogc3o7XG4gIG91dFsyXSA9IGN4ICogY3kgKiBzeiAtIHN4ICogc3kgKiBjejtcbiAgb3V0WzNdID0gY3ggKiBjeSAqIGN6ICsgc3ggKiBzeSAqIHN6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBxdWF0ZW5pb25cclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBhIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gJ3F1YXQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdGVybmlvbiB0byBjbG9uZVxyXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgY2xvbmUgPSB2ZWM0LmNsb25lO1xuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgcXVhdCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcclxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGZyb21WYWx1ZXMgPSB2ZWM0LmZyb21WYWx1ZXM7XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHF1YXQgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBzb3VyY2UgcXVhdGVybmlvblxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBjb3B5ID0gdmVjNC5jb3B5O1xuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHF1YXQgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcclxuICogQHJldHVybnMge3F1YXR9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc2V0ID0gdmVjNC5zZXQ7XG4vKipcclxuICogQWRkcyB0d28gcXVhdCdzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBhZGQgPSB2ZWM0LmFkZDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBTY2FsZXMgYSBxdWF0IGJ5IGEgc2NhbGFyIG51bWJlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxyXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzY2FsZSA9IHZlYzQuc2NhbGU7XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHF1YXQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBkb3QgPSB2ZWM0LmRvdDtcbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBsZXJwID0gdmVjNC5sZXJwO1xuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHF1YXRcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXHJcbiAqL1xuXG5leHBvcnQgdmFyIGxlbmd0aCA9IHZlYzQubGVuZ3RoO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5sZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBsZW4gPSBsZW5ndGg7XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSBxdWF0XHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHNxdWFyZWRMZW5ndGggPSB2ZWM0LnNxdWFyZWRMZW5ndGg7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0LnNxdWFyZWRMZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhIHF1YXRcclxuICpcclxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0ZXJuaW9uIHRvIG5vcm1hbGl6ZVxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBub3JtYWxpemUgPSB2ZWM0Lm5vcm1hbGl6ZTtcbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBxdWF0ZXJuaW9ucyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gYSBUaGUgZmlyc3QgcXVhdGVybmlvbi5cclxuICogQHBhcmFtIHtxdWF0fSBiIFRoZSBzZWNvbmQgcXVhdGVybmlvbi5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgdmFyIGV4YWN0RXF1YWxzID0gdmVjNC5leGFjdEVxdWFscztcbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBxdWF0ZXJuaW9ucyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0ge3F1YXR9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IHZhciBlcXVhbHMgPSB2ZWM0LmVxdWFscztcbi8qKlxyXG4gKiBTZXRzIGEgcXVhdGVybmlvbiB0byByZXByZXNlbnQgdGhlIHNob3J0ZXN0IHJvdGF0aW9uIGZyb20gb25lXHJcbiAqIHZlY3RvciB0byBhbm90aGVyLlxyXG4gKlxyXG4gKiBCb3RoIHZlY3RvcnMgYXJlIGFzc3VtZWQgdG8gYmUgdW5pdCBsZW5ndGguXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvbi5cclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBpbml0aWFsIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIGRlc3RpbmF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgdmFyIHJvdGF0aW9uVG8gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0bXB2ZWMzID0gdmVjMy5jcmVhdGUoKTtcbiAgdmFyIHhVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygxLCAwLCAwKTtcbiAgdmFyIHlVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygwLCAxLCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgZG90ID0gdmVjMy5kb3QoYSwgYik7XG5cbiAgICBpZiAoZG90IDwgLTAuOTk5OTk5KSB7XG4gICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIHhVbml0VmVjMywgYSk7XG4gICAgICBpZiAodmVjMy5sZW4odG1wdmVjMykgPCAwLjAwMDAwMSkgdmVjMy5jcm9zcyh0bXB2ZWMzLCB5VW5pdFZlYzMsIGEpO1xuICAgICAgdmVjMy5ub3JtYWxpemUodG1wdmVjMywgdG1wdmVjMyk7XG4gICAgICBzZXRBeGlzQW5nbGUob3V0LCB0bXB2ZWMzLCBNYXRoLlBJKTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfSBlbHNlIGlmIChkb3QgPiAwLjk5OTk5OSkge1xuICAgICAgb3V0WzBdID0gMDtcbiAgICAgIG91dFsxXSA9IDA7XG4gICAgICBvdXRbMl0gPSAwO1xuICAgICAgb3V0WzNdID0gMTtcbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZlYzMuY3Jvc3ModG1wdmVjMywgYSwgYik7XG4gICAgICBvdXRbMF0gPSB0bXB2ZWMzWzBdO1xuICAgICAgb3V0WzFdID0gdG1wdmVjM1sxXTtcbiAgICAgIG91dFsyXSA9IHRtcHZlYzNbMl07XG4gICAgICBvdXRbM10gPSAxICsgZG90O1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZShvdXQsIG91dCk7XG4gICAgfVxuICB9O1xufSgpO1xuLyoqXHJcbiAqIFBlcmZvcm1zIGEgc3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3F1YXR9IGMgdGhlIHRoaXJkIG9wZXJhbmRcclxuICogQHBhcmFtIHtxdWF0fSBkIHRoZSBmb3VydGggb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydCB2YXIgc3FsZXJwID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGVtcDEgPSBjcmVhdGUoKTtcbiAgdmFyIHRlbXAyID0gY3JlYXRlKCk7XG4gIHJldHVybiBmdW5jdGlvbiAob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gICAgc2xlcnAodGVtcDEsIGEsIGQsIHQpO1xuICAgIHNsZXJwKHRlbXAyLCBiLCBjLCB0KTtcbiAgICBzbGVycChvdXQsIHRlbXAxLCB0ZW1wMiwgMiAqIHQgKiAoMSAtIHQpKTtcbiAgICByZXR1cm4gb3V0O1xuICB9O1xufSgpO1xuLyoqXHJcbiAqIFNldHMgdGhlIHNwZWNpZmllZCBxdWF0ZXJuaW9uIHdpdGggdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuXHJcbiAqIGF4ZXMuIEVhY2ggYXhpcyBpcyBhIHZlYzMgYW5kIGlzIGV4cGVjdGVkIHRvIGJlIHVuaXQgbGVuZ3RoIGFuZFxyXG4gKiBwZXJwZW5kaWN1bGFyIHRvIGFsbCBvdGhlciBzcGVjaWZpZWQgYXhlcy5cclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSB2aWV3ICB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgdmlld2luZyBkaXJlY3Rpb25cclxuICogQHBhcmFtIHt2ZWMzfSByaWdodCB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgXCJyaWdodFwiIGRpcmVjdGlvblxyXG4gKiBAcGFyYW0ge3ZlYzN9IHVwICAgIHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBsb2NhbCBcInVwXCIgZGlyZWN0aW9uXHJcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcclxuICovXG5cbmV4cG9ydCB2YXIgc2V0QXhlcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG1hdHIgPSBtYXQzLmNyZWF0ZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKG91dCwgdmlldywgcmlnaHQsIHVwKSB7XG4gICAgbWF0clswXSA9IHJpZ2h0WzBdO1xuICAgIG1hdHJbM10gPSByaWdodFsxXTtcbiAgICBtYXRyWzZdID0gcmlnaHRbMl07XG4gICAgbWF0clsxXSA9IHVwWzBdO1xuICAgIG1hdHJbNF0gPSB1cFsxXTtcbiAgICBtYXRyWzddID0gdXBbMl07XG4gICAgbWF0clsyXSA9IC12aWV3WzBdO1xuICAgIG1hdHJbNV0gPSAtdmlld1sxXTtcbiAgICBtYXRyWzhdID0gLXZpZXdbMl07XG4gICAgcmV0dXJuIG5vcm1hbGl6ZShvdXQsIGZyb21NYXQzKG91dCwgbWF0cikpO1xuICB9O1xufSgpOyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuaW1wb3J0ICogYXMgcXVhdCBmcm9tIFwiLi9xdWF0LmpzXCI7XG5pbXBvcnQgKiBhcyBtYXQ0IGZyb20gXCIuL21hdDQuanNcIjtcbi8qKlxyXG4gKiBEdWFsIFF1YXRlcm5pb248YnI+XHJcbiAqIEZvcm1hdDogW3JlYWwsIGR1YWxdPGJyPlxyXG4gKiBRdWF0ZXJuaW9uIGZvcm1hdDogWFlaVzxicj5cclxuICogTWFrZSBzdXJlIHRvIGhhdmUgbm9ybWFsaXplZCBkdWFsIHF1YXRlcm5pb25zLCBvdGhlcndpc2UgdGhlIGZ1bmN0aW9ucyBtYXkgbm90IHdvcmsgYXMgaW50ZW5kZWQuPGJyPlxyXG4gKiBAbW9kdWxlIHF1YXQyXHJcbiAqL1xuXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBkdWFsIHF1YXRcclxuICpcclxuICogQHJldHVybnMge3F1YXQyfSBhIG5ldyBkdWFsIHF1YXRlcm5pb24gW3JlYWwgLT4gcm90YXRpb24sIGR1YWwgLT4gdHJhbnNsYXRpb25dXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgZHEgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg4KTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBkcVswXSA9IDA7XG4gICAgZHFbMV0gPSAwO1xuICAgIGRxWzJdID0gMDtcbiAgICBkcVs0XSA9IDA7XG4gICAgZHFbNV0gPSAwO1xuICAgIGRxWzZdID0gMDtcbiAgICBkcVs3XSA9IDA7XG4gIH1cblxuICBkcVszXSA9IDE7XG4gIHJldHVybiBkcTtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHF1YXQgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IGEgZHVhbCBxdWF0ZXJuaW9uIHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gbmV3IGR1YWwgcXVhdGVybmlvblxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBkcSA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDgpO1xuICBkcVswXSA9IGFbMF07XG4gIGRxWzFdID0gYVsxXTtcbiAgZHFbMl0gPSBhWzJdO1xuICBkcVszXSA9IGFbM107XG4gIGRxWzRdID0gYVs0XTtcbiAgZHFbNV0gPSBhWzVdO1xuICBkcVs2XSA9IGFbNl07XG4gIGRxWzddID0gYVs3XTtcbiAgcmV0dXJuIGRxO1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgZHVhbCBxdWF0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge051bWJlcn0geDEgWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkxIFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6MSBaIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdzEgVyBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHgyIFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5MiBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gejIgWiBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHcyIFcgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gbmV3IGR1YWwgcXVhdGVybmlvblxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKHgxLCB5MSwgejEsIHcxLCB4MiwgeTIsIHoyLCB3Mikge1xuICB2YXIgZHEgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg4KTtcbiAgZHFbMF0gPSB4MTtcbiAgZHFbMV0gPSB5MTtcbiAgZHFbMl0gPSB6MTtcbiAgZHFbM10gPSB3MTtcbiAgZHFbNF0gPSB4MjtcbiAgZHFbNV0gPSB5MjtcbiAgZHFbNl0gPSB6MjtcbiAgZHFbN10gPSB3MjtcbiAgcmV0dXJuIGRxO1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgZHVhbCBxdWF0IGZyb20gdGhlIGdpdmVuIHZhbHVlcyAocXVhdCBhbmQgdHJhbnNsYXRpb24pXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MSBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geTEgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHoxIFogY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3MSBXIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geDIgWCBjb21wb25lbnQgKHRyYW5zbGF0aW9uKVxyXG4gKiBAcGFyYW0ge051bWJlcn0geTIgWSBjb21wb25lbnQgKHRyYW5zbGF0aW9uKVxyXG4gKiBAcGFyYW0ge051bWJlcn0gejIgWiBjb21wb25lbnQgKHRyYW5zbGF0aW9uKVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG5ldyBkdWFsIHF1YXRlcm5pb25cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25WYWx1ZXMoeDEsIHkxLCB6MSwgdzEsIHgyLCB5MiwgejIpIHtcbiAgdmFyIGRxID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoOCk7XG4gIGRxWzBdID0geDE7XG4gIGRxWzFdID0geTE7XG4gIGRxWzJdID0gejE7XG4gIGRxWzNdID0gdzE7XG4gIHZhciBheCA9IHgyICogMC41LFxuICAgICAgYXkgPSB5MiAqIDAuNSxcbiAgICAgIGF6ID0gejIgKiAwLjU7XG4gIGRxWzRdID0gYXggKiB3MSArIGF5ICogejEgLSBheiAqIHkxO1xuICBkcVs1XSA9IGF5ICogdzEgKyBheiAqIHgxIC0gYXggKiB6MTtcbiAgZHFbNl0gPSBheiAqIHcxICsgYXggKiB5MSAtIGF5ICogeDE7XG4gIGRxWzddID0gLWF4ICogeDEgLSBheSAqIHkxIC0gYXogKiB6MTtcbiAgcmV0dXJuIGRxO1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBkdWFsIHF1YXQgZnJvbSBhIHF1YXRlcm5pb24gYW5kIGEgdHJhbnNsYXRpb25cclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gZHVhbCBxdWF0ZXJuaW9uIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7dmVjM30gdCB0cmFubGF0aW9uIHZlY3RvclxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IGR1YWwgcXVhdGVybmlvbiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvbihvdXQsIHEsIHQpIHtcbiAgdmFyIGF4ID0gdFswXSAqIDAuNSxcbiAgICAgIGF5ID0gdFsxXSAqIDAuNSxcbiAgICAgIGF6ID0gdFsyXSAqIDAuNSxcbiAgICAgIGJ4ID0gcVswXSxcbiAgICAgIGJ5ID0gcVsxXSxcbiAgICAgIGJ6ID0gcVsyXSxcbiAgICAgIGJ3ID0gcVszXTtcbiAgb3V0WzBdID0gYng7XG4gIG91dFsxXSA9IGJ5O1xuICBvdXRbMl0gPSBiejtcbiAgb3V0WzNdID0gYnc7XG4gIG91dFs0XSA9IGF4ICogYncgKyBheSAqIGJ6IC0gYXogKiBieTtcbiAgb3V0WzVdID0gYXkgKiBidyArIGF6ICogYnggLSBheCAqIGJ6O1xuICBvdXRbNl0gPSBheiAqIGJ3ICsgYXggKiBieSAtIGF5ICogYng7XG4gIG91dFs3XSA9IC1heCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIGR1YWwgcXVhdCBmcm9tIGEgdHJhbnNsYXRpb25cclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gZHVhbCBxdWF0ZXJuaW9uIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7dmVjM30gdCB0cmFuc2xhdGlvbiB2ZWN0b3JcclxuICogQHJldHVybnMge3F1YXQyfSBkdWFsIHF1YXRlcm5pb24gcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdCkge1xuICBvdXRbMF0gPSAwO1xuICBvdXRbMV0gPSAwO1xuICBvdXRbMl0gPSAwO1xuICBvdXRbM10gPSAxO1xuICBvdXRbNF0gPSB0WzBdICogMC41O1xuICBvdXRbNV0gPSB0WzFdICogMC41O1xuICBvdXRbNl0gPSB0WzJdICogMC41O1xuICBvdXRbN10gPSAwO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBkdWFsIHF1YXQgZnJvbSBhIHF1YXRlcm5pb25cclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gZHVhbCBxdWF0ZXJuaW9uIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XHJcbiAqIEBwYXJhbSB7cXVhdH0gcSB0aGUgcXVhdGVybmlvblxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IGR1YWwgcXVhdGVybmlvbiByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUm90YXRpb24ob3V0LCBxKSB7XG4gIG91dFswXSA9IHFbMF07XG4gIG91dFsxXSA9IHFbMV07XG4gIG91dFsyXSA9IHFbMl07XG4gIG91dFszXSA9IHFbM107XG4gIG91dFs0XSA9IDA7XG4gIG91dFs1XSA9IDA7XG4gIG91dFs2XSA9IDA7XG4gIG91dFs3XSA9IDA7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBkdWFsIHF1YXQgZnJvbSBhIG1hdHJpeCAoNHg0KVxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeFxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IGR1YWwgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTWF0NChvdXQsIGEpIHtcbiAgLy9UT0RPIE9wdGltaXplIHRoaXNcbiAgdmFyIG91dGVyID0gcXVhdC5jcmVhdGUoKTtcbiAgbWF0NC5nZXRSb3RhdGlvbihvdXRlciwgYSk7XG4gIHZhciB0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIG1hdDQuZ2V0VHJhbnNsYXRpb24odCwgYSk7XG4gIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKG91dCwgb3V0ZXIsIHQpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBkdWFsIHF1YXQgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtxdWF0Mn0gYSB0aGUgc291cmNlIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSBhWzRdO1xuICBvdXRbNV0gPSBhWzVdO1xuICBvdXRbNl0gPSBhWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCBhIGR1YWwgcXVhdCB0byB0aGUgaWRlbnRpdHkgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMDtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMDtcbiAgb3V0WzZdID0gMDtcbiAgb3V0WzddID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBkdWFsIHF1YXQgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4MSBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geTEgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHoxIFogY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3MSBXIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geDIgWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkyIFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6MiBaIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdzIgVyBjb21wb25lbnRcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgeDEsIHkxLCB6MSwgdzEsIHgyLCB5MiwgejIsIHcyKSB7XG4gIG91dFswXSA9IHgxO1xuICBvdXRbMV0gPSB5MTtcbiAgb3V0WzJdID0gejE7XG4gIG91dFszXSA9IHcxO1xuICBvdXRbNF0gPSB4MjtcbiAgb3V0WzVdID0geTI7XG4gIG91dFs2XSA9IHoyO1xuICBvdXRbN10gPSB3MjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZXRzIHRoZSByZWFsIHBhcnQgb2YgYSBkdWFsIHF1YXRcclxuICogQHBhcmFtICB7cXVhdH0gb3V0IHJlYWwgcGFydFxyXG4gKiBAcGFyYW0gIHtxdWF0Mn0gYSBEdWFsIFF1YXRlcm5pb25cclxuICogQHJldHVybiB7cXVhdH0gcmVhbCBwYXJ0XHJcbiAqL1xuXG5leHBvcnQgdmFyIGdldFJlYWwgPSBxdWF0LmNvcHk7XG4vKipcclxuICogR2V0cyB0aGUgZHVhbCBwYXJ0IG9mIGEgZHVhbCBxdWF0XHJcbiAqIEBwYXJhbSAge3F1YXR9IG91dCBkdWFsIHBhcnRcclxuICogQHBhcmFtICB7cXVhdDJ9IGEgRHVhbCBRdWF0ZXJuaW9uXHJcbiAqIEByZXR1cm4ge3F1YXR9IGR1YWwgcGFydFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldER1YWwob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbNF07XG4gIG91dFsxXSA9IGFbNV07XG4gIG91dFsyXSA9IGFbNl07XG4gIG91dFszXSA9IGFbN107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSByZWFsIGNvbXBvbmVudCBvZiBhIGR1YWwgcXVhdCB0byB0aGUgZ2l2ZW4gcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdH0gcSBhIHF1YXRlcm5pb24gcmVwcmVzZW50aW5nIHRoZSByZWFsIHBhcnRcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHNldFJlYWwgPSBxdWF0LmNvcHk7XG4vKipcclxuICogU2V0IHRoZSBkdWFsIGNvbXBvbmVudCBvZiBhIGR1YWwgcXVhdCB0byB0aGUgZ2l2ZW4gcXVhdGVybmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdH0gcSBhIHF1YXRlcm5pb24gcmVwcmVzZW50aW5nIHRoZSBkdWFsIHBhcnRcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0RHVhbChvdXQsIHEpIHtcbiAgb3V0WzRdID0gcVswXTtcbiAgb3V0WzVdID0gcVsxXTtcbiAgb3V0WzZdID0gcVsyXTtcbiAgb3V0WzddID0gcVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZXRzIHRoZSB0cmFuc2xhdGlvbiBvZiBhIG5vcm1hbGl6ZWQgZHVhbCBxdWF0XHJcbiAqIEBwYXJhbSAge3ZlYzN9IG91dCB0cmFuc2xhdGlvblxyXG4gKiBAcGFyYW0gIHtxdWF0Mn0gYSBEdWFsIFF1YXRlcm5pb24gdG8gYmUgZGVjb21wb3NlZFxyXG4gKiBAcmV0dXJuIHt2ZWMzfSB0cmFuc2xhdGlvblxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uKG91dCwgYSkge1xuICB2YXIgYXggPSBhWzRdLFxuICAgICAgYXkgPSBhWzVdLFxuICAgICAgYXogPSBhWzZdLFxuICAgICAgYXcgPSBhWzddLFxuICAgICAgYnggPSAtYVswXSxcbiAgICAgIGJ5ID0gLWFbMV0sXG4gICAgICBieiA9IC1hWzJdLFxuICAgICAgYncgPSBhWzNdO1xuICBvdXRbMF0gPSAoYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSkgKiAyO1xuICBvdXRbMV0gPSAoYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieikgKiAyO1xuICBvdXRbMl0gPSAoYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieCkgKiAyO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zbGF0ZXMgYSBkdWFsIHF1YXQgYnkgdGhlIGdpdmVuIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtxdWF0Mn0gYSB0aGUgZHVhbCBxdWF0ZXJuaW9uIHRvIHRyYW5zbGF0ZVxyXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIGEsIHYpIHtcbiAgdmFyIGF4MSA9IGFbMF0sXG4gICAgICBheTEgPSBhWzFdLFxuICAgICAgYXoxID0gYVsyXSxcbiAgICAgIGF3MSA9IGFbM10sXG4gICAgICBieDEgPSB2WzBdICogMC41LFxuICAgICAgYnkxID0gdlsxXSAqIDAuNSxcbiAgICAgIGJ6MSA9IHZbMl0gKiAwLjUsXG4gICAgICBheDIgPSBhWzRdLFxuICAgICAgYXkyID0gYVs1XSxcbiAgICAgIGF6MiA9IGFbNl0sXG4gICAgICBhdzIgPSBhWzddO1xuICBvdXRbMF0gPSBheDE7XG4gIG91dFsxXSA9IGF5MTtcbiAgb3V0WzJdID0gYXoxO1xuICBvdXRbM10gPSBhdzE7XG4gIG91dFs0XSA9IGF3MSAqIGJ4MSArIGF5MSAqIGJ6MSAtIGF6MSAqIGJ5MSArIGF4MjtcbiAgb3V0WzVdID0gYXcxICogYnkxICsgYXoxICogYngxIC0gYXgxICogYnoxICsgYXkyO1xuICBvdXRbNl0gPSBhdzEgKiBiejEgKyBheDEgKiBieTEgLSBheTEgKiBieDEgKyBhejI7XG4gIG91dFs3XSA9IC1heDEgKiBieDEgLSBheTEgKiBieTEgLSBhejEgKiBiejEgKyBhdzI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIGR1YWwgcXVhdCBhcm91bmQgdGhlIFggYXhpc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtxdWF0Mn0gYSB0aGUgZHVhbCBxdWF0ZXJuaW9uIHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGhvdyBmYXIgc2hvdWxkIHRoZSByb3RhdGlvbiBiZVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCByYWQpIHtcbiAgdmFyIGJ4ID0gLWFbMF0sXG4gICAgICBieSA9IC1hWzFdLFxuICAgICAgYnogPSAtYVsyXSxcbiAgICAgIGJ3ID0gYVszXSxcbiAgICAgIGF4ID0gYVs0XSxcbiAgICAgIGF5ID0gYVs1XSxcbiAgICAgIGF6ID0gYVs2XSxcbiAgICAgIGF3ID0gYVs3XSxcbiAgICAgIGF4MSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnksXG4gICAgICBheTEgPSBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6LFxuICAgICAgYXoxID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieCxcbiAgICAgIGF3MSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gIHF1YXQucm90YXRlWChvdXQsIGEsIHJhZCk7XG4gIGJ4ID0gb3V0WzBdO1xuICBieSA9IG91dFsxXTtcbiAgYnogPSBvdXRbMl07XG4gIGJ3ID0gb3V0WzNdO1xuICBvdXRbNF0gPSBheDEgKiBidyArIGF3MSAqIGJ4ICsgYXkxICogYnogLSBhejEgKiBieTtcbiAgb3V0WzVdID0gYXkxICogYncgKyBhdzEgKiBieSArIGF6MSAqIGJ4IC0gYXgxICogYno7XG4gIG91dFs2XSA9IGF6MSAqIGJ3ICsgYXcxICogYnogKyBheDEgKiBieSAtIGF5MSAqIGJ4O1xuICBvdXRbN10gPSBhdzEgKiBidyAtIGF4MSAqIGJ4IC0gYXkxICogYnkgLSBhejEgKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgZHVhbCBxdWF0IGFyb3VuZCB0aGUgWSBheGlzXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge3F1YXQyfSBhIHRoZSBkdWFsIHF1YXRlcm5pb24gdG8gcm90YXRlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgaG93IGZhciBzaG91bGQgdGhlIHJvdGF0aW9uIGJlXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIHJhZCkge1xuICB2YXIgYnggPSAtYVswXSxcbiAgICAgIGJ5ID0gLWFbMV0sXG4gICAgICBieiA9IC1hWzJdLFxuICAgICAgYncgPSBhWzNdLFxuICAgICAgYXggPSBhWzRdLFxuICAgICAgYXkgPSBhWzVdLFxuICAgICAgYXogPSBhWzZdLFxuICAgICAgYXcgPSBhWzddLFxuICAgICAgYXgxID0gYXggKiBidyArIGF3ICogYnggKyBheSAqIGJ6IC0gYXogKiBieSxcbiAgICAgIGF5MSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnosXG4gICAgICBhejEgPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4LFxuICAgICAgYXcxID0gYXcgKiBidyAtIGF4ICogYnggLSBheSAqIGJ5IC0gYXogKiBiejtcbiAgcXVhdC5yb3RhdGVZKG91dCwgYSwgcmFkKTtcbiAgYnggPSBvdXRbMF07XG4gIGJ5ID0gb3V0WzFdO1xuICBieiA9IG91dFsyXTtcbiAgYncgPSBvdXRbM107XG4gIG91dFs0XSA9IGF4MSAqIGJ3ICsgYXcxICogYnggKyBheTEgKiBieiAtIGF6MSAqIGJ5O1xuICBvdXRbNV0gPSBheTEgKiBidyArIGF3MSAqIGJ5ICsgYXoxICogYnggLSBheDEgKiBiejtcbiAgb3V0WzZdID0gYXoxICogYncgKyBhdzEgKiBieiArIGF4MSAqIGJ5IC0gYXkxICogYng7XG4gIG91dFs3XSA9IGF3MSAqIGJ3IC0gYXgxICogYnggLSBheTEgKiBieSAtIGF6MSAqIGJ6O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJvdGF0ZXMgYSBkdWFsIHF1YXQgYXJvdW5kIHRoZSBaIGF4aXNcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IGEgdGhlIGR1YWwgcXVhdGVybmlvbiB0byByb3RhdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBob3cgZmFyIHNob3VsZCB0aGUgcm90YXRpb24gYmVcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgcmFkKSB7XG4gIHZhciBieCA9IC1hWzBdLFxuICAgICAgYnkgPSAtYVsxXSxcbiAgICAgIGJ6ID0gLWFbMl0sXG4gICAgICBidyA9IGFbM10sXG4gICAgICBheCA9IGFbNF0sXG4gICAgICBheSA9IGFbNV0sXG4gICAgICBheiA9IGFbNl0sXG4gICAgICBhdyA9IGFbN10sXG4gICAgICBheDEgPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5LFxuICAgICAgYXkxID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBieixcbiAgICAgIGF6MSA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYngsXG4gICAgICBhdzEgPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICBxdWF0LnJvdGF0ZVoob3V0LCBhLCByYWQpO1xuICBieCA9IG91dFswXTtcbiAgYnkgPSBvdXRbMV07XG4gIGJ6ID0gb3V0WzJdO1xuICBidyA9IG91dFszXTtcbiAgb3V0WzRdID0gYXgxICogYncgKyBhdzEgKiBieCArIGF5MSAqIGJ6IC0gYXoxICogYnk7XG4gIG91dFs1XSA9IGF5MSAqIGJ3ICsgYXcxICogYnkgKyBhejEgKiBieCAtIGF4MSAqIGJ6O1xuICBvdXRbNl0gPSBhejEgKiBidyArIGF3MSAqIGJ6ICsgYXgxICogYnkgLSBheTEgKiBieDtcbiAgb3V0WzddID0gYXcxICogYncgLSBheDEgKiBieCAtIGF5MSAqIGJ5IC0gYXoxICogYno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUm90YXRlcyBhIGR1YWwgcXVhdCBieSBhIGdpdmVuIHF1YXRlcm5pb24gKGEgKiBxKVxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtxdWF0Mn0gYSB0aGUgZHVhbCBxdWF0ZXJuaW9uIHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge3F1YXR9IHEgcXVhdGVybmlvbiB0byByb3RhdGUgYnlcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByb3RhdGVCeVF1YXRBcHBlbmQob3V0LCBhLCBxKSB7XG4gIHZhciBxeCA9IHFbMF0sXG4gICAgICBxeSA9IHFbMV0sXG4gICAgICBxeiA9IHFbMl0sXG4gICAgICBxdyA9IHFbM10sXG4gICAgICBheCA9IGFbMF0sXG4gICAgICBheSA9IGFbMV0sXG4gICAgICBheiA9IGFbMl0sXG4gICAgICBhdyA9IGFbM107XG4gIG91dFswXSA9IGF4ICogcXcgKyBhdyAqIHF4ICsgYXkgKiBxeiAtIGF6ICogcXk7XG4gIG91dFsxXSA9IGF5ICogcXcgKyBhdyAqIHF5ICsgYXogKiBxeCAtIGF4ICogcXo7XG4gIG91dFsyXSA9IGF6ICogcXcgKyBhdyAqIHF6ICsgYXggKiBxeSAtIGF5ICogcXg7XG4gIG91dFszXSA9IGF3ICogcXcgLSBheCAqIHF4IC0gYXkgKiBxeSAtIGF6ICogcXo7XG4gIGF4ID0gYVs0XTtcbiAgYXkgPSBhWzVdO1xuICBheiA9IGFbNl07XG4gIGF3ID0gYVs3XTtcbiAgb3V0WzRdID0gYXggKiBxdyArIGF3ICogcXggKyBheSAqIHF6IC0gYXogKiBxeTtcbiAgb3V0WzVdID0gYXkgKiBxdyArIGF3ICogcXkgKyBheiAqIHF4IC0gYXggKiBxejtcbiAgb3V0WzZdID0gYXogKiBxdyArIGF3ICogcXogKyBheCAqIHF5IC0gYXkgKiBxeDtcbiAgb3V0WzddID0gYXcgKiBxdyAtIGF4ICogcXggLSBheSAqIHF5IC0gYXogKiBxejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgZHVhbCBxdWF0IGJ5IGEgZ2l2ZW4gcXVhdGVybmlvbiAocSAqIGEpXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdGVybmlvblxyXG4gKiBAcGFyYW0ge3F1YXR9IHEgcXVhdGVybmlvbiB0byByb3RhdGUgYnlcclxuICogQHBhcmFtIHtxdWF0Mn0gYSB0aGUgZHVhbCBxdWF0ZXJuaW9uIHRvIHJvdGF0ZVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZUJ5UXVhdFByZXBlbmQob3V0LCBxLCBhKSB7XG4gIHZhciBxeCA9IHFbMF0sXG4gICAgICBxeSA9IHFbMV0sXG4gICAgICBxeiA9IHFbMl0sXG4gICAgICBxdyA9IHFbM10sXG4gICAgICBieCA9IGFbMF0sXG4gICAgICBieSA9IGFbMV0sXG4gICAgICBieiA9IGFbMl0sXG4gICAgICBidyA9IGFbM107XG4gIG91dFswXSA9IHF4ICogYncgKyBxdyAqIGJ4ICsgcXkgKiBieiAtIHF6ICogYnk7XG4gIG91dFsxXSA9IHF5ICogYncgKyBxdyAqIGJ5ICsgcXogKiBieCAtIHF4ICogYno7XG4gIG91dFsyXSA9IHF6ICogYncgKyBxdyAqIGJ6ICsgcXggKiBieSAtIHF5ICogYng7XG4gIG91dFszXSA9IHF3ICogYncgLSBxeCAqIGJ4IC0gcXkgKiBieSAtIHF6ICogYno7XG4gIGJ4ID0gYVs0XTtcbiAgYnkgPSBhWzVdO1xuICBieiA9IGFbNl07XG4gIGJ3ID0gYVs3XTtcbiAgb3V0WzRdID0gcXggKiBidyArIHF3ICogYnggKyBxeSAqIGJ6IC0gcXogKiBieTtcbiAgb3V0WzVdID0gcXkgKiBidyArIHF3ICogYnkgKyBxeiAqIGJ4IC0gcXggKiBiejtcbiAgb3V0WzZdID0gcXogKiBidyArIHF3ICogYnogKyBxeCAqIGJ5IC0gcXkgKiBieDtcbiAgb3V0WzddID0gcXcgKiBidyAtIHF4ICogYnggLSBxeSAqIGJ5IC0gcXogKiBiejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGVzIGEgZHVhbCBxdWF0IGFyb3VuZCBhIGdpdmVuIGF4aXMuIERvZXMgdGhlIG5vcm1hbGlzYXRpb24gYXV0b21hdGljYWxseVxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtxdWF0Mn0gYSB0aGUgZHVhbCBxdWF0ZXJuaW9uIHRvIHJvdGF0ZVxyXG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIGhvdyBmYXIgdGhlIHJvdGF0aW9uIHNob3VsZCBiZVxyXG4gKiBAcmV0dXJucyB7cXVhdDJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdGF0ZUFyb3VuZEF4aXMob3V0LCBhLCBheGlzLCByYWQpIHtcbiAgLy9TcGVjaWFsIGNhc2UgZm9yIHJhZCA9IDBcbiAgaWYgKE1hdGguYWJzKHJhZCkgPCBnbE1hdHJpeC5FUFNJTE9OKSB7XG4gICAgcmV0dXJuIGNvcHkob3V0LCBhKTtcbiAgfVxuXG4gIHZhciBheGlzTGVuZ3RoID0gTWF0aC5zcXJ0KGF4aXNbMF0gKiBheGlzWzBdICsgYXhpc1sxXSAqIGF4aXNbMV0gKyBheGlzWzJdICogYXhpc1syXSk7XG4gIHJhZCA9IHJhZCAqIDAuNTtcbiAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICB2YXIgYnggPSBzICogYXhpc1swXSAvIGF4aXNMZW5ndGg7XG4gIHZhciBieSA9IHMgKiBheGlzWzFdIC8gYXhpc0xlbmd0aDtcbiAgdmFyIGJ6ID0gcyAqIGF4aXNbMl0gLyBheGlzTGVuZ3RoO1xuICB2YXIgYncgPSBNYXRoLmNvcyhyYWQpO1xuICB2YXIgYXgxID0gYVswXSxcbiAgICAgIGF5MSA9IGFbMV0sXG4gICAgICBhejEgPSBhWzJdLFxuICAgICAgYXcxID0gYVszXTtcbiAgb3V0WzBdID0gYXgxICogYncgKyBhdzEgKiBieCArIGF5MSAqIGJ6IC0gYXoxICogYnk7XG4gIG91dFsxXSA9IGF5MSAqIGJ3ICsgYXcxICogYnkgKyBhejEgKiBieCAtIGF4MSAqIGJ6O1xuICBvdXRbMl0gPSBhejEgKiBidyArIGF3MSAqIGJ6ICsgYXgxICogYnkgLSBheTEgKiBieDtcbiAgb3V0WzNdID0gYXcxICogYncgLSBheDEgKiBieCAtIGF5MSAqIGJ5IC0gYXoxICogYno7XG4gIHZhciBheCA9IGFbNF0sXG4gICAgICBheSA9IGFbNV0sXG4gICAgICBheiA9IGFbNl0sXG4gICAgICBhdyA9IGFbN107XG4gIG91dFs0XSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gIG91dFs1XSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYno7XG4gIG91dFs2XSA9IGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYng7XG4gIG91dFs3XSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gZHVhbCBxdWF0J3NcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtxdWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgb3V0WzRdID0gYVs0XSArIGJbNF07XG4gIG91dFs1XSA9IGFbNV0gKyBiWzVdO1xuICBvdXRbNl0gPSBhWzZdICsgYls2XTtcbiAgb3V0WzddID0gYVs3XSArIGJbN107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTXVsdGlwbGllcyB0d28gZHVhbCBxdWF0J3NcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgZHVhbCBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHtxdWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgdmFyIGF4MCA9IGFbMF0sXG4gICAgICBheTAgPSBhWzFdLFxuICAgICAgYXowID0gYVsyXSxcbiAgICAgIGF3MCA9IGFbM10sXG4gICAgICBieDEgPSBiWzRdLFxuICAgICAgYnkxID0gYls1XSxcbiAgICAgIGJ6MSA9IGJbNl0sXG4gICAgICBidzEgPSBiWzddLFxuICAgICAgYXgxID0gYVs0XSxcbiAgICAgIGF5MSA9IGFbNV0sXG4gICAgICBhejEgPSBhWzZdLFxuICAgICAgYXcxID0gYVs3XSxcbiAgICAgIGJ4MCA9IGJbMF0sXG4gICAgICBieTAgPSBiWzFdLFxuICAgICAgYnowID0gYlsyXSxcbiAgICAgIGJ3MCA9IGJbM107XG4gIG91dFswXSA9IGF4MCAqIGJ3MCArIGF3MCAqIGJ4MCArIGF5MCAqIGJ6MCAtIGF6MCAqIGJ5MDtcbiAgb3V0WzFdID0gYXkwICogYncwICsgYXcwICogYnkwICsgYXowICogYngwIC0gYXgwICogYnowO1xuICBvdXRbMl0gPSBhejAgKiBidzAgKyBhdzAgKiBiejAgKyBheDAgKiBieTAgLSBheTAgKiBieDA7XG4gIG91dFszXSA9IGF3MCAqIGJ3MCAtIGF4MCAqIGJ4MCAtIGF5MCAqIGJ5MCAtIGF6MCAqIGJ6MDtcbiAgb3V0WzRdID0gYXgwICogYncxICsgYXcwICogYngxICsgYXkwICogYnoxIC0gYXowICogYnkxICsgYXgxICogYncwICsgYXcxICogYngwICsgYXkxICogYnowIC0gYXoxICogYnkwO1xuICBvdXRbNV0gPSBheTAgKiBidzEgKyBhdzAgKiBieTEgKyBhejAgKiBieDEgLSBheDAgKiBiejEgKyBheTEgKiBidzAgKyBhdzEgKiBieTAgKyBhejEgKiBieDAgLSBheDEgKiBiejA7XG4gIG91dFs2XSA9IGF6MCAqIGJ3MSArIGF3MCAqIGJ6MSArIGF4MCAqIGJ5MSAtIGF5MCAqIGJ4MSArIGF6MSAqIGJ3MCArIGF3MSAqIGJ6MCArIGF4MSAqIGJ5MCAtIGF5MSAqIGJ4MDtcbiAgb3V0WzddID0gYXcwICogYncxIC0gYXgwICogYngxIC0gYXkwICogYnkxIC0gYXowICogYnoxICsgYXcxICogYncwIC0gYXgxICogYngwIC0gYXkxICogYnkwIC0gYXoxICogYnowO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdDIubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBTY2FsZXMgYSBkdWFsIHF1YXQgYnkgYSBzY2FsYXIgbnVtYmVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IG91dCB0aGUgcmVjZWl2aW5nIGR1YWwgcXVhdFxyXG4gKiBAcGFyYW0ge3F1YXQyfSBhIHRoZSBkdWFsIHF1YXQgdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSBkdWFsIHF1YXQgYnlcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiO1xuICBvdXRbMV0gPSBhWzFdICogYjtcbiAgb3V0WzJdID0gYVsyXSAqIGI7XG4gIG91dFszXSA9IGFbM10gKiBiO1xuICBvdXRbNF0gPSBhWzRdICogYjtcbiAgb3V0WzVdID0gYVs1XSAqIGI7XG4gIG91dFs2XSA9IGFbNl0gKiBiO1xuICBvdXRbN10gPSBhWzddICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gZHVhbCBxdWF0J3MgKFRoZSBkb3QgcHJvZHVjdCBvZiB0aGUgcmVhbCBwYXJ0cylcclxuICpcclxuICogQHBhcmFtIHtxdWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3F1YXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBkb3QgPSBxdWF0LmRvdDtcbi8qKlxyXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIGR1YWwgcXVhdHMnc1xyXG4gKiBOT1RFOiBUaGUgcmVzdWx0aW5nIGR1YWwgcXVhdGVybmlvbnMgd29uJ3QgYWx3YXlzIGJlIG5vcm1hbGl6ZWQgKFRoZSBlcnJvciBpcyBtb3N0IG5vdGljZWFibGUgd2hlbiB0ID0gMC41KVxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRcclxuICogQHBhcmFtIHtxdWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3F1YXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCwgaW4gdGhlIHJhbmdlIFswLTFdLCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIG10ID0gMSAtIHQ7XG4gIGlmIChkb3QoYSwgYikgPCAwKSB0ID0gLXQ7XG4gIG91dFswXSA9IGFbMF0gKiBtdCArIGJbMF0gKiB0O1xuICBvdXRbMV0gPSBhWzFdICogbXQgKyBiWzFdICogdDtcbiAgb3V0WzJdID0gYVsyXSAqIG10ICsgYlsyXSAqIHQ7XG4gIG91dFszXSA9IGFbM10gKiBtdCArIGJbM10gKiB0O1xuICBvdXRbNF0gPSBhWzRdICogbXQgKyBiWzRdICogdDtcbiAgb3V0WzVdID0gYVs1XSAqIG10ICsgYls1XSAqIHQ7XG4gIG91dFs2XSA9IGFbNl0gKiBtdCArIGJbNl0gKiB0O1xuICBvdXRbN10gPSBhWzddICogbXQgKyBiWzddICogdDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBpbnZlcnNlIG9mIGEgZHVhbCBxdWF0LiBJZiB0aGV5IGFyZSBub3JtYWxpemVkLCBjb25qdWdhdGUgaXMgY2hlYXBlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtxdWF0Mn0gYSBkdWFsIHF1YXQgdG8gY2FsY3VsYXRlIGludmVyc2Ugb2ZcclxuICogQHJldHVybnMge3F1YXQyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBzcWxlbiA9IHNxdWFyZWRMZW5ndGgoYSk7XG4gIG91dFswXSA9IC1hWzBdIC8gc3FsZW47XG4gIG91dFsxXSA9IC1hWzFdIC8gc3FsZW47XG4gIG91dFsyXSA9IC1hWzJdIC8gc3FsZW47XG4gIG91dFszXSA9IGFbM10gLyBzcWxlbjtcbiAgb3V0WzRdID0gLWFbNF0gLyBzcWxlbjtcbiAgb3V0WzVdID0gLWFbNV0gLyBzcWxlbjtcbiAgb3V0WzZdID0gLWFbNl0gLyBzcWxlbjtcbiAgb3V0WzddID0gYVs3XSAvIHNxbGVuO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGNvbmp1Z2F0ZSBvZiBhIGR1YWwgcXVhdFxyXG4gKiBJZiB0aGUgZHVhbCBxdWF0ZXJuaW9uIGlzIG5vcm1hbGl6ZWQsIHRoaXMgZnVuY3Rpb24gaXMgZmFzdGVyIHRoYW4gcXVhdDIuaW52ZXJzZSBhbmQgcHJvZHVjZXMgdGhlIHNhbWUgcmVzdWx0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IGEgcXVhdCB0byBjYWxjdWxhdGUgY29uanVnYXRlIG9mXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY29uanVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICBvdXRbNF0gPSAtYVs0XTtcbiAgb3V0WzVdID0gLWFbNV07XG4gIG91dFs2XSA9IC1hWzZdO1xuICBvdXRbN10gPSBhWzddO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIGR1YWwgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBhIGR1YWwgcXVhdCB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBsZW5ndGggPSBxdWF0Lmxlbmd0aDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQyLmxlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGxlbiA9IGxlbmd0aDtcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIGR1YWwgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBhIGR1YWwgcXVhdCB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc3F1YXJlZExlbmd0aCA9IHF1YXQuc3F1YXJlZExlbmd0aDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQyLnNxdWFyZWRMZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhIGR1YWwgcXVhdFxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBvdXQgdGhlIHJlY2VpdmluZyBkdWFsIHF1YXRlcm5pb25cclxuICogQHBhcmFtIHtxdWF0Mn0gYSBkdWFsIHF1YXRlcm5pb24gdG8gbm9ybWFsaXplXHJcbiAqIEByZXR1cm5zIHtxdWF0Mn0gb3V0XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIG1hZ25pdHVkZSA9IHNxdWFyZWRMZW5ndGgoYSk7XG5cbiAgaWYgKG1hZ25pdHVkZSA+IDApIHtcbiAgICBtYWduaXR1ZGUgPSBNYXRoLnNxcnQobWFnbml0dWRlKTtcbiAgICB2YXIgYTAgPSBhWzBdIC8gbWFnbml0dWRlO1xuICAgIHZhciBhMSA9IGFbMV0gLyBtYWduaXR1ZGU7XG4gICAgdmFyIGEyID0gYVsyXSAvIG1hZ25pdHVkZTtcbiAgICB2YXIgYTMgPSBhWzNdIC8gbWFnbml0dWRlO1xuICAgIHZhciBiMCA9IGFbNF07XG4gICAgdmFyIGIxID0gYVs1XTtcbiAgICB2YXIgYjIgPSBhWzZdO1xuICAgIHZhciBiMyA9IGFbN107XG4gICAgdmFyIGFfZG90X2IgPSBhMCAqIGIwICsgYTEgKiBiMSArIGEyICogYjIgKyBhMyAqIGIzO1xuICAgIG91dFswXSA9IGEwO1xuICAgIG91dFsxXSA9IGExO1xuICAgIG91dFsyXSA9IGEyO1xuICAgIG91dFszXSA9IGEzO1xuICAgIG91dFs0XSA9IChiMCAtIGEwICogYV9kb3RfYikgLyBtYWduaXR1ZGU7XG4gICAgb3V0WzVdID0gKGIxIC0gYTEgKiBhX2RvdF9iKSAvIG1hZ25pdHVkZTtcbiAgICBvdXRbNl0gPSAoYjIgLSBhMiAqIGFfZG90X2IpIC8gbWFnbml0dWRlO1xuICAgIG91dFs3XSA9IChiMyAtIGEzICogYV9kb3RfYikgLyBtYWduaXR1ZGU7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBkdWFsIHF1YXRlbmlvblxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBhIGR1YWwgcXVhdGVybmlvbiB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkdWFsIHF1YXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gJ3F1YXQyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJywgJyArIGFbNF0gKyAnLCAnICsgYVs1XSArICcsICcgKyBhWzZdICsgJywgJyArIGFbN10gKyAnKSc7XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgZHVhbCBxdWF0ZXJuaW9ucyBoYXZlIGV4YWN0bHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IGEgdGhlIGZpcnN0IGR1YWwgcXVhdGVybmlvbi5cclxuICogQHBhcmFtIHtxdWF0Mn0gYiB0aGUgc2Vjb25kIGR1YWwgcXVhdGVybmlvbi5cclxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgdGhlIGR1YWwgcXVhdGVybmlvbnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl0gJiYgYVszXSA9PT0gYlszXSAmJiBhWzRdID09PSBiWzRdICYmIGFbNV0gPT09IGJbNV0gJiYgYVs2XSA9PT0gYls2XSAmJiBhWzddID09PSBiWzddO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGR1YWwgcXVhdGVybmlvbnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3F1YXQyfSBhIHRoZSBmaXJzdCBkdWFsIHF1YXQuXHJcbiAqIEBwYXJhbSB7cXVhdDJ9IGIgdGhlIHNlY29uZCBkdWFsIHF1YXQuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHRoZSBkdWFsIHF1YXRzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhhLCBiKSB7XG4gIHZhciBhMCA9IGFbMF0sXG4gICAgICBhMSA9IGFbMV0sXG4gICAgICBhMiA9IGFbMl0sXG4gICAgICBhMyA9IGFbM10sXG4gICAgICBhNCA9IGFbNF0sXG4gICAgICBhNSA9IGFbNV0sXG4gICAgICBhNiA9IGFbNl0sXG4gICAgICBhNyA9IGFbN107XG4gIHZhciBiMCA9IGJbMF0sXG4gICAgICBiMSA9IGJbMV0sXG4gICAgICBiMiA9IGJbMl0sXG4gICAgICBiMyA9IGJbM10sXG4gICAgICBiNCA9IGJbNF0sXG4gICAgICBiNSA9IGJbNV0sXG4gICAgICBiNiA9IGJbNl0sXG4gICAgICBiNyA9IGJbN107XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGIwKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiYgTWF0aC5hYnMoYTEgLSBiMSkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTEpLCBNYXRoLmFicyhiMSkpICYmIE1hdGguYWJzKGEyIC0gYjIpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSAmJiBNYXRoLmFicyhhMyAtIGIzKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMyksIE1hdGguYWJzKGIzKSkgJiYgTWF0aC5hYnMoYTQgLSBiNCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTQpLCBNYXRoLmFicyhiNCkpICYmIE1hdGguYWJzKGE1IC0gYjUpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGE1KSwgTWF0aC5hYnMoYjUpKSAmJiBNYXRoLmFicyhhNiAtIGI2KSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhNiksIE1hdGguYWJzKGI2KSkgJiYgTWF0aC5hYnMoYTcgLSBiNykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTcpLCBNYXRoLmFicyhiNykpO1xufSIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuLyoqXHJcbiAqIDIgRGltZW5zaW9uYWwgVmVjdG9yXHJcbiAqIEBtb2R1bGUgdmVjMlxyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzJcclxuICpcclxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2xvbmVcclxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDIpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSkge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzIgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4LCB5KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogRGl2aWRlcyB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2VpbFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBmbG9vclxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE1hdGgucm91bmQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gcm91bmRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNjYWxlcyBhIHZlYzIgYnkgYSBzY2FsYXIgbnVtYmVyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gYVswXSAqIGI7XG4gIG91dFsxXSA9IGFbMV0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIHZlYzIncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgIHkgPSBiWzFdIC0gYVsxXTtcbiAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICByZXR1cm4geCAqIHggKyB5ICogeTtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMyXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdO1xuICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdO1xuICByZXR1cm4geCAqIHggKyB5ICogeTtcbn1cbi8qKlxyXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBpbnZlcnRcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTm9ybWFsaXplIGEgdmVjMlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgdmFyIGxlbiA9IHggKiB4ICsgeSAqIHk7XG5cbiAgaWYgKGxlbiA+IDApIHtcbiAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgfVxuXG4gIG91dFswXSA9IGFbMF0gKiBsZW47XG4gIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV07XG59XG4vKipcclxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzInc1xyXG4gKiBOb3RlIHRoYXQgdGhlIGNyb3NzIHByb2R1Y3QgbXVzdCBieSBkZWZpbml0aW9uIHByb2R1Y2UgYSAzRCB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICB2YXIgeiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gIG91dFswXSA9IG91dFsxXSA9IDA7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMyJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIGF4ID0gYVswXSxcbiAgICAgIGF5ID0gYVsxXTtcbiAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiByYW5kb20ob3V0LCBzY2FsZSkge1xuICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcbiAgdmFyIHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gIG91dFswXSA9IE1hdGguY29zKHIpICogc2NhbGU7XG4gIG91dFsxXSA9IE1hdGguc2luKHIpICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHttYXQyfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0MihvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHk7XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MmRcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7bWF0MmR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQyZChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV07XG4gIG91dFswXSA9IG1bMF0gKiB4ICsgbVsyXSAqIHkgKyBtWzRdO1xuICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQzXHJcbiAqIDNyZCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge21hdDN9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXTtcbiAgb3V0WzBdID0gbVswXSAqIHggKyBtWzNdICogeSArIG1bNl07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs0XSAqIHkgKyBtWzddO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDRcclxuICogM3JkIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMCdcclxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzJ9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVsxMl07XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzEzXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGUgYSAyRCB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMyfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMyXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgdmVjMiBwb2ludCB0byByb3RhdGVcclxuICogQHBhcmFtIHt2ZWMyfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxyXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgYiwgYykge1xuICAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gIHZhciBwMCA9IGFbMF0gLSBiWzBdLFxuICAgICAgcDEgPSBhWzFdIC0gYlsxXSxcbiAgICAgIHNpbkMgPSBNYXRoLnNpbihjKSxcbiAgICAgIGNvc0MgPSBNYXRoLmNvcyhjKTsgLy9wZXJmb3JtIHJvdGF0aW9uIGFuZCB0cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuXG4gIG91dFswXSA9IHAwICogY29zQyAtIHAxICogc2luQyArIGJbMF07XG4gIG91dFsxXSA9IHAwICogc2luQyArIHAxICogY29zQyArIGJbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2V0IHRoZSBhbmdsZSBiZXR3ZWVuIHR3byAyRCB2ZWN0b3JzXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICB2YXIgeDEgPSBhWzBdLFxuICAgICAgeTEgPSBhWzFdLFxuICAgICAgeDIgPSBiWzBdLFxuICAgICAgeTIgPSBiWzFdO1xuICB2YXIgbGVuMSA9IHgxICogeDEgKyB5MSAqIHkxO1xuXG4gIGlmIChsZW4xID4gMCkge1xuICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgbGVuMSA9IDEgLyBNYXRoLnNxcnQobGVuMSk7XG4gIH1cblxuICB2YXIgbGVuMiA9IHgyICogeDIgKyB5MiAqIHkyO1xuXG4gIGlmIChsZW4yID4gMCkge1xuICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgbGVuMiA9IDEgLyBNYXRoLnNxcnQobGVuMik7XG4gIH1cblxuICB2YXIgY29zaW5lID0gKHgxICogeDIgKyB5MSAqIHkyKSAqIGxlbjEgKiBsZW4yO1xuXG4gIGlmIChjb3NpbmUgPiAxLjApIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChjb3NpbmUgPCAtMS4wKSB7XG4gICAgcmV0dXJuIE1hdGguUEk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE1hdGguYWNvcyhjb3NpbmUpO1xuICB9XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMiB0byB6ZXJvXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvKG91dCkge1xuICBvdXRbMF0gPSAwLjA7XG4gIG91dFsxXSA9IDAuMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuICd2ZWMyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnKSc7XG59XG4vKipcclxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBleGFjdGx5IGhhdmUgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjMn0gYSBUaGUgZmlyc3QgdmVjdG9yLlxyXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0RXF1YWxzKGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHt2ZWMyfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB7dmVjMn0gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSk7XG59XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmxlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGxlbiA9IGxlbmd0aDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3VidHJhY3R9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzdWIgPSBzdWJ0cmFjdDtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubXVsdGlwbHl9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBtdWwgPSBtdWx0aXBseTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuZGl2aWRlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZGl2ID0gZGl2aWRlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5kaXN0YW5jZX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGRpc3QgPSBkaXN0YW5jZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZERpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgc3FyRGlzdCA9IHNxdWFyZWREaXN0YW5jZTtcbi8qKlxyXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuc3F1YXJlZExlbmd0aH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHNxckxlbiA9IHNxdWFyZWRMZW5ndGg7XG4vKipcclxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzIuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjMnMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gYVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZlYyA9IGNyZWF0ZSgpO1xuICByZXR1cm4gZnVuY3Rpb24gKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgIHZhciBpLCBsO1xuXG4gICAgaWYgKCFzdHJpZGUpIHtcbiAgICAgIHN0cmlkZSA9IDI7XG4gICAgfVxuXG4gICAgaWYgKCFvZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBsID0gTWF0aC5taW4oY291bnQgKiBzdHJpZGUgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbCA9IGEubGVuZ3RoO1xuICAgIH1cblxuICAgIGZvciAoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICB2ZWNbMF0gPSBhW2ldO1xuICAgICAgdmVjWzFdID0gYVtpICsgMV07XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07XG4gICAgICBhW2kgKyAxXSA9IHZlY1sxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0oKTsiLCJpbXBvcnQgKiBhcyBnbE1hdHJpeCBmcm9tIFwiLi9jb21tb24uanNcIjtcbi8qKlxyXG4gKiAzIERpbWVuc2lvbmFsIFZlY3RvclxyXG4gKiBAbW9kdWxlIHZlYzNcclxuICovXG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMzXHJcbiAqXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcblxuICBpZiAoZ2xNYXRyaXguQVJSQVlfVFlQRSAhPSBGbG9hdDMyQXJyYXkpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2xvbmVcclxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcclxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSwgeikge1xuICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzMgdG8gYW5vdGhlclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNvcHkob3V0LCBhKSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQob3V0LCB4LCB5LCB6KSB7XG4gIG91dFswXSA9IHg7XG4gIG91dFsxXSA9IHk7XG4gIG91dFsyXSA9IHo7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQWRkcyB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogRGl2aWRlcyB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXZpZGUob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNlaWxcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNlaWwob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguY2VpbChhWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmNlaWwoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5mbG9vciB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBmbG9vclxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSk7XG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguZmxvb3IoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgbWF4aW11bSBvZiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXgob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byByb3VuZFxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGgucm91bmQoYVsyXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIGEgdmVjMyBieSBhIHNjYWxhciBudW1iZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIHZlYzMncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgb3V0WzBdID0gYVswXSArIGJbMF0gKiBzY2FsZTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV0gKiBzY2FsZTtcbiAgb3V0WzJdID0gYVsyXSArIGJbMl0gKiBzY2FsZTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlKGEsIGIpIHtcbiAgdmFyIHggPSBiWzBdIC0gYVswXTtcbiAgdmFyIHkgPSBiWzFdIC0gYVsxXTtcbiAgdmFyIHogPSBiWzJdIC0gYVsyXTtcbiAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHJldHVybiB4ICogeCArIHkgKiB5ICsgeiAqIHo7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogejtcbn1cbi8qKlxyXG4gKiBOZWdhdGVzIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIG5lZ2F0ZVxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICBvdXRbMF0gPSAtYVswXTtcbiAgb3V0WzFdID0gLWFbMV07XG4gIG91dFsyXSA9IC1hWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gaW52ZXJ0XHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnNlKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdO1xuICBvdXRbMV0gPSAxLjAgLyBhWzFdO1xuICBvdXRbMl0gPSAxLjAgLyBhWzJdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE5vcm1hbGl6ZSBhIHZlYzNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBub3JtYWxpemVcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgdmFyIGxlbiA9IHggKiB4ICsgeSAqIHkgKyB6ICogejtcblxuICBpZiAobGVuID4gMCkge1xuICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICB9XG5cbiAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgb3V0WzJdID0gYVsyXSAqIGxlbjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkb3QoYSwgYikge1xuICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdO1xufVxuLyoqXHJcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyb3NzKG91dCwgYSwgYikge1xuICB2YXIgYXggPSBhWzBdLFxuICAgICAgYXkgPSBhWzFdLFxuICAgICAgYXogPSBhWzJdO1xuICB2YXIgYnggPSBiWzBdLFxuICAgICAgYnkgPSBiWzFdLFxuICAgICAgYnogPSBiWzJdO1xuICBvdXRbMF0gPSBheSAqIGJ6IC0gYXogKiBieTtcbiAgb3V0WzFdID0gYXogKiBieCAtIGF4ICogYno7XG4gIG91dFsyXSA9IGF4ICogYnkgLSBheSAqIGJ4O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50LCBpbiB0aGUgcmFuZ2UgWzAtMV0sIGJldHdlZW4gdGhlIHR3byBpbnB1dHNcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxlcnAob3V0LCBhLCBiLCB0KSB7XG4gIHZhciBheCA9IGFbMF07XG4gIHZhciBheSA9IGFbMV07XG4gIHZhciBheiA9IGFbMl07XG4gIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUGVyZm9ybXMgYSBoZXJtaXRlIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMzfSBjIHRoZSB0aGlyZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjM30gZCB0aGUgZm91cnRoIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gaGVybWl0ZShvdXQsIGEsIGIsIGMsIGQsIHQpIHtcbiAgdmFyIGZhY3RvclRpbWVzMiA9IHQgKiB0O1xuICB2YXIgZmFjdG9yMSA9IGZhY3RvclRpbWVzMiAqICgyICogdCAtIDMpICsgMTtcbiAgdmFyIGZhY3RvcjIgPSBmYWN0b3JUaW1lczIgKiAodCAtIDIpICsgdDtcbiAgdmFyIGZhY3RvcjMgPSBmYWN0b3JUaW1lczIgKiAodCAtIDEpO1xuICB2YXIgZmFjdG9yNCA9IGZhY3RvclRpbWVzMiAqICgzIC0gMiAqIHQpO1xuICBvdXRbMF0gPSBhWzBdICogZmFjdG9yMSArIGJbMF0gKiBmYWN0b3IyICsgY1swXSAqIGZhY3RvcjMgKyBkWzBdICogZmFjdG9yNDtcbiAgb3V0WzFdID0gYVsxXSAqIGZhY3RvcjEgKyBiWzFdICogZmFjdG9yMiArIGNbMV0gKiBmYWN0b3IzICsgZFsxXSAqIGZhY3RvcjQ7XG4gIG91dFsyXSA9IGFbMl0gKiBmYWN0b3IxICsgYlsyXSAqIGZhY3RvcjIgKyBjWzJdICogZmFjdG9yMyArIGRbMl0gKiBmYWN0b3I0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFBlcmZvcm1zIGEgYmV6aWVyIGludGVycG9sYXRpb24gd2l0aCB0d28gY29udHJvbCBwb2ludHNcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWMzfSBjIHRoZSB0aGlyZCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjM30gZCB0aGUgZm91cnRoIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYmV6aWVyKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICB2YXIgaW52ZXJzZUZhY3RvciA9IDEgLSB0O1xuICB2YXIgaW52ZXJzZUZhY3RvclRpbWVzVHdvID0gaW52ZXJzZUZhY3RvciAqIGludmVyc2VGYWN0b3I7XG4gIHZhciBmYWN0b3JUaW1lczIgPSB0ICogdDtcbiAgdmFyIGZhY3RvcjEgPSBpbnZlcnNlRmFjdG9yVGltZXNUd28gKiBpbnZlcnNlRmFjdG9yO1xuICB2YXIgZmFjdG9yMiA9IDMgKiB0ICogaW52ZXJzZUZhY3RvclRpbWVzVHdvO1xuICB2YXIgZmFjdG9yMyA9IDMgKiBmYWN0b3JUaW1lczIgKiBpbnZlcnNlRmFjdG9yO1xuICB2YXIgZmFjdG9yNCA9IGZhY3RvclRpbWVzMiAqIHQ7XG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuICB2YXIgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgdmFyIHogPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAtIDEuMDtcbiAgdmFyIHpTY2FsZSA9IE1hdGguc3FydCgxLjAgLSB6ICogeikgKiBzY2FsZTtcbiAgb3V0WzBdID0gTWF0aC5jb3MocikgKiB6U2NhbGU7XG4gIG91dFsxXSA9IE1hdGguc2luKHIpICogelNjYWxlO1xuICBvdXRbMl0gPSB6ICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cclxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXHJcbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl07XG4gIHZhciB3ID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdO1xuICB3ID0gdyB8fCAxLjA7XG4gIG91dFswXSA9IChtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSkgLyB3O1xuICBvdXRbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10pIC8gdztcbiAgb3V0WzJdID0gKG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSkgLyB3O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzMgd2l0aCBhIG1hdDMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge21hdDN9IG0gdGhlIDN4MyBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDMob3V0LCBhLCBtKSB7XG4gIHZhciB4ID0gYVswXSxcbiAgICAgIHkgPSBhWzFdLFxuICAgICAgeiA9IGFbMl07XG4gIG91dFswXSA9IHggKiBtWzBdICsgeSAqIG1bM10gKyB6ICogbVs2XTtcbiAgb3V0WzFdID0geCAqIG1bMV0gKyB5ICogbVs0XSArIHogKiBtWzddO1xuICBvdXRbMl0gPSB4ICogbVsyXSArIHkgKiBtWzVdICsgeiAqIG1bOF07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgcXVhdFxyXG4gKiBDYW4gYWxzbyBiZSB1c2VkIGZvciBkdWFsIHF1YXRlcm5pb25zLiAoTXVsdGlwbHkgaXQgd2l0aCB0aGUgcmVhbCBwYXJ0KVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHtxdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcclxuICogQHJldHVybnMge3ZlYzN9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQob3V0LCBhLCBxKSB7XG4gIC8vIGJlbmNobWFya3M6IGh0dHBzOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9ucy1maXhlZFxuICB2YXIgcXggPSBxWzBdLFxuICAgICAgcXkgPSBxWzFdLFxuICAgICAgcXogPSBxWzJdLFxuICAgICAgcXcgPSBxWzNdO1xuICB2YXIgeCA9IGFbMF0sXG4gICAgICB5ID0gYVsxXSxcbiAgICAgIHogPSBhWzJdOyAvLyB2YXIgcXZlYyA9IFtxeCwgcXksIHF6XTtcbiAgLy8gdmFyIHV2ID0gdmVjMy5jcm9zcyhbXSwgcXZlYywgYSk7XG5cbiAgdmFyIHV2eCA9IHF5ICogeiAtIHF6ICogeSxcbiAgICAgIHV2eSA9IHF6ICogeCAtIHF4ICogeixcbiAgICAgIHV2eiA9IHF4ICogeSAtIHF5ICogeDsgLy8gdmFyIHV1diA9IHZlYzMuY3Jvc3MoW10sIHF2ZWMsIHV2KTtcblxuICB2YXIgdXV2eCA9IHF5ICogdXZ6IC0gcXogKiB1dnksXG4gICAgICB1dXZ5ID0gcXogKiB1dnggLSBxeCAqIHV2eixcbiAgICAgIHV1dnogPSBxeCAqIHV2eSAtIHF5ICogdXZ4OyAvLyB2ZWMzLnNjYWxlKHV2LCB1diwgMiAqIHcpO1xuXG4gIHZhciB3MiA9IHF3ICogMjtcbiAgdXZ4ICo9IHcyO1xuICB1dnkgKj0gdzI7XG4gIHV2eiAqPSB3MjsgLy8gdmVjMy5zY2FsZSh1dXYsIHV1diwgMik7XG5cbiAgdXV2eCAqPSAyO1xuICB1dXZ5ICo9IDI7XG4gIHV1dnogKj0gMjsgLy8gcmV0dXJuIHZlYzMuYWRkKG91dCwgYSwgdmVjMy5hZGQob3V0LCB1diwgdXV2KSk7XG5cbiAgb3V0WzBdID0geCArIHV2eCArIHV1dng7XG4gIG91dFsxXSA9IHkgKyB1dnkgKyB1dXZ5O1xuICBvdXRbMl0gPSB6ICsgdXZ6ICsgdXV2ejtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXHJcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcclxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIGIsIGMpIHtcbiAgdmFyIHAgPSBbXSxcbiAgICAgIHIgPSBbXTsgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXG4gIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBwWzJdID0gYVsyXSAtIGJbMl07IC8vcGVyZm9ybSByb3RhdGlvblxuXG4gIHJbMF0gPSBwWzBdO1xuICByWzFdID0gcFsxXSAqIE1hdGguY29zKGMpIC0gcFsyXSAqIE1hdGguc2luKGMpO1xuICByWzJdID0gcFsxXSAqIE1hdGguc2luKGMpICsgcFsyXSAqIE1hdGguY29zKGMpOyAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB5LWF4aXNcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXHJcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcclxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIGIsIGMpIHtcbiAgdmFyIHAgPSBbXSxcbiAgICAgIHIgPSBbXTsgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXG4gIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBwWzJdID0gYVsyXSAtIGJbMl07IC8vcGVyZm9ybSByb3RhdGlvblxuXG4gIHJbMF0gPSBwWzJdICogTWF0aC5zaW4oYykgKyBwWzBdICogTWF0aC5jb3MoYyk7XG4gIHJbMV0gPSBwWzFdO1xuICByWzJdID0gcFsyXSAqIE1hdGguY29zKGMpIC0gcFswXSAqIE1hdGguc2luKGMpOyAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB6LWF4aXNcclxuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXHJcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcclxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxyXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIGIsIGMpIHtcbiAgdmFyIHAgPSBbXSxcbiAgICAgIHIgPSBbXTsgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXG4gIHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgcFsxXSA9IGFbMV0gLSBiWzFdO1xuICBwWzJdID0gYVsyXSAtIGJbMl07IC8vcGVyZm9ybSByb3RhdGlvblxuXG4gIHJbMF0gPSBwWzBdICogTWF0aC5jb3MoYykgLSBwWzFdICogTWF0aC5zaW4oYyk7XG4gIHJbMV0gPSBwWzBdICogTWF0aC5zaW4oYykgKyBwWzFdICogTWF0aC5jb3MoYyk7XG4gIHJbMl0gPSBwWzJdOyAvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG5cbiAgb3V0WzBdID0gclswXSArIGJbMF07XG4gIG91dFsxXSA9IHJbMV0gKyBiWzFdO1xuICBvdXRbMl0gPSByWzJdICsgYlsyXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBHZXQgdGhlIGFuZ2xlIGJldHdlZW4gdHdvIDNEIHZlY3RvcnNcclxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge051bWJlcn0gVGhlIGFuZ2xlIGluIHJhZGlhbnNcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gIHZhciB0ZW1wQSA9IGZyb21WYWx1ZXMoYVswXSwgYVsxXSwgYVsyXSk7XG4gIHZhciB0ZW1wQiA9IGZyb21WYWx1ZXMoYlswXSwgYlsxXSwgYlsyXSk7XG4gIG5vcm1hbGl6ZSh0ZW1wQSwgdGVtcEEpO1xuICBub3JtYWxpemUodGVtcEIsIHRlbXBCKTtcbiAgdmFyIGNvc2luZSA9IGRvdCh0ZW1wQSwgdGVtcEIpO1xuXG4gIGlmIChjb3NpbmUgPiAxLjApIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChjb3NpbmUgPCAtMS4wKSB7XG4gICAgcmV0dXJuIE1hdGguUEk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIE1hdGguYWNvcyhjb3NpbmUpO1xuICB9XG59XG4vKipcclxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB6ZXJvXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvKG91dCkge1xuICBvdXRbMF0gPSAwLjA7XG4gIG91dFsxXSA9IDAuMDtcbiAgb3V0WzJdID0gMC4wO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcclxuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoYSkge1xuICByZXR1cm4gJ3ZlYzMoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJyknO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXTtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cclxuICpcclxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXHJcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWYgdGhlIHZlY3RvcnMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXSxcbiAgICAgIGExID0gYVsxXSxcbiAgICAgIGEyID0gYVsyXTtcbiAgdmFyIGIwID0gYlswXSxcbiAgICAgIGIxID0gYlsxXSxcbiAgICAgIGIyID0gYlsyXTtcbiAgcmV0dXJuIE1hdGguYWJzKGEwIC0gYjApIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJiBNYXRoLmFicyhhMSAtIGIxKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiYgTWF0aC5hYnMoYTIgLSBiMikgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTIpLCBNYXRoLmFicyhiMikpO1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zdWJ0cmFjdH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHN1YiA9IHN1YnRyYWN0O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5kaXZpZGV9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBkaXYgPSBkaXZpZGU7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZGlzdCA9IGRpc3RhbmNlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkRGlzdGFuY2V9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzcXJEaXN0ID0gc3F1YXJlZERpc3RhbmNlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5sZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBsZW4gPSBsZW5ndGg7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnNxdWFyZWRMZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMzcy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMzLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcclxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzNzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZWMgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbDtcblxuICAgIGlmICghc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSAzO1xuICAgIH1cblxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmIChjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKGNvdW50ICogc3RyaWRlICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTtcbiAgICAgIHZlY1sxXSA9IGFbaSArIDFdO1xuICAgICAgdmVjWzJdID0gYVtpICsgMl07XG4gICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgIGFbaV0gPSB2ZWNbMF07XG4gICAgICBhW2kgKyAxXSA9IHZlY1sxXTtcbiAgICAgIGFbaSArIDJdID0gdmVjWzJdO1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9O1xufSgpOyIsImltcG9ydCAqIGFzIGdsTWF0cml4IGZyb20gXCIuL2NvbW1vbi5qc1wiO1xuLyoqXHJcbiAqIDQgRGltZW5zaW9uYWwgVmVjdG9yXHJcbiAqIEBtb2R1bGUgdmVjNFxyXG4gKi9cblxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzRcclxuICpcclxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuXG4gIGlmIChnbE1hdHJpeC5BUlJBWV9UWVBFICE9IEZsb2F0MzJBcnJheSkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNsb25lXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShhKSB7XG4gIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgb3V0WzBdID0gYVswXTtcbiAgb3V0WzFdID0gYVsxXTtcbiAgb3V0WzJdID0gYVsyXTtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzQgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVmFsdWVzKHgsIHksIHosIHcpIHtcbiAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICBvdXRbM10gPSB3O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWM0IHRvIGFub3RoZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBzb3VyY2UgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzQgdG8gdGhlIGdpdmVuIHZhbHVlc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0KG91dCwgeCwgeSwgeiwgdykge1xuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICBvdXRbMl0gPSB6O1xuICBvdXRbM10gPSB3O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIEFkZHMgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gIG91dFszXSA9IGFbM10gKiBiWzNdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIERpdmlkZXMgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gIG91dFsyXSA9IGFbMl0gLyBiWzJdO1xuICBvdXRbM10gPSBhWzNdIC8gYlszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2VpbFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmNlaWwoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGguY2VpbChhWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5jZWlsKGFbM10pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gZmxvb3JcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pO1xuICBvdXRbMV0gPSBNYXRoLmZsb29yKGFbMV0pO1xuICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pO1xuICBvdXRbM10gPSBNYXRoLmZsb29yKGFbM10pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbWluKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5taW4oYVsxXSwgYlsxXSk7XG4gIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICBvdXRbM10gPSBNYXRoLm1pbihhWzNdLCBiWzNdKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pO1xuICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgb3V0WzNdID0gTWF0aC5tYXgoYVszXSwgYlszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byByb3VuZFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gcm91bmQob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGgucm91bmQoYVswXSk7XG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSk7XG4gIG91dFsyXSA9IE1hdGgucm91bmQoYVsyXSk7XG4gIG91dFszXSA9IE1hdGgucm91bmQoYVszXSk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogU2NhbGVzIGEgdmVjNCBieSBhIHNjYWxhciBudW1iZXJcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcclxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgYikge1xuICBvdXRbMF0gPSBhWzBdICogYjtcbiAgb3V0WzFdID0gYVsxXSAqIGI7XG4gIG91dFsyXSA9IGFbMl0gKiBiO1xuICBvdXRbM10gPSBhWzNdICogYjtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBBZGRzIHR3byB2ZWM0J3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2FsZUFuZEFkZChvdXQsIGEsIGIsIHNjYWxlKSB7XG4gIG91dFswXSA9IGFbMF0gKyBiWzBdICogc2NhbGU7XG4gIG91dFsxXSA9IGFbMV0gKyBiWzFdICogc2NhbGU7XG4gIG91dFsyXSA9IGFbMl0gKyBiWzJdICogc2NhbGU7XG4gIG91dFszXSA9IGFbM10gKyBiWzNdICogc2NhbGU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHZhciB3ID0gYlszXSAtIGFbM107XG4gIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHcpO1xufVxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHNxdWFyZWREaXN0YW5jZShhLCBiKSB7XG4gIHZhciB4ID0gYlswXSAtIGFbMF07XG4gIHZhciB5ID0gYlsxXSAtIGFbMV07XG4gIHZhciB6ID0gYlsyXSAtIGFbMl07XG4gIHZhciB3ID0gYlszXSAtIGFbM107XG4gIHJldHVybiB4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdztcbn1cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGxlbmd0aChhKSB7XG4gIHZhciB4ID0gYVswXTtcbiAgdmFyIHkgPSBhWzFdO1xuICB2YXIgeiA9IGFbMl07XG4gIHZhciB3ID0gYVszXTtcbiAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdyk7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWM0XHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgdmFyIHggPSBhWzBdO1xuICB2YXIgeSA9IGFbMV07XG4gIHZhciB6ID0gYVsyXTtcbiAgdmFyIHcgPSBhWzNdO1xuICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHc7XG59XG4vKipcclxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBuZWdhdGVcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gLWFbMF07XG4gIG91dFsxXSA9IC1hWzFdO1xuICBvdXRbMl0gPSAtYVsyXTtcbiAgb3V0WzNdID0gLWFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBpbnZlcnRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGludmVyc2Uob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIG91dFsyXSA9IDEuMCAvIGFbMl07XG4gIG91dFszXSA9IDEuMCAvIGFbM107XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogTm9ybWFsaXplIGEgdmVjNFxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKG91dCwgYSkge1xuICB2YXIgeCA9IGFbMF07XG4gIHZhciB5ID0gYVsxXTtcbiAgdmFyIHogPSBhWzJdO1xuICB2YXIgdyA9IGFbM107XG4gIHZhciBsZW4gPSB4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdztcblxuICBpZiAobGVuID4gMCkge1xuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgfVxuXG4gIG91dFswXSA9IHggKiBsZW47XG4gIG91dFsxXSA9IHkgKiBsZW47XG4gIG91dFsyXSA9IHogKiBsZW47XG4gIG91dFszXSA9IHcgKiBsZW47XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzQnc1xyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcclxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZG90KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXSArIGFbM10gKiBiWzNdO1xufVxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGNyb3NzLXByb2R1Y3Qgb2YgdGhyZWUgdmVjdG9ycyBpbiBhIDQtZGltZW5zaW9uYWwgc3BhY2VcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSByZXN1bHQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWM0fSBVIHRoZSBmaXJzdCB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWM0fSBWIHRoZSBzZWNvbmQgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjNH0gVyB0aGUgdGhpcmQgdmVjdG9yXHJcbiAqIEByZXR1cm5zIHt2ZWM0fSByZXN1bHRcclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBjcm9zcyhvdXQsIHUsIHYsIHcpIHtcbiAgdmFyIEEgPSB2WzBdICogd1sxXSAtIHZbMV0gKiB3WzBdLFxuICAgICAgQiA9IHZbMF0gKiB3WzJdIC0gdlsyXSAqIHdbMF0sXG4gICAgICBDID0gdlswXSAqIHdbM10gLSB2WzNdICogd1swXSxcbiAgICAgIEQgPSB2WzFdICogd1syXSAtIHZbMl0gKiB3WzFdLFxuICAgICAgRSA9IHZbMV0gKiB3WzNdIC0gdlszXSAqIHdbMV0sXG4gICAgICBGID0gdlsyXSAqIHdbM10gLSB2WzNdICogd1syXTtcbiAgdmFyIEcgPSB1WzBdO1xuICB2YXIgSCA9IHVbMV07XG4gIHZhciBJID0gdVsyXTtcbiAgdmFyIEogPSB1WzNdO1xuICBvdXRbMF0gPSBIICogRiAtIEkgKiBFICsgSiAqIEQ7XG4gIG91dFsxXSA9IC0oRyAqIEYpICsgSSAqIEMgLSBKICogQjtcbiAgb3V0WzJdID0gRyAqIEUgLSBIICogQyArIEogKiBBO1xuICBvdXRbM10gPSAtKEcgKiBEKSArIEggKiBCIC0gSSAqIEE7XG4gIHJldHVybiBvdXQ7XG59XG47XG4vKipcclxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWM0J3NcclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXHJcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcclxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQsIGluIHRoZSByYW5nZSBbMC0xXSwgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgdmFyIGF4ID0gYVswXTtcbiAgdmFyIGF5ID0gYVsxXTtcbiAgdmFyIGF6ID0gYVsyXTtcbiAgdmFyIGF3ID0gYVszXTtcbiAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgb3V0WzNdID0gYXcgKyB0ICogKGJbM10gLSBhdyk7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcclxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gIHNjYWxlID0gc2NhbGUgfHwgMS4wOyAvLyBNYXJzYWdsaWEsIEdlb3JnZS4gQ2hvb3NpbmcgYSBQb2ludCBmcm9tIHRoZSBTdXJmYWNlIG9mIGFcbiAgLy8gU3BoZXJlLiBBbm4uIE1hdGguIFN0YXRpc3QuIDQzICgxOTcyKSwgbm8uIDIsIDY0NS0tNjQ2LlxuICAvLyBodHRwOi8vcHJvamVjdGV1Y2xpZC5vcmcvZXVjbGlkLmFvbXMvMTE3NzY5MjY0NDtcblxuICB2YXIgdjEsIHYyLCB2MywgdjQ7XG4gIHZhciBzMSwgczI7XG5cbiAgZG8ge1xuICAgIHYxID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyIC0gMTtcbiAgICB2MiA9IGdsTWF0cml4LlJBTkRPTSgpICogMiAtIDE7XG4gICAgczEgPSB2MSAqIHYxICsgdjIgKiB2MjtcbiAgfSB3aGlsZSAoczEgPj0gMSk7XG5cbiAgZG8ge1xuICAgIHYzID0gZ2xNYXRyaXguUkFORE9NKCkgKiAyIC0gMTtcbiAgICB2NCA9IGdsTWF0cml4LlJBTkRPTSgpICogMiAtIDE7XG4gICAgczIgPSB2MyAqIHYzICsgdjQgKiB2NDtcbiAgfSB3aGlsZSAoczIgPj0gMSk7XG5cbiAgdmFyIGQgPSBNYXRoLnNxcnQoKDEgLSBzMSkgLyBzMik7XG4gIG91dFswXSA9IHNjYWxlICogdjE7XG4gIG91dFsxXSA9IHNjYWxlICogdjI7XG4gIG91dFsyXSA9IHNjYWxlICogdjMgKiBkO1xuICBvdXRbM10gPSBzY2FsZSAqIHY0ICogZDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWM0IHdpdGggYSBtYXQ0LlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cclxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtTWF0NChvdXQsIGEsIG0pIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXSxcbiAgICAgIHcgPSBhWzNdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXSAqIHc7XG4gIG91dFsxXSA9IG1bMV0gKiB4ICsgbVs1XSAqIHkgKyBtWzldICogeiArIG1bMTNdICogdztcbiAgb3V0WzJdID0gbVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdICogdztcbiAgb3V0WzNdID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdICogdztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWM0IHdpdGggYSBxdWF0XHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXHJcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxyXG4gKiBAcGFyYW0ge3F1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxyXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtUXVhdChvdXQsIGEsIHEpIHtcbiAgdmFyIHggPSBhWzBdLFxuICAgICAgeSA9IGFbMV0sXG4gICAgICB6ID0gYVsyXTtcbiAgdmFyIHF4ID0gcVswXSxcbiAgICAgIHF5ID0gcVsxXSxcbiAgICAgIHF6ID0gcVsyXSxcbiAgICAgIHF3ID0gcVszXTsgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcblxuICB2YXIgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XG4gIHZhciBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogejtcbiAgdmFyIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4O1xuICB2YXIgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6OyAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG5cbiAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeTtcbiAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgb3V0WzJdID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcbiAgb3V0WzNdID0gYVszXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0IHRvIHplcm9cclxuICpcclxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcclxuICogQHJldHVybnMge3ZlYzR9IG91dFxyXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHplcm8ob3V0KSB7XG4gIG91dFswXSA9IDAuMDtcbiAgb3V0WzFdID0gMC4wO1xuICBvdXRbMl0gPSAwLjA7XG4gIG91dFszXSA9IDAuMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxyXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgdmVjdG9yXHJcbiAqXHJcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXHJcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gc3RyKGEpIHtcbiAgcmV0dXJuICd2ZWM0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBleGFjdGx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uICh3aGVuIGNvbXBhcmVkIHdpdGggPT09KVxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHt2ZWM0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXSAmJiBhWzNdID09PSBiWzNdO1xufVxuLyoqXHJcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHZlY3RvcnMgaGF2ZSBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGVsZW1lbnRzIGluIHRoZSBzYW1lIHBvc2l0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3ZlYzR9IGEgVGhlIGZpcnN0IHZlY3Rvci5cclxuICogQHBhcmFtIHt2ZWM0fSBiIFRoZSBzZWNvbmQgdmVjdG9yLlxyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cclxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdLFxuICAgICAgYTEgPSBhWzFdLFxuICAgICAgYTIgPSBhWzJdLFxuICAgICAgYTMgPSBhWzNdO1xuICB2YXIgYjAgPSBiWzBdLFxuICAgICAgYjEgPSBiWzFdLFxuICAgICAgYjIgPSBiWzJdLFxuICAgICAgYjMgPSBiWzNdO1xuICByZXR1cm4gTWF0aC5hYnMoYTAgLSBiMCkgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTApLCBNYXRoLmFicyhiMCkpICYmIE1hdGguYWJzKGExIC0gYjEpIDw9IGdsTWF0cml4LkVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJiBNYXRoLmFicyhhMiAtIGIyKSA8PSBnbE1hdHJpeC5FUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkgJiYgTWF0aC5hYnMoYTMgLSBiMykgPD0gZ2xNYXRyaXguRVBTSUxPTiAqIE1hdGgubWF4KDEuMCwgTWF0aC5hYnMoYTMpLCBNYXRoLmFicyhiMykpO1xufVxuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zdWJ0cmFjdH1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIHN1YiA9IHN1YnRyYWN0O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5tdWx0aXBseX1cclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIG11bCA9IG11bHRpcGx5O1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXZpZGV9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBkaXYgPSBkaXZpZGU7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpc3RhbmNlfVxyXG4gKiBAZnVuY3Rpb25cclxuICovXG5cbmV4cG9ydCB2YXIgZGlzdCA9IGRpc3RhbmNlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zcXVhcmVkRGlzdGFuY2V9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzcXJEaXN0ID0gc3F1YXJlZERpc3RhbmNlO1xuLyoqXHJcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5sZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBsZW4gPSBsZW5ndGg7XG4vKipcclxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnNxdWFyZWRMZW5ndGh9XHJcbiAqIEBmdW5jdGlvblxyXG4gKi9cblxuZXhwb3J0IHZhciBzcXJMZW4gPSBzcXVhcmVkTGVuZ3RoO1xuLyoqXHJcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWM0cy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWM0LiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcclxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxyXG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzRzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcclxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxyXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcclxuICogQGZ1bmN0aW9uXHJcbiAqL1xuXG5leHBvcnQgdmFyIGZvckVhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2ZWMgPSBjcmVhdGUoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICB2YXIgaSwgbDtcblxuICAgIGlmICghc3RyaWRlKSB7XG4gICAgICBzdHJpZGUgPSA0O1xuICAgIH1cblxuICAgIGlmICghb2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSAwO1xuICAgIH1cblxuICAgIGlmIChjb3VudCkge1xuICAgICAgbCA9IE1hdGgubWluKGNvdW50ICogc3RyaWRlICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgdmVjWzBdID0gYVtpXTtcbiAgICAgIHZlY1sxXSA9IGFbaSArIDFdO1xuICAgICAgdmVjWzJdID0gYVtpICsgMl07XG4gICAgICB2ZWNbM10gPSBhW2kgKyAzXTtcbiAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgYVtpXSA9IHZlY1swXTtcbiAgICAgIGFbaSArIDFdID0gdmVjWzFdO1xuICAgICAgYVtpICsgMl0gPSB2ZWNbMl07XG4gICAgICBhW2kgKyAzXSA9IHZlY1szXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcbn0oKTsiLCJpbXBvcnQge1xuICBkaXNwbGF5LFxuICB3ZWJGUyxcbiAgZnJhbWUsXG4gIFdsQ29tcG9zaXRvclByb3h5LFxuICBHcldlYkdsUHJveHksXG4gIFdsU2hlbGxQcm94eSxcbiAgV2xTZWF0UHJveHksXG4gIFdsUG9pbnRlclByb3h5XG59IGZyb20gJ3dlc3RmaWVsZC1ydW50aW1lLWNsaWVudCdcblxuaW1wb3J0IHsgaW5pdERyYXcsIGRyYXdTY2VuZSB9IGZyb20gJy4vd2ViZ2wtZGVtbydcblxuLyoqXG4gKiBAaW1wbGVtZW50cyBHcldlYkdMQnVmZmVyRXZlbnRzXG4gKiBAaW1wbGVtZW50cyBXbEJ1ZmZlckV2ZW50c1xuICovXG5jbGFzcyBHTEJ1ZmZlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0dyV2ViR2xQcm94eX13ZWJHTFxuICAgKiBAcGFyYW0ge09mZnNjcmVlbkNhbnZhc31vZmZzY3JlZW5DYW52YXNcbiAgICogQHBhcmFtIHtHTEJ1ZmZlclBvb2x9Z2xCdWZmZXJQb29sXG4gICAqIEByZXR1cm4ge0dMQnVmZmVyfVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZSAod2ViR0wsIG9mZnNjcmVlbkNhbnZhcykge1xuICAgIGNvbnN0IHByb3h5ID0gd2ViR0wuY3JlYXRlV2ViR2xCdWZmZXIoKVxuICAgIGNvbnN0IGJ1ZmZlclByb3h5ID0gd2ViR0wuY3JlYXRlQnVmZmVyKHByb3h5KVxuXG4gICAgY29uc3QgZ2xCdWZmZXIgPSBuZXcgR0xCdWZmZXIocHJveHksIGJ1ZmZlclByb3h5LCBvZmZzY3JlZW5DYW52YXMpXG5cbiAgICBwcm94eS5saXN0ZW5lciA9IGdsQnVmZmVyXG4gICAgYnVmZmVyUHJveHkubGlzdGVuZXIgPSBnbEJ1ZmZlclxuXG4gICAgcmV0dXJuIGdsQnVmZmVyXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtHcldlYkdMQnVmZmVyUHJveHl9cHJveHlcbiAgICogQHBhcmFtIHtXbEJ1ZmZlclByb3h5fWJ1ZmZlclByb3h5XG4gICAqIEBwYXJhbSB7T2Zmc2NyZWVuQ2FudmFzfW9mZnNjcmVlbkNhbnZhc1xuICAgKi9cbiAgY29uc3RydWN0b3IgKHByb3h5LCBidWZmZXJQcm94eSwgb2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0dyV2ViR0xCdWZmZXJQcm94eX1cbiAgICAgKi9cbiAgICB0aGlzLnByb3h5ID0gcHJveHlcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7V2xCdWZmZXJQcm94eX1cbiAgICAgKi9cbiAgICB0aGlzLmJ1ZmZlclByb3h5ID0gYnVmZmVyUHJveHlcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2Zmc2NyZWVuQ2FudmFzfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fb2Zmc2NyZWVuQ2FudmFzID0gb2Zmc2NyZWVuQ2FudmFzXG4gIH1cblxuICB0cmFuc2ZlciAoKSB7XG4gICAgdGhpcy5wcm94eS50cmFuc2Zlcih3ZWJGUy5mcm9tSW1hZ2VCaXRtYXAodGhpcy5fb2Zmc2NyZWVuQ2FudmFzLnRyYW5zZmVyVG9JbWFnZUJpdG1hcCgpKSlcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiAgU2VudCB3aGVuIHRoaXMgd2xfYnVmZmVyIGlzIG5vIGxvbmdlciB1c2VkIGJ5IHRoZSBjb21wb3NpdG9yLlxuICAgKiAgVGhlIGNsaWVudCBpcyBub3cgZnJlZSB0byByZXVzZSBvciBkZXN0cm95IHRoaXMgYnVmZmVyIGFuZCBpdHNcbiAgICogIGJhY2tpbmcgc3RvcmFnZS5cbiAgICpcbiAgICogIElmIGEgY2xpZW50IHJlY2VpdmVzIGEgcmVsZWFzZSBldmVudCBiZWZvcmUgdGhlIGZyYW1lIGNhbGxiYWNrXG4gICAqICByZXF1ZXN0ZWQgaW4gdGhlIHNhbWUgd2xfc3VyZmFjZS5jb21taXQgdGhhdCBhdHRhY2hlcyB0aGlzXG4gICAqICB3bF9idWZmZXIgdG8gYSBzdXJmYWNlLCB0aGVuIHRoZSBjbGllbnQgaXMgaW1tZWRpYXRlbHkgZnJlZSB0b1xuICAgKiAgcmV1c2UgdGhlIGJ1ZmZlciBhbmQgaXRzIGJhY2tpbmcgc3RvcmFnZSwgYW5kIGRvZXMgbm90IG5lZWQgYVxuICAgKiAgc2Vjb25kIGJ1ZmZlciBmb3IgdGhlIG5leHQgc3VyZmFjZSBjb250ZW50IHVwZGF0ZS4gVHlwaWNhbGx5XG4gICAqICB0aGlzIGlzIHBvc3NpYmxlLCB3aGVuIHRoZSBjb21wb3NpdG9yIG1haW50YWlucyBhIGNvcHkgb2YgdGhlXG4gICAqICB3bF9zdXJmYWNlIGNvbnRlbnRzLCBlLmcuIGFzIGEgR0wgdGV4dHVyZS4gVGhpcyBpcyBhbiBpbXBvcnRhbnRcbiAgICogIG9wdGltaXphdGlvbiBmb3IgR0woRVMpIGNvbXBvc2l0b3JzIHdpdGggd2xfc2htIGNsaWVudHMuXG4gICAqXG4gICAqXG4gICAqXG4gICAqIEBzaW5jZSAxXG4gICAqXG4gICAqL1xuICByZWxlYXNlICgpIHsgLyogTk9PUCAqLyB9XG59XG5cbi8qKlxuICogQGltcGxlbWVudHMgV2xSZWdpc3RyeUV2ZW50c1xuICogQGltcGxlbWVudHMgV2xTaGVsbFN1cmZhY2VFdmVudHNcbiAqIEBpbXBsZW1lbnRzIFdsU2VhdEV2ZW50c1xuICogQGltcGxlbWVudHMgV2xQb2ludGVyRXZlbnRzXG4gKi9cbmNsYXNzIFdpbmRvdyB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn13aWR0aFxuICAgKiBAcGFyYW0ge251bWJlcn1oZWlnaHRcbiAgICogQHJldHVybiB7V2luZG93fVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZSAod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHJlZ2lzdHJ5ID0gZGlzcGxheS5nZXRSZWdpc3RyeSgpXG4gICAgY29uc3Qgb2Zmc2NyZWVuQ2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KVxuICAgIGNvbnN0IGdsID0gLyoqIEB0eXBlIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9ICovb2Zmc2NyZWVuQ2FudmFzLmdldENvbnRleHQoJ3dlYmdsJylcbiAgICBjb25zdCB3aW5kb3cgPSBuZXcgV2luZG93KHJlZ2lzdHJ5LCBvZmZzY3JlZW5DYW52YXMsIGdsKVxuICAgIHJlZ2lzdHJ5Lmxpc3RlbmVyID0gd2luZG93XG4gICAgcmV0dXJuIHdpbmRvd1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7V2xSZWdpc3RyeVByb3h5fXJlZ2lzdHJ5XG4gICAqIEBwYXJhbSB7T2Zmc2NyZWVuQ2FudmFzfSBvZmZzY3JlZW5DYW52YXNcbiAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9Z2xcbiAgICovXG4gIGNvbnN0cnVjdG9yIChyZWdpc3RyeSwgb2Zmc2NyZWVuQ2FudmFzLCBnbCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtXbFJlZ2lzdHJ5UHJveHl9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuX3JlZ2lzdHJ5ID0gcmVnaXN0cnlcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2Zmc2NyZWVuQ2FudmFzfVxuICAgICAqL1xuICAgIHRoaXMuX29mZnNjcmVlbkNhbnZhcyA9IG9mZnNjcmVlbkNhbnZhc1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHRoaXMuX2dsID0gZ2xcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7R3JXZWJHbFByb3h5fG51bGx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl93ZWJHTCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7V2xDb21wb3NpdG9yUHJveHl8bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2NvbXBvc2l0b3IgPSBudWxsXG4gICAgLyoqXG4gICAgICogQHR5cGUge1dsU2hlbGxQcm94eXxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc2hlbGwgPSBudWxsXG4gICAgLyoqXG4gICAgICogQHR5cGUge1dsU2VhdFByb3h5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc2VhdCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7V2xTdXJmYWNlUHJveHl8bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3N1cmZhY2UgPSBudWxsXG4gICAgLyoqXG4gICAgICogQHR5cGUge1dsU2hlbGxTdXJmYWNlUHJveHl8bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3NoZWxsU3VyZmFjZSA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7R0xCdWZmZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9nbEJ1ZmZlciA9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiAgTm90aWZ5IHRoZSBjbGllbnQgb2YgZ2xvYmFsIG9iamVjdHMuXG4gICAqXG4gICAqICBUaGUgZXZlbnQgbm90aWZpZXMgdGhlIGNsaWVudCB0aGF0IGEgZ2xvYmFsIG9iamVjdCB3aXRoXG4gICAqICB0aGUgZ2l2ZW4gbmFtZSBpcyBub3cgYXZhaWxhYmxlLCBhbmQgaXQgaW1wbGVtZW50cyB0aGVcbiAgICogIGdpdmVuIHZlcnNpb24gb2YgdGhlIGdpdmVuIGludGVyZmFjZS5cbiAgICpcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5hbWUgbnVtZXJpYyBuYW1lIG9mIHRoZSBnbG9iYWwgb2JqZWN0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnRlcmZhY2VfIGludGVyZmFjZSBpbXBsZW1lbnRlZCBieSB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2ZXJzaW9uIGludGVyZmFjZSB2ZXJzaW9uXG4gICAqXG4gICAqIEBzaW5jZSAxXG4gICAqXG4gICAqL1xuICBnbG9iYWwgKG5hbWUsIGludGVyZmFjZV8sIHZlcnNpb24pIHtcbiAgICBzd2l0Y2ggKGludGVyZmFjZV8pIHtcbiAgICAgIGNhc2UgV2xDb21wb3NpdG9yUHJveHkucHJvdG9jb2xOYW1lOiB7XG4gICAgICAgIHRoaXMuX2NvbXBvc2l0b3IgPSB0aGlzLl9yZWdpc3RyeS5iaW5kKG5hbWUsIFdsQ29tcG9zaXRvclByb3h5LnByb3RvY29sTmFtZSwgV2xDb21wb3NpdG9yUHJveHksIHZlcnNpb24pXG4gICAgICAgIHRoaXMuX3N1cmZhY2UgPSB0aGlzLl9jb21wb3NpdG9yLmNyZWF0ZVN1cmZhY2UoKVxuICAgICAgICB0aGlzLl9vbkZyYW1lID0gZnJhbWUodGhpcy5fc3VyZmFjZSlcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgY2FzZSBHcldlYkdsUHJveHkucHJvdG9jb2xOYW1lOiB7XG4gICAgICAgIHRoaXMuX3dlYkdMID0gdGhpcy5fcmVnaXN0cnkuYmluZChuYW1lLCBHcldlYkdsUHJveHkucHJvdG9jb2xOYW1lLCBHcldlYkdsUHJveHksIHZlcnNpb24pXG4gICAgICAgIHRoaXMuX2dsQnVmZmVyID0gR0xCdWZmZXIuY3JlYXRlKHRoaXMuX3dlYkdMLCB0aGlzLl9vZmZzY3JlZW5DYW52YXMpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGNhc2UgV2xTaGVsbFByb3h5LnByb3RvY29sTmFtZToge1xuICAgICAgICB0aGlzLl9zaGVsbCA9IHRoaXMuX3JlZ2lzdHJ5LmJpbmQobmFtZSwgV2xTaGVsbFByb3h5LnByb3RvY29sTmFtZSwgV2xTaGVsbFByb3h5LCB2ZXJzaW9uKVxuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBjYXNlIFdsU2VhdFByb3h5LnByb3RvY29sTmFtZToge1xuICAgICAgICB0aGlzLl9zZWF0ID0gdGhpcy5fcmVnaXN0cnkuYmluZChuYW1lLCBXbFNlYXRQcm94eS5wcm90b2NvbE5hbWUsIFdsU2VhdFByb3h5LCB2ZXJzaW9uKVxuICAgICAgICB0aGlzLl9zZWF0Lmxpc3RlbmVyID0gdGhpc1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGluaXQgKCkge1xuICAgIHRoaXMuX3NoZWxsU3VyZmFjZSA9IHRoaXMuX3NoZWxsLmdldFNoZWxsU3VyZmFjZSh0aGlzLl9zdXJmYWNlKVxuICAgIHRoaXMuX3NoZWxsU3VyZmFjZS5saXN0ZW5lciA9IHRoaXNcbiAgICB0aGlzLl9zaGVsbFN1cmZhY2Uuc2V0VG9wbGV2ZWwoKVxuICAgIHRoaXMuX3NoZWxsU3VyZmFjZS5zZXRUaXRsZSgnU2ltcGxlIFdlYkdMJylcbiAgICB0aGlzLl9kcmF3U3RhdGUgPSBpbml0RHJhdyh0aGlzLl9nbClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn10aW1lXG4gICAqL1xuICBhc3luYyBkcmF3ICh0aW1lKSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGRyYXdTY2VuZSh0aGlzLl9nbCwgdGhpcy5fZHJhd1N0YXRlLCB0aW1lKVxuICAgICAgdGhpcy5fZ2xCdWZmZXIudHJhbnNmZXIoKVxuICAgICAgdGhpcy5fc3VyZmFjZS5hdHRhY2godGhpcy5fZ2xCdWZmZXIuYnVmZmVyUHJveHksIDAsIDApXG4gICAgICB0aGlzLl9zdXJmYWNlLmRhbWFnZSgwLCAwLCB0aGlzLl9vZmZzY3JlZW5DYW52YXMud2lkdGgsIHRoaXMuX29mZnNjcmVlbkNhbnZhcy5oZWlnaHQpXG5cbiAgICAgIC8vIFdhaXQgZm9yIHRoZSBjb21wb3NpdG9yIHRvIHNpZ25hbCB0aGF0IHdlIGNhbiBkcmF3IHRoZSBuZXh0IGZyYW1lLlxuICAgICAgLy8gTm90ZSB0aGF0IHVzaW5nICdhd2FpdCcgaGVyZSB3b3VsZCByZXN1bHQgaW4gYSBkZWFkbG9jayBhcyB0aGUgZXZlbnQgbG9vcCB3b3VsZCBiZSBibG9ja2VkLCBhbmQgdGhlIGV2ZW50XG4gICAgICAvLyB0aGF0IHJlc29sdmVzIHRoZSBhd2FpdCBzdGF0ZSB3b3VsZCBuZXZlciBiZSBwaWNrZWQgdXAgYnkgdGhlIGJsb2NrZWQgZXZlbnQgbG9vcC5cbiAgICAgIHRoaXMuX29uRnJhbWUoKS50aGVuKHRpbWUgPT4gdGhpcy5kcmF3KHRpbWUpKVxuXG4gICAgICAvLyBzZXJpYWwgaXMgb25seSByZXF1aXJlZCBpZiBvdXIgYnVmZmVyIGNvbnRlbnRzIHdvdWxkIHRha2UgYSBsb25nIHRpbWUgdG8gc2VuZCB0byB0aGUgY29tcG9zaXRvciBpZS4gaW4gYSBuZXR3b3JrIHJlbW90ZSBjYXNlXG4gICAgICB0aGlzLl9zdXJmYWNlLmNvbW1pdCgwKVxuICAgICAgZGlzcGxheS5mbHVzaCgpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn1uYW1lXG4gICAqL1xuICBnbG9iYWxSZW1vdmUgKG5hbWUpIHtcbiAgICAvLyBGSVhNRSBrZWVwIHRyYWNrIG9mIHRoZSBuYW1lIG51bWJlciBvZiB0aGUgZ2xvYmFscyB3ZSBiaW5kIHNvIHdlIGNhbiBkbyBjbGVhbnVwIGlmIGEgZ2xvYmFsIHNob3VsZCBnbyBhd2F5LlxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqICBUaGUgY29uZmlndXJlIGV2ZW50IGFza3MgdGhlIGNsaWVudCB0byByZXNpemUgaXRzIHN1cmZhY2UuXG4gICAqXG4gICAqICBUaGUgc2l6ZSBpcyBhIGhpbnQsIGluIHRoZSBzZW5zZSB0aGF0IHRoZSBjbGllbnQgaXMgZnJlZSB0b1xuICAgKiAgaWdub3JlIGl0IGlmIGl0IGRvZXNuJ3QgcmVzaXplLCBwaWNrIGEgc21hbGxlciBzaXplICh0b1xuICAgKiAgc2F0aXNmeSBhc3BlY3QgcmF0aW8gb3IgcmVzaXplIGluIHN0ZXBzIG9mIE54TSBwaXhlbHMpLlxuICAgKlxuICAgKiAgVGhlIGVkZ2VzIHBhcmFtZXRlciBwcm92aWRlcyBhIGhpbnQgYWJvdXQgaG93IHRoZSBzdXJmYWNlXG4gICAqICB3YXMgcmVzaXplZC4gVGhlIGNsaWVudCBtYXkgdXNlIHRoaXMgaW5mb3JtYXRpb24gdG8gZGVjaWRlXG4gICAqICBob3cgdG8gYWRqdXN0IGl0cyBjb250ZW50IHRvIHRoZSBuZXcgc2l6ZSAoZS5nLiBhIHNjcm9sbGluZ1xuICAgKiAgYXJlYSBtaWdodCBhZGp1c3QgaXRzIGNvbnRlbnQgcG9zaXRpb24gdG8gbGVhdmUgdGhlIHZpZXdhYmxlXG4gICAqICBjb250ZW50IHVubW92ZWQpLlxuICAgKlxuICAgKiAgVGhlIGNsaWVudCBpcyBmcmVlIHRvIGRpc21pc3MgYWxsIGJ1dCB0aGUgbGFzdCBjb25maWd1cmVcbiAgICogIGV2ZW50IGl0IHJlY2VpdmVkLlxuICAgKlxuICAgKiAgVGhlIHdpZHRoIGFuZCBoZWlnaHQgYXJndW1lbnRzIHNwZWNpZnkgdGhlIHNpemUgb2YgdGhlIHdpbmRvd1xuICAgKiAgaW4gc3VyZmFjZS1sb2NhbCBjb29yZGluYXRlcy5cbiAgICpcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVkZ2VzIGhvdyB0aGUgc3VyZmFjZSB3YXMgcmVzaXplZFxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggbmV3IHdpZHRoIG9mIHRoZSBzdXJmYWNlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgbmV3IGhlaWdodCBvZiB0aGUgc3VyZmFjZVxuICAgKlxuICAgKiBAc2luY2UgMVxuICAgKlxuICAgKi9cbiAgY29uZmlndXJlIChlZGdlcywgd2lkdGgsIGhlaWdodCkgeyAvKiBOT09QICovIH1cblxuICAvKipcbiAgICpcbiAgICogIFBpbmcgYSBjbGllbnQgdG8gY2hlY2sgaWYgaXQgaXMgcmVjZWl2aW5nIGV2ZW50cyBhbmQgc2VuZGluZ1xuICAgKiAgcmVxdWVzdHMuIEEgY2xpZW50IGlzIGV4cGVjdGVkIHRvIHJlcGx5IHdpdGggYSBwb25nIHJlcXVlc3QuXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZXJpYWwgc2VyaWFsIG51bWJlciBvZiB0aGUgcGluZ1xuICAgKlxuICAgKiBAc2luY2UgMVxuICAgKlxuICAgKi9cbiAgcGluZyAoc2VyaWFsKSB7XG4gICAgdGhpcy5fc2hlbGxTdXJmYWNlLnBvbmcoc2VyaWFsKVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqICBUaGUgcG9wdXBfZG9uZSBldmVudCBpcyBzZW50IG91dCB3aGVuIGEgcG9wdXAgZ3JhYiBpcyBicm9rZW4sXG4gICAqICB0aGF0IGlzLCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBhIHN1cmZhY2UgdGhhdCBkb2Vzbid0IGJlbG9uZ1xuICAgKiAgdG8gdGhlIGNsaWVudCBvd25pbmcgdGhlIHBvcHVwIHN1cmZhY2UuXG4gICAqXG4gICAqXG4gICAqXG4gICAqIEBzaW5jZSAxXG4gICAqXG4gICAqL1xuICBwb3B1cERvbmUgKCkgeyAvKiBOT09QICovIH1cblxuICAvKipcbiAgICpcbiAgICogIFRoaXMgaXMgZW1pdHRlZCB3aGVuZXZlciBhIHNlYXQgZ2FpbnMgb3IgbG9zZXMgdGhlIHBvaW50ZXIsXG4gICAqICBrZXlib2FyZCBvciB0b3VjaCBjYXBhYmlsaXRpZXMuICBUaGUgYXJndW1lbnQgaXMgYSBjYXBhYmlsaXR5XG4gICAqICBlbnVtIGNvbnRhaW5pbmcgdGhlIGNvbXBsZXRlIHNldCBvZiBjYXBhYmlsaXRpZXMgdGhpcyBzZWF0IGhhcy5cbiAgICpcbiAgICogIFdoZW4gdGhlIHBvaW50ZXIgY2FwYWJpbGl0eSBpcyBhZGRlZCwgYSBjbGllbnQgbWF5IGNyZWF0ZSBhXG4gICAqICB3bF9wb2ludGVyIG9iamVjdCB1c2luZyB0aGUgd2xfc2VhdC5nZXRfcG9pbnRlciByZXF1ZXN0LiBUaGlzIG9iamVjdFxuICAgKiAgd2lsbCByZWNlaXZlIHBvaW50ZXIgZXZlbnRzIHVudGlsIHRoZSBjYXBhYmlsaXR5IGlzIHJlbW92ZWQgaW4gdGhlXG4gICAqICBmdXR1cmUuXG4gICAqXG4gICAqICBXaGVuIHRoZSBwb2ludGVyIGNhcGFiaWxpdHkgaXMgcmVtb3ZlZCwgYSBjbGllbnQgc2hvdWxkIGRlc3Ryb3kgdGhlXG4gICAqICB3bF9wb2ludGVyIG9iamVjdHMgYXNzb2NpYXRlZCB3aXRoIHRoZSBzZWF0IHdoZXJlIHRoZSBjYXBhYmlsaXR5IHdhc1xuICAgKiAgcmVtb3ZlZCwgdXNpbmcgdGhlIHdsX3BvaW50ZXIucmVsZWFzZSByZXF1ZXN0LiBObyBmdXJ0aGVyIHBvaW50ZXJcbiAgICogIGV2ZW50cyB3aWxsIGJlIHJlY2VpdmVkIG9uIHRoZXNlIG9iamVjdHMuXG4gICAqXG4gICAqICBJbiBzb21lIGNvbXBvc2l0b3JzLCBpZiBhIHNlYXQgcmVnYWlucyB0aGUgcG9pbnRlciBjYXBhYmlsaXR5IGFuZCBhXG4gICAqICBjbGllbnQgaGFzIGEgcHJldmlvdXNseSBvYnRhaW5lZCB3bF9wb2ludGVyIG9iamVjdCBvZiB2ZXJzaW9uIDQgb3JcbiAgICogIGxlc3MsIHRoYXQgb2JqZWN0IG1heSBzdGFydCBzZW5kaW5nIHBvaW50ZXIgZXZlbnRzIGFnYWluLiBUaGlzXG4gICAqICBiZWhhdmlvciBpcyBjb25zaWRlcmVkIGEgbWlzaW50ZXJwcmV0YXRpb24gb2YgdGhlIGludGVuZGVkIGJlaGF2aW9yXG4gICAqICBhbmQgbXVzdCBub3QgYmUgcmVsaWVkIHVwb24gYnkgdGhlIGNsaWVudC4gd2xfcG9pbnRlciBvYmplY3RzIG9mXG4gICAqICB2ZXJzaW9uIDUgb3IgbGF0ZXIgbXVzdCBub3Qgc2VuZCBldmVudHMgaWYgY3JlYXRlZCBiZWZvcmUgdGhlIG1vc3RcbiAgICogIHJlY2VudCBldmVudCBub3RpZnlpbmcgdGhlIGNsaWVudCBvZiBhbiBhZGRlZCBwb2ludGVyIGNhcGFiaWxpdHkuXG4gICAqXG4gICAqICBUaGUgYWJvdmUgYmVoYXZpb3IgYWxzbyBhcHBsaWVzIHRvIHdsX2tleWJvYXJkIGFuZCB3bF90b3VjaCB3aXRoIHRoZVxuICAgKiAga2V5Ym9hcmQgYW5kIHRvdWNoIGNhcGFiaWxpdGllcywgcmVzcGVjdGl2ZWx5LlxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2FwYWJpbGl0aWVzIGNhcGFiaWxpdGllcyBvZiB0aGUgc2VhdFxuICAgKlxuICAgKiBAc2luY2UgMVxuICAgKlxuICAgKi9cbiAgY2FwYWJpbGl0aWVzIChjYXBhYmlsaXRpZXMpIHtcbiAgICBpZiAoY2FwYWJpbGl0aWVzICYgV2xTZWF0UHJveHkuQ2FwYWJpbGl0eS5wb2ludGVyKSB7XG4gICAgICB0aGlzLl9wb2ludGVyID0gdGhpcy5fc2VhdC5nZXRQb2ludGVyKClcbiAgICAgIHRoaXMuX3BvaW50ZXIubGlzdGVuZXIgPSB0aGlzXG4gICAgfSBlbHNlIGlmICh0aGlzLl9wb2ludGVyKSB7XG4gICAgICB0aGlzLl9wb2ludGVyLnJlbGVhc2UoKVxuICAgICAgdGhpcy5fcG9pbnRlciA9IG51bGxcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogIEluIGEgbXVsdGlzZWF0IGNvbmZpZ3VyYXRpb24gdGhpcyBjYW4gYmUgdXNlZCBieSB0aGUgY2xpZW50IHRvIGhlbHBcbiAgICogIGlkZW50aWZ5IHdoaWNoIHBoeXNpY2FsIGRldmljZXMgdGhlIHNlYXQgcmVwcmVzZW50cy4gQmFzZWQgb25cbiAgICogIHRoZSBzZWF0IGNvbmZpZ3VyYXRpb24gdXNlZCBieSB0aGUgY29tcG9zaXRvci5cbiAgICpcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgc2VhdCBpZGVudGlmaWVyXG4gICAqXG4gICAqIEBzaW5jZSAyXG4gICAqXG4gICAqL1xuICBuYW1lIChuYW1lKSB7IC8qIE5PT1AgKi8gfVxuXG4gIGF4aXMgKHRpbWUsIGF4aXMsIHZhbHVlKSB7IC8qIE5PT1AgKi8gfVxuXG4gIGF4aXNEaXNjcmV0ZSAoYXhpcywgZGlzY3JldGUpIHsgLyogTk9PUCAqLyB9XG5cbiAgYXhpc1NvdXJjZSAoYXhpc1NvdXJjZSkgeyAvKiBOT09QICovIH1cblxuICBheGlzU3RvcCAodGltZSwgYXhpcykgeyAvKiBOT09QICovIH1cblxuICBidXR0b24gKHNlcmlhbCwgdGltZSwgYnV0dG9uLCBzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSAmIFdsUG9pbnRlclByb3h5LkJ1dHRvblN0YXRlLnByZXNzZWQpIHtcbiAgICAgIHRoaXMuX3NoZWxsU3VyZmFjZS5tb3ZlKHRoaXMuX3NlYXQsIHNlcmlhbClcbiAgICB9XG4gIH1cblxuICBlbnRlciAoc2VyaWFsLCBzdXJmYWNlLCBzdXJmYWNlWCwgc3VyZmFjZVkpIHsgLyogTk9PUCAqLyB9XG5cbiAgZnJhbWUgKCkgeyAvKiBOT09QICovIH1cblxuICBsZWF2ZSAoc2VyaWFsLCBzdXJmYWNlKSB7IC8qIE5PT1AgKi8gfVxuXG4gIG1vdGlvbiAodGltZSwgc3VyZmFjZVgsIHN1cmZhY2VZKSB7IC8qIE5PT1AgKi8gfVxufVxuXG5hc3luYyBmdW5jdGlvbiBtYWluICgpIHtcbiAgLy8gY3JlYXRlIGEgbmV3IHdpbmRvdyB3aXRoIHNvbWUgYnVmZmVyc1xuICBjb25zdCB3aW5kb3cgPSBXaW5kb3cuY3JlYXRlKDgwMCwgNjAwKVxuXG4gIC8vIGNyZWF0ZSBhIHN5bmMgcHJvbWlzZVxuICBjb25zdCBzeW5jUHJvbWlzZSA9IGRpc3BsYXkuc3luYygpXG5cbiAgLy8gZmx1c2ggb3V0IHdpbmRvdyBjcmVhdGlvbiAmIHN5bmMgcmVxdWVzdHMgdG8gdGhlIGNvbXBvc2l0b3JcbiAgZGlzcGxheS5mbHVzaCgpXG5cbiAgLy8gd2FpdCBmb3IgY29tcG9zaXRvciB0byBoYXZlIHByb2Nlc3NlZCBhbGwgb3VyIG91dGdvaW5nIHJlcXVlc3RzXG4gIGF3YWl0IHN5bmNQcm9taXNlXG5cbiAgLy8gTm93IGJlZ2luIGRyYXdpbmcgYWZ0ZXIgdGhlIGNvbXBvc2l0b3IgaXMgZG9uZSBwcm9jZXNzaW5nIGFsbCBvdXIgcmVxdWVzdHNcbiAgd2luZG93LmluaXQoKVxuICB3aW5kb3cuZHJhdygwKVxuICBkaXNwbGF5LmZsdXNoKClcblxuICAvLyB3YWl0IGZvciB0aGUgZGlzcGxheSBjb25uZWN0aW9uIHRvIGNsb3NlXG4gIHRyeSB7XG4gICAgYXdhaXQgZGlzcGxheS5vbkNsb3NlKClcbiAgICBjb25zb2xlLmxvZygnQXBwbGljYXRpb24gZXhpdC4nKVxuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5lcnJvcignQXBwbGljYXRpb24gdGVybWluYXRlZCB3aXRoIGVycm9yLicpXG4gICAgY29uc29sZS5lcnJvcihlLnN0YWNrVHJhY2UpXG4gIH1cbn1cblxubWFpbigpXG4iLCJpbXBvcnQgeyBtYXQ0LCB2ZWMzIH0gZnJvbSAnZ2wtbWF0cml4J1xuXG4vL1xuLy8gaW5pdEJ1ZmZlcnNcbi8vXG4vLyBJbml0aWFsaXplIHRoZSBidWZmZXJzIHdlJ2xsIG5lZWQuIEZvciB0aGlzIGRlbW8sIHdlIGp1c3Rcbi8vIGhhdmUgb25lIG9iamVjdCAtLSBhIHNpbXBsZSB0d28tZGltZW5zaW9uYWwgc3F1YXJlLlxuLy9cbmZ1bmN0aW9uIGluaXRCdWZmZXJzIChnbCkge1xuICAvLyBDcmVhdGUgYSBidWZmZXIgZm9yIHRoZSBzcXVhcmUncyBwb3NpdGlvbnMuXG4gIGNvbnN0IHBvc2l0aW9uQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKClcblxuICAvLyBTZWxlY3QgdGhlIHBvc2l0aW9uQnVmZmVyIGFzIHRoZSBvbmUgdG8gYXBwbHkgYnVmZmVyXG4gIC8vIG9wZXJhdGlvbnMgdG8gZnJvbSBoZXJlIG91dC5cbiAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHBvc2l0aW9uQnVmZmVyKVxuXG4gIC8vIE5vdyBjcmVhdGUgYW4gYXJyYXkgb2YgcG9zaXRpb25zIGZvciB0aGUgc3F1YXJlLlxuICBjb25zdCBwb3NpdGlvbnMgPSBbXG4gICAgMS4wLCAxLjAsXG4gICAgLTEuMCwgMS4wLFxuICAgIDEuMCwgLTEuMCxcbiAgICAtMS4wLCAtMS4wXG4gIF1cblxuICAvLyBOb3cgcGFzcyB0aGUgbGlzdCBvZiBwb3NpdGlvbnMgaW50byBXZWJHTCB0byBidWlsZCB0aGVcbiAgLy8gc2hhcGUuIFdlIGRvIHRoaXMgYnkgY3JlYXRpbmcgYSBGbG9hdDMyQXJyYXkgZnJvbSB0aGVcbiAgLy8gSmF2YVNjcmlwdCBhcnJheSwgdGhlbiB1c2UgaXQgdG8gZmlsbCB0aGUgY3VycmVudCBidWZmZXIuXG4gIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucyksIGdsLlNUQVRJQ19EUkFXKVxuXG4gIC8vIE5vdyBzZXQgdXAgdGhlIGNvbG9ycyBmb3IgdGhlIHZlcnRpY2VzXG4gIGNvbnN0IGNvbG9ycyA9IFtcbiAgICAxLjAsIDEuMCwgMS4wLCAxLjAsIC8vIHdoaXRlXG4gICAgMS4wLCAwLjAsIDAuMCwgMS4wLCAvLyByZWRcbiAgICAwLjAsIDEuMCwgMC4wLCAxLjAsIC8vIGdyZWVuXG4gICAgMC4wLCAwLjAsIDEuMCwgMS4wIC8vIGJsdWVcbiAgXVxuXG4gIGNvbnN0IGNvbG9yQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKClcbiAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGNvbG9yQnVmZmVyKVxuICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShjb2xvcnMpLCBnbC5TVEFUSUNfRFJBVylcblxuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uOiBwb3NpdGlvbkJ1ZmZlcixcbiAgICBjb2xvcjogY29sb3JCdWZmZXJcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSBnbFxuICogQHBhcmFtIHt7cHJvZ3JhbUluZm86IHt1bmlmb3JtTG9jYXRpb25zOiB7cHJvamVjdGlvbk1hdHJpeDogKFdlYkdMVW5pZm9ybUxvY2F0aW9ufFdlYkdMVW5pZm9ybUxvY2F0aW9uKSwgbW9kZWxWaWV3TWF0cml4OiAoV2ViR0xVbmlmb3JtTG9jYXRpb258V2ViR0xVbmlmb3JtTG9jYXRpb24pfSwgYXR0cmliTG9jYXRpb25zOiB7dmVydGV4Q29sb3I6IEdMaW50LCB2ZXJ0ZXhQb3NpdGlvbjogR0xpbnR9LCBwcm9ncmFtOiAqfSwgYnVmZmVyczoge2NvbG9yLCBwb3NpdGlvbn19fSBwcm9ncmFtU3RhdGVcbiAqIEBwYXJhbSB0aW1lXG4gKi9cbmZ1bmN0aW9uIGRyYXdTY2VuZSAoZ2wsIHsgcHJvZ3JhbUluZm8sIGJ1ZmZlcnMgfSwgdGltZSkge1xuICBjb25zdCBzcXVhcmVSb3RhdGlvbiA9IHRpbWUgKiAwLjAwMVxuICBnbC5jbGVhckNvbG9yKDAuMCwgMC4wLCAwLjAsIDAuNykgLy8gQ2xlYXIgdG8gYmxhY2ssIGZ1bGx5IG9wYXF1ZVxuICBnbC5jbGVhckRlcHRoKDEuMCkgLy8gQ2xlYXIgZXZlcnl0aGluZ1xuICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCkgLy8gRW5hYmxlIGRlcHRoIHRlc3RpbmdcbiAgZ2wuZGVwdGhGdW5jKGdsLkxFUVVBTCkgLy8gTmVhciB0aGluZ3Mgb2JzY3VyZSBmYXIgdGhpbmdzXG5cbiAgLy8gQ2xlYXIgdGhlIGNhbnZhcyBiZWZvcmUgd2Ugc3RhcnQgZHJhd2luZyBvbiBpdC5cbiAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQpXG5cbiAgLy8gQ3JlYXRlIGEgcGVyc3BlY3RpdmUgbWF0cml4LCBhIHNwZWNpYWwgbWF0cml4IHRoYXQgaXNcbiAgLy8gdXNlZCB0byBzaW11bGF0ZSB0aGUgZGlzdG9ydGlvbiBvZiBwZXJzcGVjdGl2ZSBpbiBhIGNhbWVyYS5cbiAgLy8gT3VyIGZpZWxkIG9mIHZpZXcgaXMgNDUgZGVncmVlcywgd2l0aCBhIHdpZHRoL2hlaWdodFxuICAvLyByYXRpbyB0aGF0IG1hdGNoZXMgdGhlIGRpc3BsYXkgc2l6ZSBvZiB0aGUgY2FudmFzXG4gIC8vIGFuZCB3ZSBvbmx5IHdhbnQgdG8gc2VlIG9iamVjdHMgYmV0d2VlbiAwLjEgdW5pdHNcbiAgLy8gYW5kIDEwMCB1bml0cyBhd2F5IGZyb20gdGhlIGNhbWVyYS5cbiAgY29uc3QgZmllbGRPZlZpZXcgPSA0NSAqIE1hdGguUEkgLyAxODAgLy8gaW4gcmFkaWFuc1xuICBjb25zdCBhc3BlY3QgPSBnbC5jYW52YXMud2lkdGggLyBnbC5jYW52YXMuaGVpZ2h0XG4gIGNvbnN0IHpOZWFyID0gMC4xXG4gIGNvbnN0IHpGYXIgPSAxMDAuMFxuICBjb25zdCBwcm9qZWN0aW9uTWF0cml4ID0gbWF0NC5jcmVhdGUoKVxuXG4gIC8vIG5vdGU6IGdsbWF0cml4LmpzIGFsd2F5cyBoYXMgdGhlIGZpcnN0IGFyZ3VtZW50XG4gIC8vIGFzIHRoZSBkZXN0aW5hdGlvbiB0byByZWNlaXZlIHRoZSByZXN1bHQuXG4gIG1hdDQucGVyc3BlY3RpdmUocHJvamVjdGlvbk1hdHJpeCxcbiAgICBmaWVsZE9mVmlldyxcbiAgICBhc3BlY3QsXG4gICAgek5lYXIsXG4gICAgekZhcilcblxuICAvLyBTZXQgdGhlIGRyYXdpbmcgcG9zaXRpb24gdG8gdGhlIFwiaWRlbnRpdHlcIiBwb2ludCwgd2hpY2ggaXNcbiAgLy8gdGhlIGNlbnRlciBvZiB0aGUgc2NlbmUuXG4gIGNvbnN0IG1vZGVsVmlld01hdHJpeCA9IG1hdDQuY3JlYXRlKClcblxuICAvLyBOb3cgbW92ZSB0aGUgZHJhd2luZyBwb3NpdGlvbiBhIGJpdCB0byB3aGVyZSB3ZSB3YW50IHRvXG4gIC8vIHN0YXJ0IGRyYXdpbmcgdGhlIHNxdWFyZS5cblxuICBtYXQ0LnRyYW5zbGF0ZShtb2RlbFZpZXdNYXRyaXgsIC8vIGRlc3RpbmF0aW9uIG1hdHJpeFxuICAgIG1vZGVsVmlld01hdHJpeCwgLy8gbWF0cml4IHRvIHRyYW5zbGF0ZVxuICAgIHZlYzMuZnJvbVZhbHVlcygtMC4wLCAwLjAsIC02LjApKSAvLyBhbW91bnQgdG8gdHJhbnNsYXRlXG4gIG1hdDQucm90YXRlKG1vZGVsVmlld01hdHJpeCwgLy8gZGVzdGluYXRpb24gbWF0cml4XG4gICAgbW9kZWxWaWV3TWF0cml4LCAvLyBtYXRyaXggdG8gcm90YXRlXG4gICAgc3F1YXJlUm90YXRpb24sIC8vIGFtb3VudCB0byByb3RhdGUgaW4gcmFkaWFuc1xuICAgIHZlYzMuZnJvbVZhbHVlcygwLCAwLCAxKSkgLy8gYXhpcyB0byByb3RhdGUgYXJvdW5kXG5cbiAgLy8gVGVsbCBXZWJHTCBob3cgdG8gcHVsbCBvdXQgdGhlIHBvc2l0aW9ucyBmcm9tIHRoZSBwb3NpdGlvblxuICAvLyBidWZmZXIgaW50byB0aGUgdmVydGV4UG9zaXRpb24gYXR0cmlidXRlXG4gIHtcbiAgICBjb25zdCBudW1Db21wb25lbnRzID0gMlxuICAgIGNvbnN0IHR5cGUgPSBnbC5GTE9BVFxuICAgIGNvbnN0IG5vcm1hbGl6ZSA9IGZhbHNlXG4gICAgY29uc3Qgc3RyaWRlID0gMFxuICAgIGNvbnN0IG9mZnNldCA9IDBcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy5wb3NpdGlvbilcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgcHJvZ3JhbUluZm8uYXR0cmliTG9jYXRpb25zLnZlcnRleFBvc2l0aW9uLFxuICAgICAgbnVtQ29tcG9uZW50cyxcbiAgICAgIHR5cGUsXG4gICAgICBub3JtYWxpemUsXG4gICAgICBzdHJpZGUsXG4gICAgICBvZmZzZXQpXG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoXG4gICAgICBwcm9ncmFtSW5mby5hdHRyaWJMb2NhdGlvbnMudmVydGV4UG9zaXRpb24pXG4gIH1cblxuICAvLyBUZWxsIFdlYkdMIGhvdyB0byBwdWxsIG91dCB0aGUgY29sb3JzIGZyb20gdGhlIGNvbG9yIGJ1ZmZlclxuICAvLyBpbnRvIHRoZSB2ZXJ0ZXhDb2xvciBhdHRyaWJ1dGUuXG4gIHtcbiAgICBjb25zdCBudW1Db21wb25lbnRzID0gNFxuICAgIGNvbnN0IHR5cGUgPSBnbC5GTE9BVFxuICAgIGNvbnN0IG5vcm1hbGl6ZSA9IGZhbHNlXG4gICAgY29uc3Qgc3RyaWRlID0gMFxuICAgIGNvbnN0IG9mZnNldCA9IDBcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVycy5jb2xvcilcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKFxuICAgICAgcHJvZ3JhbUluZm8uYXR0cmliTG9jYXRpb25zLnZlcnRleENvbG9yLFxuICAgICAgbnVtQ29tcG9uZW50cyxcbiAgICAgIHR5cGUsXG4gICAgICBub3JtYWxpemUsXG4gICAgICBzdHJpZGUsXG4gICAgICBvZmZzZXQpXG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoXG4gICAgICBwcm9ncmFtSW5mby5hdHRyaWJMb2NhdGlvbnMudmVydGV4Q29sb3IpXG4gIH1cblxuICAvLyBUZWxsIFdlYkdMIHRvIHVzZSBvdXIgcHJvZ3JhbSB3aGVuIGRyYXdpbmdcbiAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtSW5mby5wcm9ncmFtKVxuXG4gIC8vIFNldCB0aGUgc2hhZGVyIHVuaWZvcm1zXG4gIGdsLnVuaWZvcm1NYXRyaXg0ZnYoXG4gICAgcHJvZ3JhbUluZm8udW5pZm9ybUxvY2F0aW9ucy5wcm9qZWN0aW9uTWF0cml4LFxuICAgIGZhbHNlLFxuICAgIHByb2plY3Rpb25NYXRyaXgpXG4gIGdsLnVuaWZvcm1NYXRyaXg0ZnYoXG4gICAgcHJvZ3JhbUluZm8udW5pZm9ybUxvY2F0aW9ucy5tb2RlbFZpZXdNYXRyaXgsXG4gICAgZmFsc2UsXG4gICAgbW9kZWxWaWV3TWF0cml4KVxuXG4gIGNvbnN0IG9mZnNldCA9IDBcbiAgY29uc3QgdmVydGV4Q291bnQgPSA0XG4gIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIG9mZnNldCwgdmVydGV4Q291bnQpXG59XG5cbi8vXG4vLyBJbml0aWFsaXplIGEgc2hhZGVyIHByb2dyYW0sIHNvIFdlYkdMIGtub3dzIGhvdyB0byBkcmF3IG91ciBkYXRhXG4vL1xuZnVuY3Rpb24gaW5pdFNoYWRlclByb2dyYW0gKGdsLCB2c1NvdXJjZSwgZnNTb3VyY2UpIHtcbiAgY29uc3QgdmVydGV4U2hhZGVyID0gbG9hZFNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdnNTb3VyY2UpXG4gIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gbG9hZFNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmc1NvdXJjZSlcblxuICAvLyBDcmVhdGUgdGhlIHNoYWRlciBwcm9ncmFtXG4gIGNvbnN0IHNoYWRlclByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKClcbiAgZ2wuYXR0YWNoU2hhZGVyKHNoYWRlclByb2dyYW0sIHZlcnRleFNoYWRlcilcbiAgZ2wuYXR0YWNoU2hhZGVyKHNoYWRlclByb2dyYW0sIGZyYWdtZW50U2hhZGVyKVxuICBnbC5saW5rUHJvZ3JhbShzaGFkZXJQcm9ncmFtKVxuXG4gIC8vIElmIGNyZWF0aW5nIHRoZSBzaGFkZXIgcHJvZ3JhbSBmYWlsZWQsIGFsZXJ0XG4gIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihzaGFkZXJQcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcbiAgICBjb25zb2xlLmVycm9yKCdVbmFibGUgdG8gaW5pdGlhbGl6ZSB0aGUgc2hhZGVyIHByb2dyYW06ICcgKyBnbC5nZXRQcm9ncmFtSW5mb0xvZyhzaGFkZXJQcm9ncmFtKSlcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIHNoYWRlclByb2dyYW1cbn1cblxuLy9cbi8vIGNyZWF0ZXMgYSBzaGFkZXIgb2YgdGhlIGdpdmVuIHR5cGUsIHVwbG9hZHMgdGhlIHNvdXJjZSBhbmRcbi8vIGNvbXBpbGVzIGl0LlxuLy9cbmZ1bmN0aW9uIGxvYWRTaGFkZXIgKGdsLCB0eXBlLCBzb3VyY2UpIHtcbiAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpXG5cbiAgLy8gU2VuZCB0aGUgc291cmNlIHRvIHRoZSBzaGFkZXIgb2JqZWN0XG4gIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSlcblxuICAvLyBDb21waWxlIHRoZSBzaGFkZXIgcHJvZ3JhbVxuICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcilcblxuICAvLyBTZWUgaWYgaXQgY29tcGlsZWQgc3VjY2Vzc2Z1bGx5XG4gIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgY29uc29sZS5lcnJvcignQW4gZXJyb3Igb2NjdXJyZWQgY29tcGlsaW5nIHRoZSBzaGFkZXJzOiAnICsgZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKVxuICAgIGdsLmRlbGV0ZVNoYWRlcihzaGFkZXIpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHJldHVybiBzaGFkZXJcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH1nbFxuICogQHJldHVybiB7e3Byb2dyYW1JbmZvOiB7dW5pZm9ybUxvY2F0aW9uczoge3Byb2plY3Rpb25NYXRyaXg6IChXZWJHTFVuaWZvcm1Mb2NhdGlvbnxXZWJHTFVuaWZvcm1Mb2NhdGlvbiksIG1vZGVsVmlld01hdHJpeDogKFdlYkdMVW5pZm9ybUxvY2F0aW9ufFdlYkdMVW5pZm9ybUxvY2F0aW9uKX0sIGF0dHJpYkxvY2F0aW9uczoge3ZlcnRleENvbG9yOiBHTGludCwgdmVydGV4UG9zaXRpb246IEdMaW50fSwgcHJvZ3JhbTogKn0sIGJ1ZmZlcnM6IHtjb2xvciwgcG9zaXRpb259fX1cbiAqL1xuZnVuY3Rpb24gaW5pdERyYXcgKGdsKSB7XG4gIC8vIFZlcnRleCBzaGFkZXIgcHJvZ3JhbVxuICBjb25zdCB2c1NvdXJjZSA9IGBcbiAgICBhdHRyaWJ1dGUgdmVjNCBhVmVydGV4UG9zaXRpb247XG4gICAgYXR0cmlidXRlIHZlYzQgYVZlcnRleENvbG9yO1xuXG4gICAgdW5pZm9ybSBtYXQ0IHVNb2RlbFZpZXdNYXRyaXg7XG4gICAgdW5pZm9ybSBtYXQ0IHVQcm9qZWN0aW9uTWF0cml4O1xuXG4gICAgdmFyeWluZyBsb3dwIHZlYzQgdkNvbG9yO1xuXG4gICAgdm9pZCBtYWluKHZvaWQpIHtcbiAgICAgIGdsX1Bvc2l0aW9uID0gdVByb2plY3Rpb25NYXRyaXggKiB1TW9kZWxWaWV3TWF0cml4ICogYVZlcnRleFBvc2l0aW9uO1xuICAgICAgdkNvbG9yID0gYVZlcnRleENvbG9yO1xuICAgIH1cbiAgYFxuXG4gIC8vIEZyYWdtZW50IHNoYWRlciBwcm9ncmFtXG4gIGNvbnN0IGZzU291cmNlID0gYFxuICAgIHZhcnlpbmcgbG93cCB2ZWM0IHZDb2xvcjtcblxuICAgIHZvaWQgbWFpbih2b2lkKSB7XG4gICAgICBnbF9GcmFnQ29sb3IgPSB2Q29sb3I7XG4gICAgfVxuICBgXG5cbiAgLy8gSW5pdGlhbGl6ZSBhIHNoYWRlciBwcm9ncmFtOyB0aGlzIGlzIHdoZXJlIGFsbCB0aGUgbGlnaHRpbmdcbiAgLy8gZm9yIHRoZSB2ZXJ0aWNlcyBhbmQgc28gZm9ydGggaXMgZXN0YWJsaXNoZWQuXG4gIGNvbnN0IHNoYWRlclByb2dyYW0gPSBpbml0U2hhZGVyUHJvZ3JhbShnbCwgdnNTb3VyY2UsIGZzU291cmNlKVxuXG4gIC8vIENvbGxlY3QgYWxsIHRoZSBpbmZvIG5lZWRlZCB0byB1c2UgdGhlIHNoYWRlciBwcm9ncmFtLlxuICAvLyBMb29rIHVwIHdoaWNoIGF0dHJpYnV0ZXMgb3VyIHNoYWRlciBwcm9ncmFtIGlzIHVzaW5nXG4gIC8vIGZvciBhVmVydGV4UG9zaXRpb24sIGFWZXZydGV4Q29sb3IgYW5kIGFsc29cbiAgLy8gbG9vayB1cCB1bmlmb3JtIGxvY2F0aW9ucy5cbiAgY29uc3QgcHJvZ3JhbUluZm8gPSB7XG4gICAgcHJvZ3JhbTogc2hhZGVyUHJvZ3JhbSxcbiAgICBhdHRyaWJMb2NhdGlvbnM6IHtcbiAgICAgIHZlcnRleFBvc2l0aW9uOiBnbC5nZXRBdHRyaWJMb2NhdGlvbihzaGFkZXJQcm9ncmFtLCAnYVZlcnRleFBvc2l0aW9uJyksXG4gICAgICB2ZXJ0ZXhDb2xvcjogZ2wuZ2V0QXR0cmliTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgJ2FWZXJ0ZXhDb2xvcicpXG4gICAgfSxcbiAgICB1bmlmb3JtTG9jYXRpb25zOiB7XG4gICAgICBwcm9qZWN0aW9uTWF0cml4OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgJ3VQcm9qZWN0aW9uTWF0cml4JyksXG4gICAgICBtb2RlbFZpZXdNYXRyaXg6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihzaGFkZXJQcm9ncmFtLCAndU1vZGVsVmlld01hdHJpeCcpXG4gICAgfVxuICB9XG5cbiAgLy8gSGVyZSdzIHdoZXJlIHdlIGNhbGwgdGhlIHJvdXRpbmUgdGhhdCBidWlsZHMgYWxsIHRoZVxuICAvLyBvYmplY3RzIHdlJ2xsIGJlIGRyYXdpbmcuXG4gIGNvbnN0IGJ1ZmZlcnMgPSBpbml0QnVmZmVycyhnbClcblxuICByZXR1cm4ge1xuICAgIHByb2dyYW1JbmZvLFxuICAgIGJ1ZmZlcnNcbiAgfVxufVxuXG5leHBvcnQge1xuICBpbml0RHJhdyxcbiAgZHJhd1NjZW5lXG59XG4iXSwic291cmNlUm9vdCI6IiJ9